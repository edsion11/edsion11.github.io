<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6语法总结（一）</title>
    <url>/2020/04/03/ES6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4>let 和 const</h4>
<p>在原来的ES5时，定义变量，函数用的var会造成变量提升，于是ES6新增了<code>let</code>和<code>const</code>语法。接下来用代码说明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]()</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span> ;j++)&#123;</span><br><span class="line">  b[j] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">b[<span class="number">6</span>]()</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
上下仅有的不同是for循环里面的<code> i </code>，<code> j </code>定义方式不同，上面定义的<code> i </code>为全局变量，for循环结束，<code> i </code>为10。而下面定义的<code> j </code>为局部变量，只在for（）｛｝的作用域内有效，于是形成了上面的结果。
<p>另外for循环的的设置循环变量括号内部是父作用域，而循环体则是子作用域。---来自阮一峰老师的博客介绍</p>
<code>var</code>的变量存在变量提升，什么意思呢，就是<code>var</code>定义的变量，在js运行时，会在运行开始的时候执行一条语句<code> var a </code>此时<code>a</code>为<code>undefined</code>，如果在定义<code>a</code>变量之前调用<code>a</code>变量,会显示<code>undefined</code>。而现在ES6为了减少这种情况，同时规范代码，新提出了<code>let</code>指令，let定义的变量，只有在let的块作用域内有效，出了作用域调用就会报错<code>// 报错ReferenceError</code><br>
<h4>暂时性死区</h4>
ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。即在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。有了这个，<code>typeof</code>就会更加安全，如果let定义之前typeof，会报错，而如果没有定义，则会输出undefined。<br>
还有一点：<code> let </code>不允许重复定义，不能同时定义相同的变量两次。
<h4>块作用域</h4>
<p>在ES5中只有全局作用域和局部作用域，带来了很多不合理的场景，所以如今ES6提出了块作用域，强调规范</p>
第一种场景，内层变量可能会覆盖外层变量。
第二种场景，用来计数的循环变量泄露为全局变量。(上面开头例子)
详见阮一峰老师的博客<a href="https://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">阮一峰-let和const</a>
<h4>关于函数声明</h4>
<p>ES5中规定：函数只能在顶层作用域或者函数作用域中声明，不能在块级作用域申明。但是浏览器中还是支持在块级作用域中申明函数，不会报错。</p>
<p>而ES6引入了块级作用域，规定块级作用域外不可引用作用域内的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnc</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
上面的代码在ES5中会输出<code>I am inside!</code>，因为类似于<code>var</code>变量，函数会var声明提前，将if作用域内的<code>function</code>会提前至if之前，即<code> var f = undefined</code>于是在ES6中回报错。
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  test.js:<span class="number">10</span></span><br><span class="line">  f();</span><br><span class="line">  ^</span><br><span class="line"><span class="built_in">TypeError</span>: f is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>
原因是ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<h4>const命令</h4>
<p><code>const</code>会声明一个只读的变量，不能更改，也不能再定义并且定义的同时要立即赋值。同时const也是存在暂时性死区和块级作用域。与之前let类似</p>
<p>const只是定义数据所在的内存地址不能变动，而不是数据不能改动，即如果const定义一个数组或者对象，数组的push()，push()方法依然有效，对象设置属性也正常，但是对const定义的数组或者对象等再次赋值，负责会报错。如果永久冻结，不能变动，有一个冻结方法是<code>Object.freeze</code></p>
<p>如果有如下的定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>正常模式会无效，而严格模式会报错（具体没有尝试，还没有具体碰到两种模式，只是了解）</p>
<h4>ES6申明变量6种方法</h4>
<ul>
  <li><code>var</code></li>
  <li><code>function</code></li>
  <li><code>let</code></li>
  <li><code>const</code></li>
  <li><code>import</code></li><a href="#">具体介绍</a>
  <li><code>class</code></li><a href="#">具体介绍</a>
</ul>
<h4>globalThis对象</h4>
<p>ES6还引入了globalThis对象，用来表示顶层对象，比如浏览器的顶层对象是<code>window</code>，WebWorker的顶层对象是<code>self</code>，Node里面是<code>global</code></p>
<span style="float:right">本次博客主要参考自阮一峰的ECMAScript6入门(一)</span>]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>let</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax交互总结</title>
    <url>/2020/03/30/Ajax%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="什么是Ajax和JSON，它们的优缺点">什么是Ajax和JSON，它们的优缺点</h4>
<ul>
<li>Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新</li>
<li>优点：可以实现异步通信效果，页面局部刷新，带来更好的用户体验</li>
<li>JSON是一种轻量级的数据交换格式，看着像对象，本质是字符串</li>
<li>优点：轻量级、易于人的阅读和编写，便于js解析，支持复合数据类型</li>
</ul>
<h4 id="Ajax的交互流程有哪几步？">Ajax的交互流程有哪几步？</h4>
<ul>
<li>创建ajax对象</li>
<code>xhr = new XMLHttpRequest</code>
<li>规定请求地址</li>
<code>xhr.open(method,url,async)</code>
<li>等待服务器相应</li>
<code>xhr.onload</code>
<li>向服务器发送请求</li>
<code>xhr.send()</code>
</ul>
<p>下面是一个验证用户名的ajax例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">username.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> usernameValue = username.value;</span><br><span class="line"><span class="comment">//将usernameValue提交给服务器，有服务器进行唯一性的校验</span></span><br><span class="line"><span class="comment">//1、创建对象 兼容处理</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">	xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2、准备发送</span></span><br><span class="line">	xhr.open(<span class="string">"get"</span>,<span class="string">"./server/checkUsername.php?uname="</span> + usernameValue,<span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//3、执行发送</span></span><br><span class="line">	xhr.send(<span class="literal">null</span>);</span><br><span class="line">	<span class="comment">//制定回调函数</span></span><br><span class="line">	xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> result = xhr.responseText;</span><br><span class="line">	<span class="keyword">var</span> username_result = <span class="built_in">document</span>.querySelector(<span class="string">"#username_result"</span>);</span><br><span class="line">	<span class="keyword">if</span>(result == <span class="string">"ok"</span>) &#123;</span><br><span class="line">	username_result.innerText = <span class="string">"用户名可以使用"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		username_result.innerText = <span class="string">"用户名已经被注册"</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="XMLHttpRequest对象在IE和Firefox中创建方式有没有不同？">XMLHttpRequest对象在IE和Firefox中创建方式有没有不同？</h4>
<span>
IE中通过new ActiveXObject()得到，Firefox中通过newXMLHttpRequest()得到.
使用jquery封装好的ajax，会避免这些问题
</span><h4 id="简述ajax的优缺点">简述ajax的优缺点</h4>
<span>
优点：
　　<li>无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）
　　<li>异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）
　　<li>前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）
　　<li>界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）
　　<li>缺点：
　　<li>ajax不支持浏览器back按钮
　　<li>安全问题 Aajax暴露了与服务器交互的细节
　　<li>对搜索引擎的支持比较弱
　　<li>破坏了Back与History后退按钮的正常行为等浏览器机制
</span>
<h4 id="get与post的区别，什么时候使用post？">get与post的区别，什么时候使用post？</h4>
<p>get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些</p>
<ul>
<li>get相对post安全性低</li>
<li>get有缓存，post没有</li>
<li>get体积小，post可以无限大</li>
<li>get的url参数可见，post不可见</li>
<li>get只接受ASCII字符的参数数据类型，post没有限制</li>
<li>get请求参数会保留历史记录，post中参数不会保留</li>
<li>get会被浏览器主动catch，post不会，需要手动设置</li>
<li>get在浏览器回退时无害，post会再次提交请求</li>
</ul>
<p>post一般用于修改服务器上的资源，对所发送的信息没有限制。比如</p>
<ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
<h4 id="XMLHttpRequest常用方法和属性">XMLHttpRequest常用方法和属性</h4><p>open(get/post,url,是否异步)创建http请求</p>
<p>send()发送请求给服务器</p>
<p>setRequestHeader()设置头信息（使用post才会用到，get并不需要调用该方法）</p>
<p>常用的属性：</p>
<p>onreadystatechange 用于监听ajax的工作状态（readyState变化时会调用此方法）</p>
<p>readyState 用来存放XMLHttpRequest的状态</p>
<p>status 服务器返回的状态码</p>
<p>responseText 服务器返回的文本内容</p>
<h4 id="readyState的几个状态">readyState的几个状态</h4>
0：请求未初始化（此时还没有调用open）<p>1：服务器连接已建立，已经发送请求开始监听</p>
<p>2：请求已接收，已经收到服务器返回的内容</p>
<p>3：请求处理中，解析服务器响应内容</p>
<p>4：请求已完成，且响应就绪</p>
<h4 id="jquery ajax的实现">jquery ajax的实现</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">     url:发送请求的地址,</span><br><span class="line">     data:数据的拼接,<span class="comment">//发送到服务器的数据</span></span><br><span class="line">     type:<span class="string">'get'</span>,<span class="comment">//请求方式，默认get请求</span></span><br><span class="line">     dataType:<span class="string">'json'</span>,<span class="comment">//服务器返回的数据类型</span></span><br><span class="line">     <span class="keyword">async</span>:<span class="literal">true</span>,<span class="comment">//是否异步，默认true</span></span><br><span class="line">     cache:<span class="literal">false</span>,<span class="comment">//设置为 false 将不会从浏览器缓存中加载请求信息</span></span><br><span class="line">     success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="comment">//请求成功后的回调函数</span></span><br><span class="line">     error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//请求失败时调用此函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
不足之处：<p>　　（1）针对MVC的编程,不符合现在前端MVVM的浪潮</p>
<p>　　（2）基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</p>
<h4>同步和异步</h4>
同步：程序运行从上而下，浏览器必须把这个任务执行完毕，才能继续执行下一个任务<p>异步：程序运行从上而下，浏览器任务没有执行完，但是可以继续执行下一行代码</p>
<h4 id="跨域">跨域</h4>
跨域的概念：协议、域名、端口都相同才同域，否则都是跨域<p>解决跨域问题：</p>
<p>1.使用JSONP（json+padding）把数据内填充起来</p>
<p>2.CORS方式（跨域资源共享），在后端上配置可跨域</p>
<p>3.服务器代理，通过服务器的文件能访问第三方资源</p>
<h4>JSONP原理</h4>
ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。
<h4 id="Ajax和JSONP">Ajax和JSONP</h4>
ajax: { }<p>jsonp:fn( { } )</p>
<p>ajax的数据jsonp不能用，jsonp的数据ajax是可以用的</p>
<p>jsonp本质是通过URL的方式进行请求的，所以它是get方式请求，没有post</p>
]]></content>
      <tags>
        <tag>Ajax</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title>GET和POST的区别</title>
    <url>/2020/03/27/GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>-GET 和 POST 有什么区别？<br>-1.首先最直观的是语义上的区别。<br>-2.从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。<br>-3.从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。<br>-4.从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。<br>-5.从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同)<br>-6.从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 -body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</p>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式之观察者模式</title>
    <url>/2020/07/25/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="发布-订阅模式">发布-订阅模式<a href="#发布-订阅模式" title="发布-订阅模式"></a></h3><p>发布订阅模式又称为观察者模式，它定义了对象间的一种一对多的依赖关系，当一个对象发生改变时，所有依赖与它的对象都会得到通知。在前端开发中，DOM事件是一个典型的发布-订阅模型。比如我们监听一个点击事件，设置一个回调函数负责收到通知。<br>现在来看看如何来实现一个JavaScript版的发布-订阅模式<br>先实现一个发布者工厂：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">    clientList:[],</span><br><span class="line">    subscribe(key,fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.clientList[key]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.clientList[key].push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    trigger()&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>),</span><br><span class="line">        fns = <span class="keyword">this</span>.clientList[key];</span><br><span class="line">        <span class="keyword">if</span>(!fns||fns.length===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,fn;fn = fns[i++];)&#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    unsubscribe(key,fn) &#123;</span><br><span class="line">        <span class="keyword">var</span> fns = <span class="keyword">this</span>.clientList[key];</span><br><span class="line">        <span class="keyword">if</span>(!fns)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">            fns&amp;&amp;(fns.length=<span class="number">0</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> l = fns.length<span class="number">-1</span>;l&gt;=<span class="number">0</span>;l--)&#123;</span><br><span class="line">                <span class="keyword">let</span> _fn = fns[l];</span><br><span class="line">                <span class="keyword">if</span>(_fn===fn)&#123;</span><br><span class="line">                    fns.splice(l,<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个发布者工厂里我们先是定义个<code>subscribe</code>函数来对特定的属性进行订阅，并将订阅者存在属性订阅者列表中。接着定义一个<code>trigger</code>用来发布通知给所有的订阅者，接下来是一个<code>unsubscribe</code>来取消订阅，对对应属性的特定订阅者取消该属性的订阅。</p>
<p>接着写一个给对象布置“发布-订阅”功能的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> event)&#123;</span><br><span class="line">        obj[i] = event[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="function">(<span class="params">price</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"apple-price"</span>,price)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> xiaoHong =<span class="function">(<span class="params">price</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"banana-price"</span>,price)</span><br><span class="line">&#125;</span><br><span class="line">sales.subscribe(<span class="string">"apple"</span>,xiaoming)</span><br><span class="line">sales.subscribe(<span class="string">"banana"</span>,xiaoHong)</span><br><span class="line">sales.trigger(<span class="string">"apple"</span>,<span class="number">500</span>)<span class="comment">//apple-price 500</span></span><br><span class="line">sales.trigger(<span class="string">"banana"</span>,<span class="number">600</span>)<span class="comment">//banana-price 600</span></span><br><span class="line">sales.trigger(<span class="string">"apple"</span>,<span class="number">1200</span>)<span class="comment">//apple-price 1200</span></span><br><span class="line">sales.unsubscribe(<span class="string">"apple"</span>,xiaoming)<span class="comment">//取消订阅</span></span><br><span class="line">sales.trigger(<span class="string">"apple"</span>,<span class="number">1</span>)<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>以上就实现了一个简单的发布-订阅模式</p>
<h3 id="vue中的发布-订阅">Vue中的发布-订阅<a href="#vue中的发布-订阅" title="Vue中的发布-订阅"></a></h3><p>发布-订阅在目前的前端框架有诸多的应用，常见的是Vue2.0的双向绑定就利用了观察者模式<br>在Vue2.0中使用<code>Object.defineProperty</code>对数据的属性进行劫持可以收到数据更改的消息，而如何通知视图更新呢，Vue中定义了一个依赖类：<code>dep</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码位置：src/core/observer/dep.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除一个依赖</span></span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个依赖</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.target) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addSub(<span class="built_in">window</span>.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有依赖更新</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove an item from an array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的依赖管理器Dep类中，我们先初始化了一个subs数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。</p>
<p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj,key,val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">'object'</span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()  <span class="comment">//实例化一个依赖管理器，生成一个依赖管理数组dep</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">      dep.depend()    <span class="comment">// 在getter中收集依赖</span></span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify()   <span class="comment">// 在setter中通知依赖更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在Vue中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个”谁”。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p>
<p><code>Watcher</code>类的具体实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (vm,expOrFn,cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse simple path.</span></span><br><span class="line"><span class="comment"> * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来</span></span><br><span class="line"><span class="comment"> * 例如：</span></span><br><span class="line"><span class="comment"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * parsePath('a.b.c')(data)  // 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处附上一张Vue双向绑定的图解<br><img src="/images/Vue.jpg" class="φcy" alt="Vue"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript常用字符串以及数组处理函数2</title>
    <url>/2020/06/05/JavaScript%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B02/</url>
    <content><![CDATA[<h5 id="includes">includes()<a href="#includes" title="includes()"></a></h5><p>判断数组是否包含一个值，返回true 或者 false</p>
<h5 id="indexof和lastindexof">indexOf()和lastIndexOf()<a href="#indexof和lastindexof" title="indexOf()和lastIndexOf()"></a></h5><p>返回给定元素的第一个索引和最后一个索引</p>
<h5 id="pop和push">pop()和push()<a href="#pop和push" title="pop()和push()"></a></h5><p>pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<br>push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。<br>pop(),push()具有通用性，可用call()或apply()用在类数组对象上(arguments)</p>
<h5 id="shift和unshift">shift()和unshift()<a href="#shift和unshift" title="shift()和unshift()"></a></h5><p>shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。<br>unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。</p>
<h5 id="reduce">reduce()<a href="#reduce" title="reduce()"></a></h5><p><code>reduce()</code> 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。<br>reduce()的callback接受五个参数（前两个为必选，后三个可选参数）：</p>
<ul><li>accumulator累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue。</li>
<li>currentValue数组中正在处理的元素。</li>
<li>index 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。</li>
<li>array 调用reduce()的数组</li>
<li>initialValue 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。<br>回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Bruce'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> countedNames = names.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">allNames, name</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (name <span class="keyword">in</span> allNames) &#123;</span><br><span class="line">         allNames[name]++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         allNames[name] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> allNames;</span><br><span class="line"> &#125;, &#123;&#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(names)</span><br><span class="line"> <span class="built_in">console</span>.log(countedNames)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//数组去重</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.sort().reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(init.length === <span class="number">0</span> || init[init.length<span class="number">-1</span>] !== current) &#123;</span><br><span class="line">        init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//[1,2,3,4,5</span></span><br><span class="line">  <span class="comment">//--还有按顺序运行Promise</span></span><br></pre></td></tr></table></figure></li>
</ul><h5 id="slice">slice()<a href="#slice" title="slice()"></a></h5><p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。<br>slice可以一般化用在类数组对象昂，即Array.prototype.slice.call(arguments)</p>
<h5 id="splice">splice()<a href="#splice" title="splice()"></a></h5><p>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> months = [<span class="string">'Jan'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'June'</span>];</span><br><span class="line">months.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'Feb'</span>);</span><br><span class="line"><span class="comment">// inserts at index 1</span></span><br><span class="line"><span class="built_in">console</span>.log(months);</span><br><span class="line"><span class="comment">// expected output: Array ["Jan", "Feb", "March", "April", "June"]</span></span><br><span class="line"></span><br><span class="line">months.splice(<span class="number">4</span>, <span class="number">1</span>, <span class="string">'May'</span>);</span><br><span class="line"><span class="comment">// replaces 1 element at index 4</span></span><br><span class="line"><span class="built_in">console</span>.log(months);</span><br><span class="line"><span class="comment">// expected output: Array ["Jan", "Feb", "March", "April", "May"]</span></span><br></pre></td></tr></table></figure><h5 id="sort">sort()<a href="#sort" title="sort()"></a></h5><p>对数组进行排序<br>默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Edward'</span>, <span class="attr">value</span>: <span class="number">21</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Sharpe'</span>, <span class="attr">value</span>: <span class="number">37</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'And'</span>, <span class="attr">value</span>: <span class="number">45</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'The'</span>, <span class="attr">value</span>: <span class="number">-12</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Magnetic'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'Zeros'</span>, <span class="attr">value</span>: <span class="number">37</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort by value</span></span><br><span class="line">items.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.value - b.value)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(items)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* [</span></span><br><span class="line"><span class="comment">  &#123; name: 'The', value: -12 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Edward', value: 21 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Sharpe', value: 37 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'And', value: 45 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Magnetic' &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Zeros', value: 37 &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// sort by name</span></span><br><span class="line">items.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nameA = a.name.toUpperCase(); <span class="comment">// ignore upper and lowercase</span></span><br><span class="line">    <span class="keyword">var</span> nameB = b.name.toUpperCase(); <span class="comment">// ignore upper and lowercase</span></span><br><span class="line">    <span class="keyword">if</span> (nameA &lt; nameB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nameA &gt; nameB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// names must be equal</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(items)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; name: 'And', value: 45 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Edward', value: 21 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Magnetic' &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Sharpe', value: 37 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'The', value: -12 &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: 'Zeros', value: 37 &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="tostring和join">toString()和join()<a href="#tostring和join" title="toString()和join()"></a></h5><p>join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。<br>toString() 返回一个字符串，表示指定的数组及其元素。<br>两者区别不大，只是join()可以接受一个作为分隔符。</p>
<h4 id="stringprototype方法">String.prototype方法<a href="#stringprototype方法" title="String.prototype方法"></a></h4><h5 id="fromcharcode">fromCharCode()<a href="#fromcharcode" title="fromCharCode()"></a></h5><p>静态 String.fromCharCode() 方法返回由指定的UTF-16代码单元序列创建的字符串。</p>
<h5 id="charat">charAt()<a href="#charat" title="charAt()"></a></h5><p>charAt() 方法从一个字符串中返回指定的字符。参数为下标</p>
<h5 id="charcodeat">charCodeAt()<a href="#charcodeat" title="charCodeAt()"></a></h5><p>返回指定下标出对应字符的UTF-16的编码值</p>
<h5 id="concat">concat()<a href="#concat" title="concat()"></a></h5><p>concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p>
<h5 id="match">match()<a href="#match" title="match()"></a></h5><p>match() 方法检索返回一个字符串匹配正则表达式的的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/[A-E]/gi</span>;</span><br><span class="line"><span class="keyword">var</span> matches_array = str.match(regexp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(matches_array);</span><br><span class="line"><span class="comment">// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure><h5 id="substring">substring()<a href="#substring" title="substring()"></a></h5><p>substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。</p>
<h5 id="replace">replace()<a href="#replace" title="replace()"></a></h5><p>replace() 方法返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。<br>原字符串不会改变。<br>语法：str.replace(regexp|substr, newSubStr|function)</p>
<ul><li>regexp (pattern)一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。</li>
<li>substr (pattern)一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。</li>
<li>newSubStr (replacement)用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。</li>
<li>function (replacement)一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Twas the night before Xmas...'</span>;</span><br><span class="line"><span class="keyword">var</span> newstr = str.replace(<span class="regexp">/xmas/i</span>, <span class="string">'Christmas'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newstr);  <span class="comment">// Twas the night before Christmas...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/apples/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"Apples are round, and apples are juicy."</span>;</span><br><span class="line"><span class="keyword">var</span> newstr = str.replace(re, <span class="string">"oranges"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// oranges are round, and oranges are juicy.</span></span><br><span class="line"><span class="built_in">console</span>.log(newstr);</span><br></pre></td></tr></table></figure><h5 id="search">search()<a href="#search" title="search()"></a></h5>search() 方法执行正则表达式和 String 对象之间的一个搜索匹配。</li>
</ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hey JudE"</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/[A-Z]/g</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="regexp">/[.]/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(re)); <span class="comment">// returns 4, which is the index of the first capital letter "J"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(re2)); <span class="comment">// returns -1 cannot find '.' dot punctuation</span></span><br></pre></td></tr></table></figure><h5 id="trim">trim()<a href="#trim" title="trim()"></a></h5><p>trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> orig = <span class="string">'   foo  '</span>;</span><br><span class="line"><span class="built_in">console</span>.log(orig.trim()); <span class="comment">// 'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个 .trim() 例子，只从一边删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orig = <span class="string">'foo    '</span>;</span><br><span class="line"><span class="built_in">console</span>.log(orig.trim()); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC,MVP,MVVM了解</title>
    <url>/2020/03/31/MVC-MVP-MVVM%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h4 style="text-align:center">MVC</h4>
<h5>MVC的概念</h5>
<div>M是指业务模型，V是指业务界面，C是控制器</div>
<ul>
<li>M即model模型，数据层，负责数据的的处理和获取的数据接口</li>
<li>V即view视图层，是用户看到并且交互的界面</li>
<li>C即control控制层，是model和view进行数据交互的桥梁</li>
</ul>
它们之间的通信用一个图表示：
<img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1585640477674&di=5fa58e41fb0e7545fa31ca8ba8d798b2&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2Fcbe8c7a255f7bf8b2fdf90868a100850.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100">
<div>Model主要负责数据层的接口，View是展示层(GUI)，对于web前端来说所有以html开头的文件都属于这一层，Controller控制层，理论上所有的通信都是单向的。类似于 一个三角形通信结构。所以MVC更适合后端开发，相关发展比较成熟。</div><br>
<div>好处：    1.耦合性低。    2.重用性高    3.拓展新好    4.可维护性高</div>
<div>MVC不适合前端开发：
<ul>
<li>1.前端的View已经具备了独立处理用户事件的能力，如果每个事件都流经Controller层，这层会变得十分臃肿</li>
<li>2.MVC中的View和Controller一般都是一一对应的，捆绑起来表示一个组件，视图层和控制层的紧密连接让Controller和View无法复用</li>
</ul>
</div>
<h4 style="text-align:center">MVP模式</h4>
<div>MVP(Model-View-Presenter)是MVC的改良版，由IBM的子公司提出</div>
<div>在MVC中View可以直接操控Model，而在MVP模式中，View只能通过presenter来操控Model，而presenter和View和Model都是双向通信</div><br>
<div>与MVC相比，MVP通过解耦View和Model，完全分离视图和模型，使职责划分更清晰</div><br>
<div>View不依赖Model，可以将View分离出来做组件，组件化生产，只需要一系列接口提供给上层操作</div>
<img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1294241556,276820963&fm=26&gp=0.jpg">
<div style="text-align:center">上图就是MVP模式图</div>
<div>MVP也存在问题</div>
<ul>
<li>Presenter作为View和Model的桥梁，除了基本业务逻辑外，还有大量代码需要对View到Model和从Model到View进行“手动同步”，这样显得presenter很重，维护麻烦</li>
<li>同时由于没有数据绑定，如果Presenter对视图渲染的需求增多，一旦试图需求发生改变，Presenter也需要改动
</li></ul>
<h5 style="text-align:center">MVVM的出现</h5>
<div>MVVM提出了ViewModel模型(最早由微软提出)</div>
<div>关键点在于ViewModel和Model层实现了数据的双向绑定</div>
<img src="https://upload-images.jianshu.io/upload_images/4050018-ce27fe8c0d60e299.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp">
<div>MVVM首先是将View和Model的同步逻辑自动化了，对应于MVP模式的“手动同步”</div>
<div>之前presenter负责的View和Model同步不用再手动同步了，而是交给框架提供的数据绑定负责，只需要告诉View显示的数据对应于Model的哪个部分即可。在这之中通过ViewModel进行数据绑定，Model发生变化，ViewModel自动刷新，同时如果ViewModel改变，Model也自动刷新</div>
<h4>总结：</h4>
<div>
<ul>
<li>整体上看，MVVM比MVC和MVP精简了很多，不仅优化了业务和界面的依赖，还解决了数据频繁更新的问题。</li>
<li>MVVM中，View不知道Model的存在，ViewModel和Model也察觉不到View，这种低耦合模式，让开发更容易</li>
<li>MVVM更适合试图更多的前端项目进行工程化开发</li>
</ul>
</div>]]></content>
      <tags>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise和Observable区别</title>
    <url>/2020/05/12/Promise%E5%92%8CObservable%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>最近学 Angular 看大漠老师的视频看到了 Observable 这块，Observable 是 Rxjs 库里异步编程核心的一部分，相比于 Rxjs 又有那些区别呢</p>
<h3 id="observable-介绍"><h5>Observable 介绍</h5><a href="#observable-介绍" title="Observable 介绍"></a></h3><p>RxJS 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 Observable，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。 ————引用 Rxjs 中文网站的介绍 ——<a href="https://cn.rx.js.org/manual/overview.html#observable-" target="_blank">Rxjs 官网</a></p>
<h4 id="observable（可观察对象）">Observable（可观察对象）<a href="#observable（可观察对象）" title="Observable（可观察对象）"></a></h4><p>这里具体原理可参照 JavaScript 设计模式–观察，订阅模式</p>
<ul><li>在 RxJS 中用来解决异步事件管理的的基本概念是：</li>
<li>-Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li>
<li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li>
<li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li>
<li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li>
<li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li>
<li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其</li>
</ul><h4 id="使用-observable">使用 Observable<a href="#使用-observable" title="使用 Observable"></a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Observable写法</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span></span><br><span class="line"><span class="comment">//创建一个Observable对象</span></span><br><span class="line"><span class="keyword">let</span> Ob1 = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  observer.next(<span class="string">'observable'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">Ob1.subscribe(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用-promise">使用 Promise<a href="#使用-promise" title="使用 Promise"></a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Pro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//reject(2)</span></span><br><span class="line">&#125;</span><br><span class="line">Pro1.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Observable 与函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  console.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = foo.call(); <span class="comment">// 等同于 foo()</span></span><br><span class="line">console.log(x);</span><br><span class="line"><span class="keyword">var</span> y = foo.call(); <span class="comment">// 等同于 foo()</span></span><br><span class="line">console.log(y);</span><br><span class="line"><span class="comment">//"Hello"</span></span><br><span class="line"><span class="comment">//42</span></span><br><span class="line"><span class="comment">//"Hello"</span></span><br><span class="line"><span class="comment">//42</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">用 Observables 重写上面的代码：</span><br><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(function (observer) &#123;</span><br><span class="line">  console.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">foo.subscribe(function (x) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;);</span><br><span class="line">foo.subscribe(function (y) &#123;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//"Hello"</span></span><br><span class="line"><span class="comment">//42</span></span><br><span class="line"><span class="comment">//"Hello"</span></span><br><span class="line"><span class="comment">//42</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>因为函数和 Observables 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observables 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observables 与之相反，不会共享副作用并且是延迟执行。</p>
<h4 id="区别">区别<a href="#区别" title="区别"></a></h4><h5 id="为什么用-rxjs">为什么用 Rxjs<a href="#为什么用-rxjs" title="为什么用 Rxjs"></a></h5><p>promise 相较于 Rxjs 而言功能更单一 promise 只能将一个数据的状态由 pending 转换成 resoloved 或者 rejected.而 Rxjs 可以处理多个数据对应 complete 和 error 状态但是 Rxjs 同时又拥有 next 方法。Observable 是惰性的，需要 subscribe 的时候才输出值。promise 内部状态是不可控制的，执行了就无法终止。而 Observable 可以定义如何取消异步方法。<br>比如如下的场景：</p>
<p>输入框中输入字符，按回车发送一个请求，并将返回的结果变成一个 Todo item。如果在请求返回结果前又一次按下回车或 add 按钮，如果相同则不进行任何操作，如果不同则取消掉上次的请求并发送新的请求。（实际的场景往往是发送个 http 请求该请求会返回的很慢，业务上加上心跳检查（发送方按照一定规则（周期性发送、空闲发送等等）向接收方发送固定格式的消息，接受方收到消息后回复一个固定格式的消息，如果长时间没有收到，比如心跳周期的 3 倍，则认为当前连接失效，将其断开。），如果前一次在心跳间隔内无返回则再次调用请求，同时需要抛弃前一次请求的返回，并且此时有可能调用参数不一样的该接口从而造成数据不一致的问题）对于 Promise 实现我们不只要维护一个定时器 timer 同时还要维护一个全局变量。</p>
<p>再比如我们需要监听页面滚动的事件，作出一些逻辑操作，这是就会产生事件过于频繁的调用，造成页面卡顿的现象。用原生 js 实现的时候，需要实现个节流或者防抖函数，通过实现个闭包函数，在内部维护个定时器。而在 Rxjs 中通过操作符 debounce 就可以方便的解决</p>
<h5 id="同步与异步">同步与异步<a href="#同步与异步" title="同步与异步"></a></h5><p>首先第一个区别是：Promise 是解决异步编程的方法，而 Observable 可以同步也可以异步</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Observable同步执行</span></span><br><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>)</span><br><span class="line">  observer.next(<span class="number">42</span>)</span><br><span class="line">  observer.next(<span class="number">100</span>) <span class="comment">// “返回”另外一个值</span></span><br><span class="line">  observer.next(<span class="number">200</span>) <span class="comment">// 还可以再“返回”值</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>)</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"before"</span></span><br><span class="line"><span class="comment">"Hello"</span></span><br><span class="line"><span class="comment">42</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">200</span></span><br><span class="line"><span class="comment">"after"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Observable = <span class="built_in">require</span>(<span class="string">'rxjs/Observable'</span>).Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// observer.next(5);</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.next(<span class="number">5</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value + <span class="string">'!'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'And now we are here.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">这个如果是直接next <span class="number">5</span>,则输出是  <span class="number">5</span>！ -&gt; And now we are here.</span><br><span class="line">采用setTimeout next <span class="number">5</span>， 则相反  And now we are here.-&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><h5 id="单个值和多个值">单个值和多个值<a href="#单个值和多个值" title="单个值和多个值"></a></h5><p>Observable 里面的 next()方法类似与 Promise.resolve(),但是 Promise()内部的 resolve()方法成功后，后面的不会执行，就是说 Observable 可以持续发射很多值，而 Promise 只能发射一个值就结束了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">' I am promise '</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> observable1 = <span class="keyword">new</span> Observable(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am Observable!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise 里的 console.log 会执行，而 Observable 里的代码不会输出，只有订阅（subscribe）之后才会输出</p>
<h5 id="异步执行任务的取消">异步执行任务的取消<a href="#异步执行任务的取消" title="异步执行任务的取消"></a></h5><p>Promise 的执行默认是不可取消的，而 Observable 是可以通过 subscribe 的 unsubscribe()方法来取消<br>因为在 Promise 中.then()返回的是一个新的 Promise 对象，而 Observable+subscribe 返回的是 subscription 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Observable = require(<span class="string">'rxjs/Observable'</span>).Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = <span class="keyword">new</span> Observable((observer) =&gt; &#123;</span><br><span class="line">    let i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> token = setInterval(() =&gt; &#123;</span><br><span class="line">        observer.next(i++);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> () =&gt; clearInterval(token);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscription = observable.subscribe(value =&gt; console.log(value + <span class="string">'!'</span>));</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>!</span><br><span class="line"><span class="number">1</span>!</span><br><span class="line"><span class="number">2</span>!</span><br><span class="line"><span class="number">3</span>!</span><br><span class="line"><span class="comment">//Observable</span></span><br></pre></td></tr></table></figure><h5 id="一次和多次执行">一次和多次执行<a href="#一次和多次执行" title="一次和多次执行"></a></h5><p>Promise 只会执行一次 resolve(),而 Observable 每次订阅都会执行一次观察对象中的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Promise</span></span><br><span class="line">let time;</span><br><span class="line"><span class="keyword">const</span> waitOneSecondPromise = <span class="keyword">new</span> Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'promise call'</span>)</span><br><span class="line">    time = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    setTimeout(() =&gt; resolve(<span class="string">'hello world'</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">waitOneSecondPromise.then((value) =&gt; &#123;console.log( <span class="string">'第一次'</span>, value, <span class="keyword">new</span> Date().getTime() - time)&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    waitOneSecondPromise.then((value) =&gt; &#123;console.log(<span class="string">'第二次'</span>, value, <span class="keyword">new</span> Date().getTime() - time)&#125;);</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果是 promise call</span></span><br><span class="line">第一次 hello world <span class="number">1007</span></span><br><span class="line">第二次 hello world <span class="number">5006</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Observable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Observable = require(<span class="string">'rxjs/Observable'</span>).Observable;</span><br><span class="line"></span><br><span class="line">let time;</span><br><span class="line"><span class="keyword">const</span> waitOneSecondObservable = <span class="keyword">new</span> Observable((observer) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'I was called'</span>);</span><br><span class="line">    time = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    setTimeout(() =&gt; observer.next(<span class="string">'hey girl'</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">waitOneSecondObservable.subscribe((value) =&gt; &#123;console.log( <span class="string">'第一次'</span>, value, <span class="keyword">new</span> Date().getTime() - time)&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    waitOneSecondObservable.subscribe((value) =&gt; &#123;console.log( <span class="string">'第二次'</span>, value, <span class="keyword">new</span> Date().getTime() - time)&#125;);</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">I was called</span><br><span class="line">第一次 hey girl <span class="number">1003</span></span><br><span class="line">I was called</span><br><span class="line">第二次 hey girl <span class="number">1003</span></span><br></pre></td></tr></table></figure><h5 id="工具">工具<a href="#工具" title="工具"></a></h5><p>Observable 提供了很多的工具函数，常用的 filter 和 map 演示如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stream2$ =</span><br><span class="line">  <span class="keyword">new</span> Observable() &lt;</span><br><span class="line">  number &gt;</span><br><span class="line">  (<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      observer.next(count++)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearInterval(interval)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">stream2$.subscribe(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observable&gt;'</span> + value))</span><br><span class="line">stream2$</span><br><span class="line">  .pipe(filter(<span class="function">(<span class="params">val</span>) =&gt;</span> val % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'filter&gt;'</span> + value))</span><br><span class="line">stream2$</span><br><span class="line">  .pipe(map(<span class="function">(<span class="params">value</span>) =&gt;</span> value * value))</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'map&gt;'</span> + value))</span><br></pre></td></tr></table></figure><h5 id="总结">总结<a href="#总结" title="总结"></a></h5><ul><li>Observable 是 lazy 的，只有订阅才输出，同时 Observable 可以接受多个值。Promise 只能 resolve 一次。</li>
<li>Promise 内部 resolve 一定是异步的，而 Observable 则可以自由发挥</li>
<li>Promise 只会执行一次，创建之后就会执行，不能重复执行，而 Observable 每订阅一次会执行一次，而如果想只执行一次，可以利用 share。</li>
<li>Promise 不可以取消，而 Observable 可以取消</li>
</ul>]]></content>
      <tags>
        <tag>Promise</tag>
        <tag>Observable</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust学习小记录</title>
    <url>/2020/10/03/Rust%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="rust-入坑">Rust 入坑<a href="#rust-入坑" title="Rust 入坑"></a></h4><p>首先介绍一下 Rust:A language for the next 40 years 在油管上某视频被称为下一个 40 年所用的语言。那么 Rust 的特点有哪些呢，官网对其的介绍有三个特点：</p>
<pre><code>- 高性能
- 可靠性
- 生产力</code></pre><p>rust 是由 Mozila 公司推出是为构建高性能应用的语言，直接竞争对手有 C，C++语言。Rust 一些比较吸引人的是，具有很高的性能，类似于 npm 的包管理器（前端友好）,稳定的 async await 异步模型，前端的朋友应该很熟悉了。还有诸如泛型，trait，错误处理，生命周期，所有权提供内存安全，以及并发时的数据安全，智能指针+无 GC 更灵活。但 Rust 目前还处于成长状态，有友好的社区支持，但是整体生态不是很完善，可用的包较少，还需要较长时间的实践与发展。</p>
<h4 id="webassembly">WebAssembly<a href="#webassembly" title="WebAssembly"></a></h4><p>WebAssembly 是由主流浏览器厂商组成的 W3C 社区团体制定的新的规范，作为可用于前端开发的第四种“语言”。WebAssembly 有一套完整的语义，目标是将其他语言编译成<code>wasm</code> 或<code>wat</code>二进制文件，目标是充分发挥硬件能力以达到原生执行效率。<br>作为一种编程语言，WebAssembly 由两种表示相同结构的格式组成，尽管使用的方式不同：</p>
<ul><li>wat 文件是 WebAssembly 的一种体现，用的是一种 S-expressions,用的是一种类似于 Clojure 的语言。</li>
<li>而.wasm 二进制格式是低级别和用于通过 WASM 虚拟机直接消耗。从概念上讲，它类似于 ELF 和 Mach-O。</li>
</ul><h4 id="rust-构建-wasm-之准备">rust 构建 wasm 之准备<a href="#rust-构建-wasm-之准备" title="rust 构建 wasm 之准备"></a></h4><p>首先是工具链<br>需要 rust 的构建工具 <code>rustup</code>，<code>rustc</code>， <code>cargo</code>.<br><code>rustup</code>是用来安装 <code>rust</code> 的工具，<code>rustc</code>是用来编译<code>rust</code>代码的命令行工具，<code>cargo</code>则是 rust 官方的包管理器。接下来安装<code>wasm-pack</code>，用来构建，测试，发布 rust 生成的 webAssembly。安装地址：<a href="https://rustwasm.github.io/wasm-pack/installer/" target="_blank">wasm-pack</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cargo install cargo-generate</span><br></pre></td></tr></table></figure><p><code>cargo-generate</code>用来启动和运行 rust 项目<br>当然将<code>wasm</code>运行在 web 上，还需要<code>npm</code>包管理器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install npm@latest -g</span><br></pre></td></tr></table></figure><h4 id="正式开始">正式开始<a href="#正式开始" title="正式开始"></a></h4><p>首先用刚才安装的<code>cargo-generate</code>克隆远程仓库的项目模板。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cargo generate --git https:<span class="comment">//github.com/rustwasm/wasm-pack-template</span></span><br></pre></td></tr></table></figure><p>运行之后会提示输入项目名称,比如<code>hello</code>。<br>克隆完成后，进入项目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd wasm-game-<span class="keyword">of</span>-life</span><br></pre></td></tr></table></figure><p>项目结构如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hello/</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── LICENSE_APACHE</span><br><span class="line">├── LICENSE_MIT</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">    ├── lib.rs</span><br><span class="line">    └── utils.rs</span><br></pre></td></tr></table></figure><p>首先是 cargo.toml 文件，学习过 rust 的都应该了解了这个文件。这个文件类似与 npm 的<code>package.json</code>文件,里面保存了当前的项目的版本以及依赖的包。还有一个比较重要的文件是<code>src</code>下面的<code>lib.rs</code>文件,这个文件类似于一个模块，是我们即将编译为<code>wasm</code>文件的 rust 源文件,它主要用于<code>wasm-bingen</code>和<code>javascript</code>交互</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused_variables)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">mod</span> utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> wasm_bindgen::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global</span></span><br><span class="line"><span class="comment">// allocator.</span></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"wee_alloc"</span>)]</span></span><br><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line"><span class="keyword">static</span> ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">alert</span></span>(s: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">greet</span></span>() &#123;</span><br><span class="line">    alert(<span class="string">"Hello, hello!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在当前目录下面运行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wasm-pack build</span><br></pre></td></tr></table></figure><p>会将我们的 rust 项目打包为 WebAssembly 文件和 js 文件，编译后的文件在<code>pkg</code>文件夹内</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pkg/</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">├── hello_bg.wasm</span><br><span class="line">├── hello.d.ts</span><br><span class="line">└── hello.js</span><br></pre></td></tr></table></figure><p>同时也生成了 ts 文件，更有助与工程化的构建 web 程序</p>
<p>接下来在当前目录下克隆一个 wasm 的 web 项目模板,</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init wasm-app www</span><br></pre></td></tr></table></figure><p>可看<a href="https://github.com/rustwasm/create-wasm-app" target="_blank">wasm-app Github 介绍</a></p>
<p>接下来修改目录下的文件的部分内容，让他能找到我们的 WebAssembly 文件，并运行在本地环境</p>
<p>首先是修改<code>www</code>目录下的<code>package.json</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;                     <span class="comment">// Add this three lines block!</span></span><br><span class="line">    <span class="string">"wasm-game-of-life"</span>: <span class="string">"file:../pkg"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来修改<code>www/index.js</code>为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> wasm <span class="keyword">from</span> <span class="string">'wasm-game-of-life'</span></span><br><span class="line"></span><br><span class="line">wasm.greet()</span><br></pre></td></tr></table></figure><p>接下来在该目录下运行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>即可在本地环境看到了<code>alert</code><br>这样一个简单的 wasm 项目就运行起来了，接着我们可以在 rust 目录下写 lib.rs 来丰富我们的应用了。</p>
<p>下一次分享利用 rust 构建一个小型服务器，用来操作 mongoDB 数据库。<br>在之后可以尝试将<code>tensorflow</code>上的个别深度学习模型，编译为 wasm 运行在浏览器中，进行尝试。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Typescript相关</title>
    <url>/2021/02/22/Typescript%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>最近复习基础看到了Learning Typescript这本书，翻开学习，发现了不少知识，在此记录一下。</p>
<h4 id="面向对象编程">面向对象编程<a href="#面向对象编程" title="面向对象编程"></a></h4><h4 id="solid原则">SOLID原则<a href="#solid原则" title="SOLID原则"></a></h4><p>利用Typescript进行面向对象编程要注意五个点，简称为“SOLID”原则</p>
<ul><li>单一职责原则(SRP): 表明软件组件(函数，类，模块)必须专注于单一的任务(只有单一的职责)</li>
<li>开/闭原则(OCP): 表明软件设计时必须时刻考虑到(代码)可能的发展(具有扩展性)，但是程序的发展必须最少地修改已有的代码(对已有的修改封闭)</li>
<li>里氏替换原则(LSP): 表明只要继承的是同一个接口，程序里任意一个类都可以被其他的类替换。在替换完成后，不需要其他额外的工作程序就能像原来一样运行。</li>
<li>接口隔离原则(ISP): 表明我们应该将那些非常大的接口拆分成一些更具体的接口，这样客户端就只需要关心他们需要用到的接口</li>
<li>依赖反转原则(DIP): 表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。<br>用<code>Typesciript</code>编写一个类如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    public surname: string;</span><br><span class="line">    public email: string;</span><br><span class="line">    <span class="keyword">constructor</span>(name: string, surname: string, email: string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.surname = surname;</span><br><span class="line">    &#125;</span><br><span class="line">    greet()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p : Person = <span class="keyword">new</span> Person(<span class="string">"liming"</span>, <span class="string">"li"</span>, <span class="string">"123@163.com"</span>);</span><br></pre></td></tr></table></figure>如果要验证<code>email</code>的格式，在<code>Person</code>上增加代码会使<code>Person</code>类变得非常大，我们可以八<code>email</code>抽象成一个类分离出来，这体现了第一个单一职责原则。<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Email&#123;</span><br><span class="line">    <span class="keyword">public</span> email: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">email: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.validateEmail(email))&#123;</span><br><span class="line">            <span class="keyword">this</span>.email = email</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Invalid email!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> validateEmail(email: <span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> re = <span class="string">'/\S+@\S+\.\S+/'</span>;</span><br><span class="line">        <span class="keyword">return</span> re.test(email)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">       <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">       <span class="keyword">public</span> surname: <span class="built_in">string</span>;</span><br><span class="line">       <span class="keyword">public</span> email: Email;</span><br><span class="line">       <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, surname: <span class="built_in">string</span>, email: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">           <span class="keyword">this</span>.email = email;</span><br><span class="line">           <span class="keyword">this</span>.name = name;</span><br><span class="line">           <span class="keyword">this</span>.surname = surname;</span><br><span class="line">       &#125;</span><br><span class="line">       greet()&#123;</span><br><span class="line">           alert(<span class="string">"hello"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>在面向对象的过程中，类与类有一些关系，比如关联，聚合，组合，继承，混合等，接下来并不介绍他们的概念，而是介绍一下泛型类和泛型约束</li>
</ul><h4 id="泛型类">泛型类<a href="#泛型类" title="泛型类"></a></h4><p>泛型类如同泛型函数，可以介绍很多重复的代码，接下来用代码说明<br>首先是一个类<br><img src="/images/typescript/ts_1.png" class="φcy" alt="代码"><br>这里包括一个<code>User</code>的类和一个<code>NotGenericUserRepository</code>的类，后面这个类是获取User的列表，并传给JSON文件，当我们想获取一个会议，或者一个歌曲列表时，不同的类形成的这个<code>GenericRepository</code>类也就要重写，这时可以利用泛型类。如下所示：<br><img src="/images/typescript/ts_2.png" class="φcy" alt="代码"><br>有时候，我们需要泛型约束，如上述例子，新需求是增加一些变更来验证通过Ajax请求的数据:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">success: <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list: T[]</span><br><span class="line">    <span class="keyword">var</span> items = &lt;T[]&gt;data.items</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(items[i].isValid())&#123; <span class="comment">// 验证</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们可以写一个验证接口，将泛型进行约束：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> User <span class="keyword">implements</span> ValidatableInterface&#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">public</span> password: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, password: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.password = password</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> isValid()&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Talk <span class="keyword">implements</span> ValidatableInterface&#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, password: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> isValid()&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> NotGenericUserRepository&lt;T <span class="keyword">extends</span> ValidatableInterface&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> _url: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">url: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>._url = url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getAsync()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve: (<span class="params">users: T[]</span>) =&gt; <span class="built_in">void</span>. reject</span>) =&gt;</span> &#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: <span class="keyword">this</span>._url,</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">"GET"</span>,</span><br><span class="line">                dataType: <span class="string">"JSON"</span>,</span><br><span class="line">                success: <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> list: T[]</span><br><span class="line">                    <span class="keyword">var</span> items = &lt;T[]&gt;data.items</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(items[i].isValid())&#123;</span><br><span class="line">                            list.push(items[i])</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(list)</span><br><span class="line">                &#125;,</span><br><span class="line">                error: <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">class</span> User <span class="keyword">implements</span> ValidatableInterface&#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">public</span> password: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, password: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.password = password</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> isValid()&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Talk <span class="keyword">implements</span> ValidatableInterface&#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, password: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> isValid()&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> NotGenericUserRepository&lt;T <span class="keyword">extends</span> ValidatableInterface&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> _url: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">url: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>._url = url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getAsync()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve: (<span class="params">users: T[]</span>) =&gt; <span class="built_in">void</span>. reject</span>) =&gt;</span> &#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: <span class="keyword">this</span>._url,</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">"GET"</span>,</span><br><span class="line">                dataType: <span class="string">"JSON"</span>,</span><br><span class="line">                success: <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> list: T[]</span><br><span class="line">                    <span class="keyword">var</span> items = &lt;T[]&gt;data.items</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(items[i].isValid())&#123;</span><br><span class="line">                            list.push(items[i])</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(list)</span><br><span class="line">                &#125;,</span><br><span class="line">                error: <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型中的new操作">泛型中的new操作<a href="#泛型中的new操作" title="泛型中的new操作"></a></h4><p>要通过代码来创建新的对象，我们需要声明泛型T拥有构造函数，这意味着我们需要像下面一样，用<code>type: {new() :T;}</code>替代<code>type:T</code><br><img src="/images/typescript/ts_4.png" class="φcy" alt="代码"><br>####</p>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise从入门到放弃</title>
    <url>/2020/04/29/Promise%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<h3 id="promise-从入门到放弃">Promise 从入门到放弃<a href="#promise-从入门到放弃" title="Promise 从入门到放弃"></a></h3><h4 id="javascript-异步操作执行历史">javascript 异步操作执行历史<a href="#javascript-异步操作执行历史" title="javascript 异步操作执行历史"></a></h4><p>JavaScript 语言的执行环境是“单线程”， 所谓单线程，就是一次只能完成一件任务， 如果有多个任务就需要排队，一个完成了，继续下一个，这种方式在实现来说是非常简单的，但是如果一个任务耗时很长，那么后面的任务就需要排队等着，会拖延整个程序的执行。 常见的浏览器无响应（假死）就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡死，其他任务无法执行。</p>
<h4 id="javascript-异步操作的类型">javascript 异步操作的类型<a href="#javascript-异步操作的类型" title="javascript 异步操作的类型"></a></h4><ul><li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>promise</li>
<li>generator（ES6）</li>
<li>async/await （ES7）</li>
</ul><h4 id="回调函数">回调函数<a href="#回调函数" title="回调函数"></a></h4><ul><li>同步回调<br>立即执行，完全执行完之后才结束，不会放入回调队列<br>example : Promise(()=&gt;{}) 数组的 forEach()</li>
<li>异步回调<br>setTimeout((()=&gt;{}))</li>
</ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'over'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>异步回调<br>进入回调队列，等待执行</p>
</li>
<li><p>回调函数</p>
</li>
</ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是f1'</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'我是f1的'</span> + i)</span><br><span class="line">    &#125;</span><br><span class="line">    func(Zz)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'我是f2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'我是f3'</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1(f2) <span class="comment">//这里f1(),f2()不会阻塞f3()的运行</span></span><br><span class="line">f3()</span><br></pre></td></tr></table></figure><p>这里主要利用<code>setTimeout()</code>函数来进行异步操作，f3<code>()</code>的执行不会受到<code>f1()</code>影响。主要是因为<code>setTimeout()</code>是异步函数。</p>
<ul><li>为什么要用 Promise<ul><li>1.指定回调函数的而方式更加灵活</li>
<li>2.支持链式调用，可解决回调地狱问题<br>回调地狱就是传统的回调函数嵌套所产生的问题，不利于阅读，不利于异常处理，解决方案有 Promise 链式调用以及最新的 async 和 await</li>
</ul></li>
</ul><h3 id="promise">Promise<a href="#promise" title="Promise"></a></h3><ul><li>Promise 是 ES6 中提出的新的异步编程解决方案<br>语法上来看：Promise 是一个构造函数<br>功能上来看；Promise 对象用来封装了一个异步操作并可以获取其结果</li>
<li>Promise 状态<br>pending 状态–&gt;初始状态<br>fullFilled 状态–&gt;对应 Promise 内函数执行成功–&gt;对应 resolve(params)<br>rejected 状态–&gt;对应 Promise 内函数执行失败或抛出异常–&gt;对应 reject(params)</li>
<li>Promise 执行流程<br><img src="/images/Promise.png" class="φcy" alt="Promise执行"></li>
</ul><h3 id="如何改变-promise-的状态">如何改变 promise 的状态<a href="#如何改变-promise-的状态" title="如何改变 promise 的状态"></a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve(value)<span class="comment">//---pedding-&gt;fullfilled</span></span><br><span class="line">reject(reason)<span class="comment">//---pedding-&gt;rejected</span></span><br><span class="line"><span class="keyword">throw</span> <span class="comment">//抛出异常，rejected，reason为throw的值</span></span><br></pre></td></tr></table></figure><p>定义两个 then()，都会输出</p>
<p>promise 状态的改变和 then 回调函数的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先指定回调函数，在改变状态</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//这里是同步执行</span></span><br><span class="line">  <span class="built_in">console</span>.log<span class="string">`先指定回调函数，在改变状态`</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>) <span class="comment">//再改变pedding状态，同时改变数据</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//先指定回调函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1----&gt;'</span> + value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//先改变状态，再指定函数</span></span><br><span class="line"><span class="comment">//第一种，去掉异步的定时器</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log<span class="string">`//先改变状态，再指定函数`</span></span><br><span class="line">  resolve(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2---&gt;'</span> + value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第二种都设置定时器</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log<span class="string">`//先改变状态，再指定函数`</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  p3.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'value3---&gt;'</span> + value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1200</span>)</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">[ '先指定回调函数，在改变状态' ]</span></span><br><span class="line"><span class="comment">[ '//先改变状态，再指定函数' ]</span></span><br><span class="line"><span class="comment">[ '//先改变状态，再指定函数' ]</span></span><br><span class="line"><span class="comment">value2---&gt;2</span></span><br><span class="line"><span class="comment">value1----&gt;1</span></span><br><span class="line"><span class="comment">value3---&gt;3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="promiseall-和-promiserace">Promise.all() 和 Promise.race()<a href="#promiseall-和-promiserace" title="Promise.all() 和 Promise.race()"></a></h3><ul><li>Promise.all()<br>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</li>
<li>Promise.race()<br>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</li>
</ul><h3 id="promise-值穿透问题">Promise 值穿透问题<a href="#promise-值穿透问题" title="Promise 值穿透问题"></a></h3><ul><li>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</li>
</ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result) <span class="comment">//foo</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//-----------------------------</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log) <span class="comment">//2</span></span><br></pre></td></tr></table></figure><ul><li>异常穿透<br>(1)当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,<br>(2)前面任何操作出了异常, 都会传到最后失败的回调中处理</li>
</ul><h3 id="中断-promise-链">中断 promise 链<a href="#中断-promise-链" title="中断 promise 链"></a></h3><p>(1)当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数<br>(2)办法: 在回调函数中返回一个 pendding 状态的 promise 对象</p>
<h3 id="手写-promise-对象">手写 Promise 对象<a href="#手写-promise-对象" title="手写 Promise 对象"></a></h3><p>已上传到 GIthub <a href="https://github.com/edsion11/guzhenxu.github.io/blob/master/Study/javascript/%E5%BC%82%E6%AD%A5javascript/%E6%89%8B%E5%86%99Promise.js" title="With a Title" target="_blank">手写 Promise(ES5)</a>.</p>
<h3 id="async-和-await">async 和 await<a href="#async-和-await" title="async 和 await"></a></h3><ul><li>async 函数<br>函数的返回值为 Promise 对象<br>Promise 对象的结果由 async 函数执行的返回值决定</li>
<li>await 函数<br>await 右侧的表达式一般为 Promise 对象，但也可以是其他值<br>如果表达式是 Promise 对象，await 返回 Promise 成功的值<br>如果为其他值，则直接作为 await 的返回值</li>
<li>注意<br>await 必须写在 async 函数中，但 async 函数中可以没有 await<br>await 的 Promise 对象失败，会抛出异常，用 try…catch 捕获异常 🍎</li>
</ul><h3 id="宏队列-和-微队列">宏队列 和 微队列<a href="#宏队列-和-微队列" title="宏队列 和 微队列"></a></h3><ul><li>宏队列<br>DOM 事件回调 Ajax 回调 定时器回调</li>
<li>微队列<br>Mutation() Promise()<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">//微队列优先级高</span></span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//立即进入宏队列</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'timeout1'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'setTimeout的Promise1'</span> + value)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//立即进入宏队列</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>)</span></span><br><span class="line">    /*</span><br><span class="line">      每次准备取出一个宏队列的任务时，都会先执行所有的微任务</span><br><span class="line">      */</span><br><span class="line"><span class="javascript">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'setTimeout的Promise2'</span> + value)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line"><span class="javascript">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//立即进入微队列</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'Promise onResolved'</span> + value)</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  <span class="comment">//Promise onResolved 1.</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//timeout</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>]]></content>
      <tags>
        <tag>Promise</tag>
        <tag>async/await</tag>
        <tag>宏队列</tag>
        <tag>微队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向绑定</title>
    <url>/2020/04/08/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>Vue的双向绑定是v-model指令</p>
<p>具体的实现原理是用了js中的<code>Object.defineProperty</code>方法来修改目标对象的属性</p>
<img src="https://vue-js.com/learn-vue/assets/img/3.0b99330d.jpg">
先看看Vue中源码中的解释:
<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js" target="_blank" rel="noopener">源码地址</a>
<h4>1.使Object数据变得可侦测 </h4>
<p>数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。</p>
<p>要将数据变的‘可观测’，我们就要借助前言中提到的<code>Object.defineProperty</code>方法了，在本文中，我们就使用这个方法使数据变得“可观测”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = &#123;</span><br><span class="line">  val: <span class="string">'hello'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Obj, <span class="string">'val'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据已读取'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据已修改'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Obj.val</span><br><span class="line">Obj.val = <span class="string">'123'</span></span><br></pre></td></tr></table></figure><p>上面是创建一个对象Obj，然后读取和赋值，下面是输出结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">数据已读取</span><br><span class="line">数据已修改</span><br><span class="line">[Done] exited <span class="keyword">with</span> code=<span class="number">0</span> <span class="keyword">in</span> <span class="number">0.118</span> seconds</span><br></pre></td></tr></table></figure>
<p>上面是Object.defineProperty方法对数据进行观测拦截，每当该属性进行读或写操作的时候就会触发<code>get()</code>和<code>set()</code>,这样的方法在原来html页面进行简单的双向绑定，大型项目会很复杂，Vue框架的双向绑定引入观测模式，封装在index.js中，就是Vue的双向绑定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// 给value新增一个__ob__属性，值为该value的Observer实例</span></span><br><span class="line">    <span class="comment">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span></span><br><span class="line">    def(value,<span class="string">'__ob__'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 当value为数组时的逻辑</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">* 使一个对象转化成可观测对象</span><br><span class="line"> * @param &#123; <span class="built_in">Object</span> &#125; obj 对象</span><br><span class="line"> * @param &#123; <span class="built_in">String</span> &#125; key 对象的key</span><br><span class="line"> * @param &#123; Any &#125; val 对象的某个key的值</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj,key,val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果只传了obj和key，那么val = obj[key]</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">'object'</span>)&#123;</span><br><span class="line">      <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被读取了`</span>);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>属性被修改了`</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>上面是数据可观测的过程，上面的代码中我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。
并且给value新增一个<code>__ob__</code>属性，值为该value的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作
</p>
<p>
然后判断数据的类型，只有<code>object</code>类型的数据才会调用walk将每一个属性转换成<code>getter/setter</code>的形式来侦测变化。 最后，在<code>defineReactive</code>中当传入的属性值还是一个object时使用<code>new observer（val）</code>来递归子属性，这样我们就可以把obj中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。 也就是说，只要我们将一个<code>object</code>传到<code>observer</code>中，那么这个<code>object</code>就会变成可观测的、响应式的<code>object</code>。
</p>
<h4>2.依赖收集</h4>
<p>之后还有依赖收集，我们在上面是实现了数据的可观测性，数据变换之后，还得通知对应的视图层变换，在整个视图层之中知道需要通知的部分，就是“依赖收集”。如果数据变了，就把数据的依赖数组通知变换。</p>
<p>总结一句话就是:<code>getter()</code>收集依赖 , <code>setter()</code>通知依赖更新</p>]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>http状态码</title>
    <url>/2020/03/29/http%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<div><image src="http://pic.netbian.com/uploads/allimg/180803/084010-15332568107994.jpg"></image></div>
<h4 style="font-weight:bold">一些常见的状态码有</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">200       //服务器请求成功</span><br><span class="line">403       //服务器理解请求客户端的请求，但是拒绝执行此请求</span><br><span class="line">404       //服务器请求的网页不存在</span><br><span class="line">503       //服务器不可用</span><br></pre></td></tr></table></figure>
<p>所有状态解释：</p>
<h4 style="font-weight:bold">1XX(临时响应)</h4>
<p>表示临时响应需要请求者继续执行操作的状态码</p>
<pre>
 100       //服务器收到请求的一部分，正在等待剩余部分
 101   //请求切换协议，服务器确认并切换
</pre>
<h4 style="font-weight:bold">2XX(成功)</h4>
<p>表示响应成功--status</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">200       //OK    请求成功。一般用于GET与POST请求</span><br><span class="line">201       //Created    已创建。成功请求并创建了新的资源</span><br><span class="line">202       //Accepted    已接受。已经接受请求，但未处理完成</span><br><span class="line">203       //Non-Authoritative Information    非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</span><br><span class="line">204       //无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</span><br><span class="line">205       //重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</span><br><span class="line">206       //部分内容。服务器成功处理了部分GET请求</span><br></pre></td></tr></table></figure>
<h4 style="font-weight:bold">3XX(重定向)</h4>
<p>表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">300       //多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</span><br><span class="line">301       //永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</span><br><span class="line">302       //临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</span><br><span class="line">303       // 查看其它地址。与301类似。使用GET和POST请求查看</span><br><span class="line">304       // 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</span><br><span class="line">305       // 使用代理。所请求的资源必须通过代理访问</span><br><span class="line">306       //已经被废弃的HTTP状态码</span><br><span class="line">307       //临时重定向。与302类似。使用GET请求重定向</span><br></pre></td></tr></table></figure>
<h4 style="font-weight:bold">4XX(请求错误)</h4>
<p>这些状态码表示请求可能出错，妨碍了服务器的处理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">400       //客户端请求的语法错误，服务器无法理解</span><br><span class="line">401       //请求要求用户的身份认证</span><br><span class="line">402       //保留，将来使用</span><br><span class="line">403       //服务器理解请求客户端的请求，但是拒绝执行此请求</span><br><span class="line">404       //服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面</span><br><span class="line">405       //客户端请求中的方法被禁止</span><br><span class="line">406       //服务器无法根据客户端请求的内容特性完成请求</span><br><span class="line">407       //请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</span><br><span class="line">408       //服务器等待客户端发送的请求时间过长，超时</span><br><span class="line">409       //服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</span><br><span class="line">410       //客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</span><br><span class="line">411       //服务器无法处理客户端发送的不带Content-Length的请求信息</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<h4 style="font-weight:bold">5XX(服务器错误)</h4>
<p>这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">100       // 服务器内部错误，无法完成请求</span><br><span class="line">101       //服务器不支持请求的功能，无法完成请求</span><br><span class="line">102       //作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</span><br><span class="line">103       //由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</span><br><span class="line">104       //充当网关或代理的服务器，未及时从远端服务器获取请求</span><br><span class="line">105       //服务器不支持请求的HTTP协议的版本，无法完成处理</span><br></pre></td></tr></table></figure>
<ul><li><h4 style="font-weight:bold">强，协商缓存</h4></li></ul>
<p>顺便记录一下强缓存和协商缓存</p>
缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。
<table>
<tr>
<th>    </th>
<th>获取资源形式</th>
<th>状态码</th>
<th>是否发送请求到服务器</th>
</tr>
<tr>
<th>强缓存</th>
<th>从缓存取</th>
<th>200</th>
<th>否，直接从缓存取</th>
</tr>
<tr>
<th>协商缓存</th>
<th>从缓存取</th>
<th>状304</th>
<th>    
是，通过服务器来告知缓存是否可用</th>
</tr>
</table>
<a href="https://591616.coding-pages.com/2020/03/29/http状态码/" target="_blank" rel="noopener">本文链接(https://591616.coding-pages.com/2020/03/29/http状态码/)</a>]]></content>
      <tags>
        <tag>http状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript(一)</title>
    <url>/2020/03/30/javaScript-%E4%B8%80/</url>
    <content><![CDATA[<ul><li><h4>把多个JavaScript函数绑定到onload时间处理函数上</h4></li></ul>
<p>假设我有两个函数：firstFunction()和secondFunction()。如果我想让他们俩都在页面加载时得到执行，我该怎么办？如果把他们逐一绑定到onload事件上，他们当中将只有最后那个被执行：</p>
<pre>
<code>window.onload = firstFunction;</code>
<code>window.onload = scondFunction;</code>
</pre>
secondFunction将取代firstFunction。所以得出结论：每个事件处理函数只能绑定一条指令
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLoadEvent</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldload = <span class="built_in">window</span>.onload;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="built_in">window</span>.onload = fnc;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      oldonload();</span><br><span class="line">      func();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>
这相当于把那些将在页面加载完毕时执行的函数创建为一个队列。如果想把刚才那两个函数添加到这个队列里去，只需要写如下代码：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addLoadEvent(firstFunction)</span><br><span class="line">addLoadEvent(secondFunction)</span><br></pre></td></tr></table></figure>
---未完待续]]></content>
  </entry>
  <entry>
    <title>javaScript常用字符串以及数组处理函数</title>
    <url>/2020/05/29/javaScript%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>今天对javaScript常用的数组以及字符串函数做个总结</p>
<h4 id="数组函数">数组函数<a href="#数组函数" title="数组函数"></a></h4><h5 id="arrayprototypeconcat连接">Array.prototype.concat()(连接)<a href="#arrayprototypeconcat连接" title="Array.prototype.concat()(连接)"></a></h5><p>  <code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<p>  官网介绍的语法：<code>var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])</code></p>
<p>  说明：<code>concat</code>方法创建一个新的数组，返回的是当前数组的一个浅拷贝，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]]</span><br><span class="line"><span class="keyword">let</span> resultArr1 = arr1.concat(arr2)</span><br><span class="line"><span class="built_in">console</span>.log(resultArr1)<span class="comment">//[ 1, 2, 3, 2, 3, 4, [ 2, [ 3, 4 ] ] ]</span></span><br></pre></td></tr></table></figure><h5 id="arrayprototypeevery和arrayprototypesome">Array.prototype.every()和Array.prototype.some()<a href="#arrayprototypeevery和arrayprototypesome" title="Array.prototype.every()和Array.prototype.some()"></a></h5><p><code>every()</code> 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。而<code>some()</code> 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> even = <span class="function">(<span class="params">element</span>) =&gt;</span> element % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array.some(even));</span><br><span class="line"><span class="built_in">console</span>.log(array.every(even))</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="built_in">console</span>.log(arr.some(even));</span><br><span class="line"><span class="built_in">console</span>.log(arr.every(even))</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">注意：如果用一个空数组进行测试，some在任何情况下它返回的都是<span class="literal">false</span>。 every在任何情况下都返回<span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="arrayprototypefill">Array.prototype.fill()<a href="#arrayprototypefill" title="Array.prototype.fill()"></a></h5><p>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。参数：value,start,end.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.fill(obj,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br><span class="line"><span class="comment">//当一个对象传给value时，填充数组的是这个对象的引用。</span></span><br><span class="line">obj.a=<span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1)</span><br><span class="line"><span class="comment">//[ 1, 2, &#123; a: 1, b: 2 &#125;, 4 ]</span></span><br><span class="line"><span class="comment">//[ 1, 2, &#123; a: 3, b: 2 &#125;, 4 ]</span></span><br></pre></td></tr></table></figure><h5 id="arrayprototypefilter">Array.prototype.filter()<a href="#arrayprototypefilter" title="Array.prototype.filter()"></a></h5><p>filter()字面意思就是过滤器，返回过滤后的数组元素，刚方法创建一个新数组，对原数组不做修改。接收参数和concat()相同，value:当前处理的元素，index,当前处理元素的index,array,调用filter()的函数本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.filter(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value&gt;=<span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)<span class="comment">//[3,4]</span></span><br></pre></td></tr></table></figure><h5 id="arrayprototypefind和arrayprototypefindindex">Array.prototype.find()和Array.prototype.findIndex()<a href="#arrayprototypefind和arrayprototypefindindex" title="Array.prototype.find()和Array.prototype.findIndex()"></a></h5><p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.find(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value&gt;=<span class="number">3</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="params">value</span>=&gt;</span>value&gt;=<span class="number">3</span>))</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><h5 id="arrayprototypeflat">Array.prototype.flat()<a href="#arrayprototypeflat" title="Array.prototype.flat()"></a></h5><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。主要用处为数组扁平化，以及去除数组空值。该函数带有一个可选参数deep,默认为1.指定深度遍历的结构深度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,[[[[<span class="number">123</span>,[<span class="number">2</span>],[]]]]] ]]],<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, , ,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> array1 = array.flat(<span class="number">456</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array1)</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6,123, 2, 3, 4, 5, 6,3]</span></span><br><span class="line">MDN官网列出了几种替代方法，这里列出其中一个。有机会再总结数组扁平化的方法，以及手写个flat</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatDeep</span>(<span class="params">arr, d = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d &gt; <span class="number">0</span> ? arr.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc.concat(<span class="built_in">Array</span>.isArray(val) ? flatDeep(val, d - <span class="number">1</span>) : val), [])</span><br><span class="line">        : arr.slice();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = flatDeep(array, <span class="literal">Infinity</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><h5 id="arrayprototypeflatmap和arrayprototypemap">Array.prototype.flatmap()和Array.prototype.map()<a href="#arrayprototypeflatmap和arrayprototypemap" title="Array.prototype.flatmap()和Array.prototype.map()"></a></h5><p><code>flatMap()</code> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。它返回一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.map(<span class="function"><span class="params">x</span>=&gt;</span>[x*<span class="number">2</span>]).flat())</span><br><span class="line"><span class="built_in">console</span>.log(arr.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(arr.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(arr.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]));</span><br></pre></td></tr></table></figure><p>此外flatMap 能用于在map期间增删项目（也就是修改items的数量）。换句话说，它允许你遍历很多项使之成为另一些项（靠分别把它们放进去来处理），而不是总是一对一。 从这个意义上讲，它的作用类似于 filter的对立面。只需返回一个1项元素数组以保留该项，返回一个多元素数组以添加项，或返回一个0项元素数组以删除该项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Let's say we want to remove all the negative numbers and split the odd numbers into an even number and a 1</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">-3</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">-33</span>, <span class="number">-4</span>, <span class="number">18</span>]</span><br><span class="line"><span class="comment">//       |\  \  x   |  | \   x   x   |</span></span><br><span class="line"><span class="comment">//      [4,1, 4,   20, 16, 1,       18]</span></span><br><span class="line">a.flatMap( <span class="function">(<span class="params">n</span>) =&gt;</span></span><br><span class="line">  (n &lt; <span class="number">0</span>) ?      [] :</span><br><span class="line">  (n % <span class="number">2</span> == <span class="number">0</span>) ? [n] :</span><br><span class="line">                 [n<span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment">// expected output: [4, 1, 4, 20, 16, 1, 18]</span></span><br></pre></td></tr></table></figure><p>对于map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。<br>以下列出map的常见用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">首先是字符串引用</span><br><span class="line"><span class="keyword">let</span>  a = <span class="built_in">Array</span>.prototype.map.call(<span class="string">"Hello World"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.charCodeAt(<span class="number">0</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//querySelector应用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.querySelectorAll(<span class="string">'select option:checked'</span>);</span><br><span class="line"><span class="keyword">var</span> values = <span class="built_in">Array</span>.prototype.map.call(elems, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>map()中的坑点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(<span class="built_in">parseInt</span>));</span><br><span class="line"><span class="comment">//[1,NaN,NaN]</span></span><br><span class="line"><span class="comment">//parseInt一般第一个参数是字符串，第二个参数是进制转换值</span></span><br><span class="line"><span class="comment">//原因是parseInt 经常被带着一个参数使用, 但是这里接受两个。第一个参数是一个表达式而第二个是callback function的基,Array.prototype.map 传递3个参数，第三个参数被parseInt忽视了</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map( <span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">parseInt</span>(str) ));</span><br><span class="line"><span class="comment">//[1,2,3]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnInt</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(element, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(returnInt));</span><br><span class="line"><span class="comment">//[1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当返回undefined 或没有返回任何内容时:</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> filteredNumbers = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">num, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index &lt; <span class="number">3</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// filteredNumbers is [1, 2, 3, undefined]</span></span><br><span class="line"><span class="comment">// numbers is still [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h5 id="arrayprototypeforeach">Array.prototype.forEach()<a href="#arrayprototypeforeach" title="Array.prototype.forEach()"></a></h5><p><code>forEach()</code> 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">这里是一个使用thisArg的例子</span><br><span class="line">thisArg 参数（<span class="keyword">this</span>）传给了 forEach()，每次调用时，它都被传给 callback 函数，作为它的 <span class="keyword">this</span> 值。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Counter.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sum += entry;</span><br><span class="line">    ++<span class="keyword">this</span>.count;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// ^---- Note</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Counter();</span><br><span class="line">obj.add([<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>]);</span><br><span class="line">obj.count;</span><br><span class="line"><span class="comment">// 3 === (1 + 1 + 1)</span></span><br><span class="line">obj.sum;</span><br><span class="line"><span class="comment">// 16 === (2 + 5 + 9)</span></span><br><span class="line"></span><br><span class="line">复制对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">  <span class="keyword">const</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">  propNames.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, name);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(copy, name, desc);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">如果数组在迭代时被修改了，则其他元素会被跳过。</span><br><span class="line"><span class="keyword">const</span> obj2 = copy(obj1);</span><br><span class="line"><span class="keyword">var</span> words = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line">words.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(word);</span><br><span class="line">  <span class="keyword">if</span> (word === <span class="string">'two'</span>) &#123;</span><br><span class="line">    words.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// four</span></span><br><span class="line">还可以用作扁平化数组</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(i))</span><br><span class="line">      result.push(...flatten(i));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result.push(i);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-21-合并两个有序链表</title>
    <url>/2020/04/20/leetcode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="题目">题目<a href="#题目" title="题目"></a></h4><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h4 id="示例">示例<a href="#示例" title="示例"></a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><p>看到这道题第一个思路就是遍历其中一个链表，依次插入另一个链表。这个方法在官方解释为“迭代法”。<br>即我们假设<code>l1</code>元素严格比<code>l2</code>元素少，我们可以将<code>l2</code>中的元素逐一插入<code>l1</code>中正确的位置。</p>
<h4 id="算法思路">算法思路<a href="#算法思路" title="算法思路"></a></h4><p>首先建立一个新链表，指向空，接着建立一个“哨兵节点”<code>prevNode</code>用于不断<code>next</code>下一个添加新元素。重复遍历判断<code>l1</code>和<code>l2</code>的值，两者较小值插入，然后<code>prevNode.next</code>。一直到最后其中一个链表到达尾部指向 <code>null</code>,此时另一个链表剩余值一定比目前这个值大，所以直接连接在<code>prevNode</code>后面即可。具体实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">var</span> prevNode = prevHead</span><br><span class="line">  <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">      prevNode.next = l1</span><br><span class="line">      l1 = l1.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevNode.next = l2</span><br><span class="line">      l2 = l2.next</span><br><span class="line">    &#125;</span><br><span class="line">    prevNode = prevNode.next</span><br><span class="line">  &#125;</span><br><span class="line">  prevNode.next = l1 ? l1 : l2</span><br><span class="line">  <span class="keyword">return</span> prevHead.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是用递归方法，递归思想：递归的定义操作<code>merge</code>,比较两个链表头部较小的一个与剩下元素的<code>merge</code>操作结果合并。</p>
<h4 id="递归算法思路">递归算法思路<a href="#递归算法思路" title="递归算法思路"></a></h4><p>先判断递归终值，即判断<code>l1</code> ,<code>l2</code>为<code>null</code>的时候，<code>return</code>的值。递归内容：如果<code>l1</code>的<code>val</code>值更小，则将<code>l1.next</code>与排序好的链表头相接，<code>l2</code>同理。</p>
<h5 id="具体实现如下">具体实现如下<a href="#具体实现如下" title="具体实现如下"></a></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next = mergeLists(l1.next, l2)</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    l2.next = mergeLists(l1, l2.next)</span><br><span class="line">    <span class="keyword">return</span> l2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>leeocde-148-链表排序</title>
    <url>/2020/06/10/leeocde-%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="leetcode-148-链表排序">leetcode-148-链表排序<a href="#leetcode-148-链表排序" title="leetcode-148-链表排序"></a></h4><h5 id="题目描述：">题目描述：<a href="#题目描述：" title="题目描述："></a></h5><p>在 O(n<em>log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。<br>分析：看到O(n</em>log n)的时间复杂度以及O(1)的空间复杂度。确定使用归并排序作为主要程序结构。</p>
<p>在归并排序中，体现了分而治之的思想：利用递归算法将链表分解一个个递归基：单节点。分解利用二分的思想，逐渐分解。但链表结构不同于向量结构，向量是循秩访问，可以求出中间元素的秩。链表则是通过节点间联系访问。这里是难点之一，解决方法是利用双指针法：设置快慢两个指针，快的走两步，慢的走一步，而且快指针定义在慢指针初始位置的下一位。这样当快指针为<code>null</code>时，慢指针刚好到中间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mid = node</span><br><span class="line"><span class="keyword">let</span> fast = node.next</span><br><span class="line"><span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">  mid = mid.next</span><br><span class="line">  fast = fast.next.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表多种操作会用到双指针的方法，这里<code>while</code>语句利用短路表达式<code>&amp;&amp;</code>，使代码可读性高，易于理解。<br>有了这关键的一步，就可以递归了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node || !node.next) <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">let</span> mid = node</span><br><span class="line">    <span class="keyword">let</span> fast = node.next</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">      mid = mid.next</span><br><span class="line">      fast = fast.next.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> rightList = mid.next</span><br><span class="line">    mid.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> left = node</span><br><span class="line">    <span class="keyword">let</span> right = rightList</span><br><span class="line">    <span class="keyword">return</span> mergeList(mergeSort(left), mergeSort(right))<span class="comment">//这里的mergeSort是合并算法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>递归完成后就要合并了，合并和正常归并排序一致，将左链表与右链表逐一比较，较小者连接到头节点，即可。<br>附上完整代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sortList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  合并每个递归基</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">left</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeList</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> pre = res</span><br><span class="line">    <span class="keyword">while</span> (left &amp;&amp; right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left.val &lt;= right.val) &#123;</span><br><span class="line">        pre.next = left</span><br><span class="line">        left = left.next</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre.next = right</span><br><span class="line">        right = right.next</span><br><span class="line">      &#125;</span><br><span class="line">      pre = pre.next</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = left ? left : right</span><br><span class="line">    <span class="keyword">return</span> res.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 递归至每个递归基</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node || !node.next) <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">let</span> mid = node</span><br><span class="line">    <span class="keyword">let</span> fast = node.next</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">      mid = mid.next</span><br><span class="line">      fast = fast.next.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> rightList = mid.next</span><br><span class="line">    mid.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> left = node</span><br><span class="line">    <span class="keyword">let</span> right = rightList</span><br><span class="line">    <span class="keyword">return</span> mergeList(mergeSort(left), mergeSort(right))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mergeSort(head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然归并排序比较复杂，链表排序方法中，容易理解以及使用的还有插入排序，这在leetocde-147.<br>在数组中插入元素比较麻烦，但可以转化为元素互换，而在链表中插入是个比较容易的操作。所以插入排序很适用。这里直接贴题解代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> insertionSortList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="comment">// 哨兵节点</span></span><br><span class="line">    <span class="keyword">let</span> preHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将要移动重新插入链表中的元素</span></span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="comment">// 插入链表中的前驱位置 插入pre和pre.next之间</span></span><br><span class="line">    <span class="keyword">let</span> pre = preHead;</span><br><span class="line">    <span class="comment">// 下一个将要移动插入的元素</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">        <span class="comment">// 保存下一个将要插入的元素</span></span><br><span class="line">        next = curr.next;</span><br><span class="line">        <span class="comment">// 寻找插入的前驱位置</span></span><br><span class="line">        <span class="keyword">while</span>(pre.next &amp;&amp; pre.next.val &lt; curr.val)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        curr.next = pre.next;</span><br><span class="line">        pre.next = curr;</span><br><span class="line">        <span class="comment">// 从头或者从左到右开始遍历</span></span><br><span class="line">        pre = preHead;</span><br><span class="line">        <span class="comment">// 下一个</span></span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码中有详细注释，就不用解释了。整体代码简洁，容易理解，可以更好的理解插入排序。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-5-最长回文字符串的解法</title>
    <url>/2020/04/05/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<h5>题目：</h5>
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 <code> s </code>的最大长度为 1000。
<h6>示例一</h6>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案</span><br></pre></td></tr></table></figure>
<h6>一.暴力法</h6>
首先就是双重循环，一一遍历的暴力法，直接了当。废话不说，直接上代码。
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> huiwen = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.split(<span class="string">''</span>).join()==s.split(<span class="string">''</span>).reverse().join()) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!s || s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">var</span> ans=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i ; j&lt;s.length;j++)&#123;</span><br><span class="line">            str+=s[j]</span><br><span class="line">            <span class="comment">//console.log(str)</span></span><br><span class="line">            <span class="keyword">if</span>(huiwen(str)&amp;&amp;str.length&gt;=max)&#123;</span><br><span class="line">                max=str.length</span><br><span class="line">                ans = str</span><br><span class="line">                <span class="comment">//console.log(ans)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这是本人自己想的代码，只过了41用例，就超时了，看了看别人的暴力法通过了91用例，道理都差不多，具体应该是str的问题吧。直接到下一种方法<code>动态规划</code>
<h6>二.动态规划</h6>
<br>
<p>由于还不会在博客写公式，先贴一张leetcode的官方题解思路-动态规划</p>
<br>
<img src=/images/leetcode-最长回文字符串动态规划解答.png>
<p>代码如下：</p>
<p>作者：Alexer-660</p>
<span>链接：</span><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-by-alexer-660/" target="_blank" rel="noopener">点此直通</a><br>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s || s.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s_f = s.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">var</span> resultStr = s[<span class="number">0</span>];<span class="comment">//放结果</span></span><br><span class="line">    <span class="keyword">var</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> tmpLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> maxStrIndex = <span class="number">0</span>;<span class="comment">//最大下标</span></span><br><span class="line">    <span class="keyword">var</span> len = s.length;</span><br><span class="line">    <span class="comment">//判断字符串是否回文</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isPalinerome</span>(<span class="params">i,r</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len - i - <span class="number">1</span> == r -tmpLen + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化二维数组</span></span><br><span class="line">    <span class="keyword">var</span> len = s.length;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        arr[i] = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> r = <span class="number">0</span>;r&lt;len;r++)&#123;</span><br><span class="line">            arr[i][r] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> r=<span class="number">0</span>;r&lt;len;r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s_f[r])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || r==<span class="number">0</span>)&#123;</span><br><span class="line">                    arr[i][r] = <span class="number">1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    arr[i][r] = arr[i<span class="number">-1</span>][r<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                    tmpLen = arr[i][r]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmpLen &gt; maxLen &amp;&amp; isPalinerome(i,r))&#123;</span><br><span class="line">                    maxStrIndex = r;</span><br><span class="line">                    maxLen = tmpLen;</span><br><span class="line">                    resultStr =  s.substring(i-tmpLen+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
运行下来耗时<code>700ms</code>多，占用内存是<code>140MB</code>左右
思路已经明白，就是根据子串的回文性质，转换为求最长子串问题
，这又映射到类似的<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">leetcode-3无重复字符的最长子串问题</a>
<p>题目如下：</p>
给定一个字符串，请你找出其中不含有重复字符的 最长子串S的长度。<br>
<h6>示例</h6>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>
<p>在后面博客有讲解：<a href="#">直通</a></p><br>
本次文章到此完毕，谢谢！<span style="float:right">2020/4/4---研究一下动态规划再补充</span>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-6-Z字形变换</title>
    <url>/2020/04/04/leetcode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h5>题目描述</h5>
将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>"LCIRETOESIIGEDHN"</code>。
请你实现这个将字符串进行指定行数变换的函数：
<code>string convert(string s, int numRows);</code>
<h5>示例1：</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>
上面是题目的基本介绍，拿到这道题我的思路首先是遍历字符串，但是字符串排列规律一时间不好确定，
于是通过画图来看，本来思路是创建一个二维数组往进去填字符串，然后最后按行拼接，去除空的就像，然鹅并没有写出填的方法。于是乎打开了leetcode的题解，膜拜了一下大神的写法。先上代码：
对于大神的代码每行注释以下方便理解
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s;<span class="comment">//向来函数第一先边界判断！！！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">Math</span>.min(s.length, numRows);<span class="comment">//取字符串长度和Z高的较小值</span></span><br><span class="line">    <span class="comment">//console.log("len=" +len)//输出一下(此行我加的--忽略)</span></span><br><span class="line">    <span class="keyword">const</span> rows = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; len; i++) rows[i] = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//console.log(rows)</span></span><br><span class="line">    <span class="keyword">let</span> loc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> down = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">        rows[loc] += c;</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="number">0</span> || loc == numRows - <span class="number">1</span>)</span><br><span class="line">            down = !down;</span><br><span class="line">        loc += down ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> row <span class="keyword">of</span> rows) &#123;</span><br><span class="line">        ans += row;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(convert(<span class="string">"LEETCODEISHIRING"</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
图解如下：<a href="https://leetcode-cn.com/problems/zigzag-conversion/solution/hua-jie-suan-fa-6-z-zi-xing-bian-huan-by-guanpengc/" target="_blank" rel="noopener">转自leetcode</a>
<img src=/images/Z字形变换图解.png>
这样的解法就是把直接按行输出字符串，无中间空余，作者设了一个down参量来判断是否是“Z”的竖列，每次给<code>rows[0]rows[1]rows[2]......rows[n]</code>字符串值拼接即可得到答案，感觉很巧妙，关键在与rows的设置和down的运用。其他算法相比这个较复杂，这个好理解，等我发现更好的，或者通法再来补充。
<a href="https://leetcode-cn.com/u/guanpengchn/" target="_blank" rel="noopener">感谢这位leetcode名为灵魂画手作者的奉献</a>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题(旋转矩阵)</title>
    <url>/2020/04/07/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h5>题目描述</h5>
<p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
不占用额外内存空间能否做到？
</p>
第一种算法，引入辅助数组，再复制<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> l = matrix[<span class="number">0</span>].length</span><br><span class="line">  <span class="keyword">const</span> h = matrix.length</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(l)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    arr[i] = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix.length; j++) &#123;</span><br><span class="line">      arr[i][j] = matrix[matrix.length - <span class="number">1</span> - j][i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">      matrix[i][j] = arr[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法，直接对原数组操作，需要观察规律</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = matrix.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">      matrix[j].push(matrix[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    matrix[i].splice(<span class="number">0</span>, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JavaScript（一）</title>
    <url>/2020/05/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4 id="11-编译原理">1.1 编译原理<a href="#11-编译原理" title="1.1 编译原理"></a></h4><ul><li><p>分词/词法分析<br>这个过程是将由字符组成的字符串分解成有意义的代码块<br>例如 <code>var x = 2</code>分解为<code>var</code> ,<code>x</code>,<code>=</code> ,<code>2</code>,一个个的字符。<br>分词和词法分析主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。</p>
</li>
<li><p>解析/语法分析<br>这个过程主要是将词法单元转换成一个由元素逐级嵌套组成的代表程序语法结构的树<br>这个树叫做抽象语法树（AST）✔</p>
</li>
<li><p>代码生成<br>将上面生成的语法树解析为可执行代码的过程称为代码生成<br>而 JavaScript 引擎要比上面复杂，JavaScript 是解释型语言，会存在性能问题，不过 Google 的 V8 引擎已经优化了很多，接近 C++/C 等语言了</p>
</li>
</ul><h4 id="12-作用域">1.2 作用域<a href="#12-作用域" title="1.2 作用域"></a></h4><p>简洁的来说就是代码可被访问到的区域</p>
<p>比如声明<code>var x = 2</code>,用一段代码说明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//global</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//指向空对象null，global是顶层作用域</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//指向global，指向上一层func1定义时所在的作用域</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">123</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">//这里是for循环的作用域</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//ReferenceError: i is not defined，这里访问不到let定义的块作用域，又称作用域死区</span></span><br><span class="line">  func2()</span><br><span class="line">&#125;</span><br><span class="line">func1()</span><br></pre></td></tr></table></figure><h4 id="编译器（关于变量声明）">编译器（关于变量声明）<a href="#编译器（关于变量声明）" title="编译器（关于变量声明）"></a></h4><p>这里有 LHS 和 RHS 查询，即左值查询与右值查询（右值在 C 语言是一个专业术语）这里不过多解释<br>。这里 LHS 和 RHS 查询分别是对等号左右的值进行查询，例如<code>var x = 2</code>，编译器编译到这里会对 x 进 console.log(b)行 LHS 查询，如果在当前作用域没有查到，就会向上一层作用域继续查询，目的是为 2 找到一个赋值的目标，而<code>console.log(b)</code>则会进行 RHS 查询，目的是对<code>console.log()</code>引用地址的查询，找到 b 是谁，或者说在哪。如果 RHS 在所有的作用域中都没有找到所需要的变量，会抛出异常，是 ReferenceERROR 错误，引用错误。但是 LHS 如果在顶层作用域中也没找到变量时，则会创建一个该变量。（严格模式中会直接和 RHS 一样抛出错误）<br>这里有一个隐式说明要注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">(a)</span></span>&#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/LHS和RHS.jpg" class="φcy" alt="这里有个例子"><br>上面代码片段会有一次 LHS 查询，<code>a=2</code>,这是隐式的，可能会被忽略。</p>
<h4 id="词法作用域">词法作用域<a href="#词法作用域" title="词法作用域"></a></h4><p>这里有两个关键词：</p>
<ul><li>词法化</li>
<li>遮蔽效应<br>词法作用域是由你在写代码时将变量和块作用域写在哪里决定的。<br>遮蔽效应是如果在当前作用域和上一层作用域存在相同名称的变量，如果在当前作用域调用该变量，则当前作用域的变量会遮蔽外层作用域的变量</li>
</ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function">function <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span> <span class="comment">//这里如果注释掉，下面会输出1</span></span><br><span class="line">  console.log(a) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p>在词法作用域中有两种欺骗词法：<code>eval()</code> 和 <code>with()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str) <span class="comment">//eval()将其中的参数会解析为js代码，并运行。</span></span><br><span class="line">  <span class="comment">//严格模式中。eval()运行时有自己的词法作用域，这样其中的参数将不会修改所在的作用域</span></span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">foo(<span class="string">'var b=123'</span>, <span class="number">234</span>) <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>还有 with()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">  b: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">foo(o1)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a)</span><br><span class="line">foo(o2)</span><br><span class="line"><span class="built_in">console</span>.log(o2.a) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//2,a被泄露到全局作用域里了</span></span><br></pre></td></tr></table></figure><p>with()可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域<br>当我们给 with()传 o1 时，o1 内部有 a 属性，直接赋值，而传 o2 时，内部没有，则进行 LHS 查询到全局作用域赋值<br>，with()实际是给传递给他的变量创造了一个新的词法作用域。</p>
<h4 id="this">this<a href="#this" title="this"></a></h4><p>常见 this 理解误区</p>
<ul><li>1.this 指向自身</li>
<li>2.this 指向它的作用域（这种比较容易混淆，在某些状况是正确的，在其他状况是错误的）</li>
</ul><h5 id="this-绑定规则">this 绑定规则<a href="#this-绑定规则" title="this 绑定规则"></a></h5><ul><li>默认绑定</li>
</ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">f1() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>隐式绑定</li>
</ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  f2: f1,</span><br><span class="line">&#125;</span><br><span class="line">obj.f2()</span><br></pre></td></tr></table></figure><p>隐式绑定一个常见的问题是隐式绑定的函数会丢失绑定对象<br>，会引用默认绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line">a = <span class="string">'123'</span></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">这里的参数传递其实就是一种隐式赋值。传入函数时也会被隐式赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoFoo</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  f()</span><br><span class="line">  obj.foo()</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="string">'123'</span></span><br><span class="line">obj = &#123;</span><br><span class="line">  a: <span class="number">223</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line">DoFoo(obj.foo)</span><br></pre></td></tr></table></figure><p>还有一个问题是在回调函数中很容易出现 this 丢失的情况，而在一些回调函数中，还会出现修改 this 指向的情况<br>判断 this 的优先级</p>
<ul><li>函数是否在 new 中调用，(new 绑定)？如果是的话 this 绑定的是新创建的对象</li>
<li><code>var bar = new foo()</code></li>
<li>函数是否通过 call()，apply()或者硬绑定调用？如果是的话，this 绑定的是指定的对象</li>
<li><code>var bar =foo.call(obj)</code></li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象</li>
<li><code>var bar = obj1.foo()</code></li>
<li>如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到 undefined，负责绑定到全局对象。</li>
<li><code>var bar = foo()</code></li>
</ul><h4 id="被忽略的-this">被忽略的 this<a href="#被忽略的-this" title="被忽略的 this"></a></h4><p>如果 call(),apply(),bind()，第一个参数传入的是 null 或者 undefined，那么实际绑定为默认绑定，常见的一种做法是用 apply(null,[…])，但是总是使用<code>null</code>有时会产生不必要的效果，比如 this 指向了全局作用域，这样会在不知不觉中修改了全局变量，一种安全的 this 做法是，利用<code>object.create(null)</code>创建一个空对象来作为 this 指向。</p>
<h4 id="间接引用">间接引用<a href="#间接引用" title="间接引用"></a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123;</span><br><span class="line">  a: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">o2.foo() <span class="comment">//3</span></span><br><span class="line">;(o3.foo = o2.foo)() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>赋值表达式 o3.foo=o2.foo 返回值是目标函数的引用，因此调用位置是 foo()而不是 o3.foo(),于是会用默认绑定，绑定到全局作用域，而全局作用域没有定义<code>a</code>，输出 undefined。</p>
<h4 id="this-词法">this 词法<a href="#this-词法" title="this 词法"></a></h4><p>上面是正常函数定义<code>function(){}</code>，而 ES6 中提出新的定义函数方式：箭头函数，箭头函数 this 指向有外层作用域来决定，来看一段代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a) =&gt; &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo.call(obj1)</span><br><span class="line">bar.call(obj2) <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>foo 内部 return 的箭头函数，this 调用时会捕获 foo()的 this，而 foo 的 this 绑定到来 obj1，所以 bar 的 call()无效了。</p>
]]></content>
      <tags>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack打包</title>
    <url>/2020/04/19/webpack%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="webpack">webpack<a href="#webpack" title="webpack"></a></h1><p>webpack 是一个打包工具，可以通过 npm 下载安装：<code>npm install -g webpack</code>来安装。</p>
<h3 id="原因">原因<a href="#原因" title="原因"></a></h3><p>我们在构建网站时，在 <code>&lt;script&gt;</code> 或者<code>&lt;link&gt;</code>标签中会引入静态资源文件。</p>
<h3 id="常见的静态资源">常见的静态资源<a href="#常见的静态资源" title="常见的静态资源"></a></h3><ol><li>.js .jsx .coffee .ts(typescript)</li>
<li>css</li>
<li>images</li>
<li>字体文件</li>
<li>模板文件</li>
</ol><p>这些静态文件是我们经常需要引用的，但是浏览器解析渲染时，如果静态资源太多，会加载变慢。还有许多依赖关系也会影响。<br>解决问题就是：</p>
<ul><li>合并，压缩</li>
<li>图片的 base64 编码</li>
<li>使用 requireJS,也可用 webpack 解决依赖关系</li>
<li>Gulp 是基于 task 的解决方案</li>
<li>webpack 是基于项目的解决方案</li>
</ul><h2 id="初次使用-webpack">初次使用 webpack<a href="#初次使用-webpack" title="初次使用 webpack"></a></h2><p>html 的隔行变色<br>首先是构建一个项目目录：</p>
<ul><li>dist （webpack 打包后的文件目录）</li>
<li>src （html,css,js 文件）</li>
<li>node_modules（npm 引入的库文件）</li>
<li>package.json （npm init）</li>
</ul><p>先建立 index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=/, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--下面的script标签是在webpack打包之后引入的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../dist/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是一个标签<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>src&gt;main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'li:odd'</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'lightblue'</span>)</span><br><span class="line">  $(<span class="string">'li:even'</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'lightyellow'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先在 dist 目录下创建 main.js 文件<br>接着在项目目录下面执行<code>webpack ./src/main.js ./dist/main.js</code> 就会生成 main.js 文件，运行～，成功！</p>
<p>具体可见<a href="http://webpackjs.com" target="_blank">webpack 官网</a></p>
<p>后续再补充！</p>
]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>浏览器兼容</tag>
      </tags>
  </entry>
  <entry>
    <title>前端项目服务端渲染（SSR）</title>
    <url>/2021/02/16/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%EF%BC%89/</url>
    <content><![CDATA[<h3 id="名词解释">名词解释<a href="#名词解释" title="名词解释"></a></h3><h4 id="ssr">SSR<a href="#ssr" title="SSR"></a></h4><ul><li>SSR：服务器端渲染-将客户端或通用应用程序渲染到服务器上的HTML。</li>
</ul><h4 id="csr">CSR<a href="#csr" title="CSR"></a></h4><ul><li>CSR：客户端渲染-通常使用DOM在浏览器中渲染应用程序。</li>
</ul><h4 id="rehydration">Rehydration<a href="#rehydration" title="Rehydration"></a></h4><ul><li>Rehydration： “启动”客户端上的JavaScript视图，以便它们重用服务器渲染的HTML的DOM树和数据。</li>
</ul><h4 id="prerendering">Prerendering<a href="#prerendering" title="Prerendering"></a></h4><ul><li>Prerendering：在构建时运行客户端应用程序以将其初始状态捕获为静态HTML。</li>
</ul><h4 id="ttfb">TTFB<a href="#ttfb" title="TTFB"></a></h4><ul><li>TTFB： 到第一个字节的时间-视为单击链接到输入内容的第一位之间的时间。</li>
</ul><h4 id="fp">FP<a href="#fp" title="FP"></a></h4><ul><li>FP： First Paint-第一次获取任何像素对用户可见。</li>
</ul><h4 id="fcp">FCP<a href="#fcp" title="FCP"></a></h4><ul><li>FCP： 第一个内容丰富的油漆-所请求的内容（文章主体等）可见的时间。</li>
</ul><h4 id="tti">TTI<a href="#tti" title="TTI"></a></h4><ul><li>TTI： 互动时间-页面互动的时间（事件连线等）。</li>
</ul><h3 id="前端渲染介绍">前端渲染介绍<a href="#前端渲染介绍" title="前端渲染介绍"></a></h3><h4 id="csr客户端渲染">CSR客户端渲染<a href="#csr客户端渲染" title="CSR客户端渲染"></a></h4><p>今天介绍的是服务端渲染（Server-side Rendering）,简称为SSR。<br>首先介绍一下常见的web渲染模式，第一个是目前前后端分离的主要开发模式，也是大多数前端同学的开发方式，就是客户端渲染（Client-side Rendering）。目前的三大框架Angular,React,Vue都是基于CSR开发的框架，我们在开发时只需要和后端同学，提前约定好接口，接着前端页面由我们前端同学开发构建，在需要页面刷新的地方，可以使用Ajax技术进行局部刷新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CSR (Client-Side Rendering) – rendering an app <span class="keyword">in</span> a browser, generally using the DOM.</span><br></pre></td></tr></table></figure><p><img src="/images/CSR渲染.png" class="φcy" title="CSR渲染图" alt="CSR渲染"><br>上图是Google大会上贴出的介绍CSR的一张原理图，net代表网络请求，请求js文件“bundle.js”,此时是FCP时间点，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FCP：First Contentful Paint - the time when requested content (article body, etc) becomes visible.</span><br></pre></td></tr></table></figure><p>翻译过来就是：第一个内容丰富的渲染-所请求的内容（文章主体等）可见的时间。接下来由我们的js引擎以及浏览器渲染引擎渲染更多的页面内容。渲染完毕后又到了一个时间点：TTI。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TTI: Time To Interactive - the time at which a page becomes interactive (events wired up, etc)</span><br></pre></td></tr></table></figure><p>翻译过来就是：”互动时间-页面互动的时间（事件被整理等”,也就是用户第一次可以与页面交互的时间点。而从FCP到TTI需要花费的时间则是由我们前端打包的js文件大小决定。这其中包含了我们的业务代码，同时又有第三方库的部分代码。对于性能较差的机器，也就花费时间更长。在google大会上提到的有利用HTTP/2 Server Push或者<code>&lt;link rel=preload&gt;</code>加载数据，可以提升性能，而在我们前端开发中还可以使用懒加载，webpack的treeshaking等等减少js文件大小来减少渲染时长。同时由于目前的前端框架大多开发的是单页面应用SPA（single page Application）,如果js文件较大，则首屏加载会变慢，影响用户体验。让我换个思路，改变渲染模式，想想会有什么效果。</p>
<h4 id="ssr服务端渲染">SSR服务端渲染<a href="#ssr服务端渲染" title="SSR服务端渲染"></a></h4><p>服务器呈现响应于导航生成服务器上页面的完整HTML。这样可以避免客户端进行数据获取和模板化的其他往返过程，因为它是在浏览器获得响应之前进行处理的。服务器渲染通常会产生快速的First Paint  （FP）和First Contentful Paint  （FCP）。在服务器上运行页面逻辑和呈现可以避免向客户端发送大量JavaScript，这有助于实现快速的交互时间 （TTI）。这是有道理的，因为使用服务器渲染，您实际上只是将文本和链接发送到用户的浏览器。这种方法可以在很大范围的设备和网络条件下很好地工作，并且可以带来有趣的浏览器优化，例如流文档解析。SSR渲染过程大致如下图所示：</p>
<p><img src="/images/SSR渲染.png" class="φcy" title="CSR渲染图" alt="CSR渲染"><br>通过服务器渲染，用户不太可能会等待CPU绑定的JavaScript处理才能使用您的网站。即使 无法避免使用第三方JS，使用服务器渲染来减少自己的第一方JS成本也可以为您提供更多的“预算”。但是，此方法有一个主要缺点：在服务器上生成页面会花费时间，这通常会导致首字节时间 （TTFB）变慢。</p>
<p>服务器渲染的动态特性可能会带来可观的计算开销。许多服务器渲染解决方案不会提早刷新，可能会延迟TTFB或将发送的数据加倍（例如，客户端JS使用的内联状态）。在<code>React</code>中，<code>renderToString()</code>可能很慢，因为它是同步的并且是单线程的。要使服务器呈现“正确”状态，可能涉及寻找或构建组件缓存解决方案，管理内存消耗，应用备忘录技术以及许多其他问题。通常，您要多次处理/重建同一应用程序-一次在客户端，一次在服务器。仅仅因为服务器渲染可以使某些事情更快地出现，并不意味着您要做的工作更少。</p>
<p>服务器渲染会为每个<code>URL</code>按需生成<code>HTML</code>，但比仅提供静态渲染内容要慢。如果您可以进行其他工作，则服务器渲染+ HTML缓存可以大大减少服务器渲染时间。服务器渲染的优势在于，与静态渲染相比，它能够提取更多的“实时”数据并响应更完整的请求集。需要个性化的页面是请求类型的一个具体示例，无法与静态渲染一起很好地工作。</p>
<h3 id="参考链接">参考链接<a href="#参考链接" title="参考链接"></a></h3><p><a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#server-vs-static" target="_blank">Google开发者大会对于前端渲染的介绍</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/04/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>动态规划的问题总结如下：</p>
<h4 id="1斐波那契数列引入动态规划问题">1.斐波那契数列引入动态规划问题<a href="#1斐波那契数列引入动态规划问题" title="1.斐波那契数列引入动态规划问题"></a></h4><p><img src="/images/动态规划.png" class="φcy" alt="123"><br>使用动态规划思想解决问题的起点是，通过分解目标问题，得到要解决目标问题的子问题。通过对子问题的求解，继而求解其他更加复杂的子问题(包括“最终问题”)。类似递归的逆过程，“递归”是自顶向下的循环求解思想，而“动态规划”是自下而上的求解思想，从子问题向上求解。<br>下面三个例子都是动态规划的经典问题：</p>
<h6 id="1求解最长公共子串">1.求解最长公共子串<a href="#1求解最长公共子串" title="1.求解最长公共子串"></a></h6><p>题目：给定两个字符串  text1 和  text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的   子序列   是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>若这两个字符串没有公共子序列，则返回 0。</p>
<h6 id="示例-1">示例 1<a href="#示例-1" title="示例 1"></a></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abcde"</span>, text2 = <span class="string">"ace"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">"ace"</span>，它的长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p>思路为动态规划，使用一个二维数组存储两个字符串相同<br>位置的字符比较结果。初始化时，该数组的每一个元素被设置为 0。每次在这两个数组的<br>相同位置发现了匹配，就将数组对应行和列的元素加 1，否则保持为 0。<br>按照这种方式，一个变量会持续记录下找到了多少个匹配项。当算法执行完毕时，这个变<br>量会结合一个索引变量来获得最长公共子串。<br>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">text1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">text2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="function"><span class="keyword">function</span> (<span class="params">text1, text2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = text1.length</span><br><span class="line">  <span class="keyword">let</span> m = text2.length</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>), () =&gt; <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>))</span><br><span class="line">  <span class="comment">//这里用到了ES6的新Array方法from,实现一个浅拷贝，向数组赋值0，</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">Math</span>.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n][m]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="下面有两道题用到了动态规划，当然也有别的方法，此处只是对动态规划进行应用与演示">下面有两道题用到了动态规划，当然也有别的方法，此处只是对动态规划进行应用与演示.<a href="#下面有两道题用到了动态规划，当然也有别的方法，此处只是对动态规划进行应用与演示" title="下面有两道题用到了动态规划，当然也有别的方法，此处只是对动态规划进行应用与演示."></a></h5><h4 id="2leetcode-62-不同路径-i">2.leetcode-62-不同路径 I<a href="#2leetcode-62-不同路径-i" title="2.leetcode-62-不同路径 I"></a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1</span>. 向右 -&gt; 向右 -&gt; 向下 <span class="number">2</span>. 向右 -&gt; 向下 -&gt; 向右 <span class="number">3</span>. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[i][j] = <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3leetcode-63-不同路径-ii障碍物">3.leetcode-63-不同路径 II(障碍物)<a href="#3leetcode-63-不同路径-ii障碍物" title="3.leetcode-63-不同路径 II(障碍物)"></a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: [   [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],   [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],   [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] ]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">3</span>x3</span><br><span class="line">网格的正中间有一个障碍物。 从左上角到右下角一共有 <span class="number">2</span> 条不同的路径： <span class="number">1.</span> 向右 -&gt;</span><br><span class="line">向右 -&gt; 向下 -&gt; 向下 <span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">obstacleGrid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span> (<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = obstacleGrid.length</span><br><span class="line">  <span class="keyword">var</span> m = obstacleGrid[<span class="number">0</span>].length</span><br><span class="line">  <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (dp[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] != <span class="number">1</span>) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> r = <span class="number">1</span>; r &lt; n; r++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[r][<span class="number">0</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">      dp[r][<span class="number">0</span>] = dp[r - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> r = <span class="number">1</span>; r &lt; m; r++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obstacleGrid[i][r] != <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][r] = dp[i - <span class="number">1</span>][r] + dp[i][r - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>算法思想</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现的call,apply,bind,new</title>
    <url>/2020/06/28/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%9A%84call-apply-bind-new/</url>
    <content><![CDATA[<h4 id="call">call<a href="#call" title="call"></a></h4><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数<br>语法：<code>function.call(thisArg, arg1, arg2, ...)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//console.log(this)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>) <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line">  thisArg = thisArg || global || <span class="built_in">window</span> <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line">  thisArg[fn] = <span class="keyword">this</span> <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[fn](...args) <span class="comment">// 执行当前函数</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn] <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reply = [<span class="keyword">this</span>.animal, <span class="string">'typically sleep between'</span>, <span class="keyword">this</span>.sleepDuration].join(</span><br><span class="line">    <span class="string">' '</span></span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log(reply)</span><br><span class="line">&#125;</span><br><span class="line">global.obj = &#123;</span><br><span class="line">  animal: <span class="string">'cats'</span>,</span><br><span class="line">  sleepDuration: <span class="string">'12 and 16 hours'</span>,</span><br><span class="line">&#125;</span><br><span class="line">greet()<span class="comment">// typically sleep between</span></span><br><span class="line">greet.mycall(obj)<span class="comment">//cats typically sleep between 12 and 16 hours</span></span><br></pre></td></tr></table></figure><h4 id="apply">apply<a href="#apply" title="apply"></a></h4><p><code>apply()</code> 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。<br>语法：<code>func.apply(thisArg, [argsArray])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>) <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line">  thisArg = thisArg || <span class="built_in">window</span> <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line">  thisArg[fn] = <span class="keyword">this</span> <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[fn](...args) <span class="comment">// 执行当前函数</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[fn] <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="comment">// 返回函数执行结果</span></span><br><span class="line">&#125;</span><br><span class="line">greet.myApply(obj, [])<span class="comment">//cats typically sleep between 12 and 16 hours</span></span><br></pre></td></tr></table></figure><h4 id="bind">Bind<a href="#bind" title="Bind"></a></h4><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br>语法: <code>function.bind(thisArg, arg1, arg2, ...)</code><br>注意三点:</p>
<ul><li>bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数</li>
<li>new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例</li>
<li>没有保留原函数在原型链上的属性和方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Bind must be called on a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// new优先级</span></span><br><span class="line">  <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.apply(</span><br><span class="line">      <span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : thisArg,</span><br><span class="line">      args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 继承原型上的属性和方法</span></span><br><span class="line">  fbound.prototype = <span class="built_in">Object</span>.create(self.prototype)</span><br><span class="line">  <span class="keyword">return</span> fbound</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = greet.bind(obj)</span><br><span class="line">result()<span class="comment">//cats typically sleep between 12 and 16 hours</span></span><br></pre></td></tr></table></figure><h4 id="new">new<a href="#new" title="new"></a></h4></li>
</ul><p>首先我们要知道new做了什么</p>
<ul><li>创建一个新对象，并继承其构造函数的prototype，这一步是为了继承构造函数原型上的属性和方法</li>
<li>执行构造函数，方法内的this被指定为该新实例，这一步是为了执行构造函数内的赋值操作</li>
<li>返回新实例（规范规定，如果构造方法返回了一个对象，那么返回该对象，否则返回第一步创建的新对象）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">item,...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(item.prototype)</span><br><span class="line">    <span class="comment">//这里要注意是否对象会有返回值</span></span><br><span class="line">    <span class="keyword">let</span> result = item.apply(obj,args)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> item()===<span class="literal">undefined</span>?obj:result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b1 = myNew(Book,<span class="string">"javaScript"</span>)</span><br><span class="line"><span class="keyword">let</span> b2 = <span class="keyword">new</span> Book(<span class="string">"javaScript"</span>)</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">Book.apply(obj1,[<span class="string">"123"</span>])</span><br><span class="line"><span class="built_in">console</span>.log(obj1)<span class="comment">//&#123; name: '123' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b1)<span class="comment">//&#123; name: 'javaScript' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b2)<span class="comment">//&#123; name: 'javaScript' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>]]></content>
      <tags>
        <tag>call</tag>
        <tag>apply</tag>
        <tag>bind</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数</title>
    <url>/2020/04/21/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="箭头函数">箭头函数<a href="#箭头函数" title="箭头函数"></a></h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>
<h4 id="例">例<a href="#例" title="例"></a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> materials = [<span class="string">'Hydrogen'</span>, <span class="string">'Helium'</span>, <span class="string">'Lithium'</span>, <span class="string">'Beryllium'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(materials.map(<span class="function">(<span class="params">material</span>) =&gt;</span> material.length))</span><br><span class="line"><span class="comment">// expected output: Array [8, 6, 7, 9]</span></span><br></pre></td></tr></table></figure><h4 id="基础语法">基础语法<a href="#基础语法" title="基础语法"></a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"><span class="comment">//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当只有一个参数时，圆括号是可选的：</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有参数的函数应该写成一对圆括号。</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><h4 id="高级语法">高级语法<a href="#高级语法" title="高级语法"></a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加括号的函数体返回对象字面量表达式：</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持剩余参数和默认参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123;</span><br><span class="line">statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样支持参数列表解构</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line">f();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h5 id="引入箭头函数主要有两个方面的作用更简短的函数而且不绑定-this">引入箭头函数主要有两个方面的作用:更简短的函数而且不绑定 this<a href="#引入箭头函数主要有两个方面的作用更简短的函数而且不绑定-this" title="引入箭头函数主要有两个方面的作用:更简短的函数而且不绑定 this"></a></h5><p>箭头函数不会创建自己的<code>this</code>,它只会从自己的作用域链的上一层继承<code>this</code>。因此，在下面的代码中，传递给<code>setInterval</code>的函数内的 this 与封闭函数中的<code>this</code>值相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.age++ <span class="comment">// |this| 正确地指向 p 实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure><h4 id="通过call和apply调用">通过<code>call</code>和<code>apply</code>调用<a href="#通过call和apply调用" title="通过call和apply调用"></a></h4><p>由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定 this），他们的第一个参数会被忽略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  base : <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  add : function(a) &#123;</span><br><span class="line">    <span class="keyword">var</span> f = v =&gt; v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: function(a) &#123;</span><br><span class="line">    <span class="keyword">var</span> f = v =&gt; v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      base : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line">console.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure><h5 id="使用箭头函数作为方法">使用箭头函数作为方法<a href="#使用箭头函数作为方法" title="使用箭头函数作为方法"></a></h5><p>箭头函数作为方法时，由于没有定义<code>this</code>绑定，方法里指向里上一个作用链的作用域。下面是例子中指向的是全局作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用箭头函数作为方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, <span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, <span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//obj.b() //undefined &#123;&#125;</span></span><br><span class="line"><span class="comment">//上面是在node环境下运行的，在浏览器环境下运行会输出：undefined,window</span></span><br><span class="line"><span class="comment">//obj.c() //1 &#123;a:1.b:[Function:b],c:[Function:c]&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'b'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, <span class="keyword">typeof</span> <span class="keyword">this</span>.a, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a++</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//obj.b //undefined 'undefined' &#123;&#125;</span></span><br><span class="line"><span class="comment">//箭头函数不能用作构造器，和new一起用会报错</span></span><br><span class="line"><span class="comment">/*(var Foo = () =&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">var f = new Foo()*/</span></span><br><span class="line"><span class="comment">//箭头函数也没有prototype属性，同样报错</span></span><br><span class="line"><span class="comment">//箭头函数不能用作函数生成器。</span></span><br></pre></td></tr></table></figure><h6 id="还有几点注意：">还有几点注意：<a href="#还有几点注意：" title="还有几点注意："></a></h6><ul><li>箭头函数返回子面量对象时要加括号（这是因为花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。）</li>
<li>箭头函数的作用域注意，是局部作用域</li>
</ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Good'</span> + (now.getHours() &gt; <span class="number">17</span> ? <span class="string">' evening.'</span> : <span class="string">' day.'</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting() <span class="comment">//"Good day."</span></span><br><span class="line"><span class="built_in">console</span>.log(now) <span class="comment">// ReferenceError: now is not defined 标准的let作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数括号内定义的变量是局部变量（默认参数）</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="function">(<span class="params">now = <span class="keyword">new</span> <span class="built_in">Date</span>(</span>)) =&gt;</span></span><br><span class="line">  <span class="string">'Good'</span> + (now.getHours() &gt; <span class="number">17</span> ? <span class="string">' evening.'</span> : <span class="string">' day.'</span>)</span><br><span class="line">greeting() <span class="comment">//"Good day."</span></span><br><span class="line"><span class="built_in">console</span>.log(now) <span class="comment">// ReferenceError: now is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比：函数体内&#123;&#125;不使用var定义的变量是全局变量</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Good'</span> + (now.getHours() &gt; <span class="number">17</span> ? <span class="string">' evening.'</span> : <span class="string">' day.'</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting() <span class="comment">//"Good day."</span></span><br><span class="line"><span class="built_in">console</span>.log(now) <span class="comment">// Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比：函数体内&#123;&#125; 用var定义的变量是局部变量</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Good'</span> + (now.getHours() &gt; <span class="number">17</span> ? <span class="string">' evening.'</span> : <span class="string">' day.'</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting() <span class="comment">//"Good day."</span></span><br><span class="line"><span class="built_in">console</span>.log(now) <span class="comment">// ReferenceError: now is not defined</span></span><br></pre></td></tr></table></figure><p>上面是 MDN 的例子。</p>
<ul><li>同样的箭头函数还可以使用闭包和递归</li>
</ul><h5 id="2020425-补充">2020/4/25 补充<a href="#2020425-补充" title="2020/4/25 补充"></a></h5><h5 id="箭头函数与匿名函数的区别">箭头函数与匿名函数的区别<a href="#箭头函数与匿名函数的区别" title="箭头函数与匿名函数的区别"></a></h5><ul><li><p>this 指向区别</p>
<ul><li>箭头函数根据所在的环境（我在哪个环境中，this 就指向谁），Arrow functions bind the parent context。按照词法作用域绑定 this</li>
<li>匿名函数中 this 指向 window</li>
</ul></li>
</ul><h6 id="使用箭头函数注意几点">使用箭头函数注意几点<a href="#使用箭头函数注意几点" title="使用箭头函数注意几点"></a></h6><ul><li><p>1、函数体内的 this 对象就是定义时所在的对象，而不是使用时所在对象；</p>
</li>
<li><p>2、不可以当作构造函数使用，也就是不能用 new 命令实例化一个对象，否则会抛出一个错误；</p>
</li>
<li><p>3、不可以使用 arguments 对象，该对象在函数体内不存在，如果要用的话，可以用 rest 参数代替；</p>
</li>
<li><p>4、不可以使用 yield 命令，箭头函数不能用作 Generator 函数；</p>
</li>
</ul>]]></content>
      <tags>
        <tag>javascript函数</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Angular Universal做ssr渲染</title>
    <url>/2021/12/13/%E4%BD%BF%E7%94%A8angular-universal%E5%81%9Assr%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>最近在公司的项目中用到了react做ssr渲染，于是想在angular中也试试，angular在很久之前就出了做ssr渲染的库，名字是<code>@nguniversal/express-engine</code>,使用<code>ng add</code>可以稳定的将自己的项目转化为<code>ssr</code>渲染模式</p>
<h3 id="如何构建服务端渲染项目">如何构建服务端渲染项目<a href="#如何构建服务端渲染项目" title="如何构建服务端渲染项目"></a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ng add @nguniversal/express-engine</span><br></pre></td></tr></table></figure><p>这样我们的项目中会多出几个文件，分别是</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  main.server.ts             * bootstrapper <span class="keyword">for</span> server app</span><br><span class="line">  app/ ...                   application code</span><br><span class="line">    app.server.module.ts     * server-side application module</span><br><span class="line">server.ts                    * express web server</span><br><span class="line">tsconfig.server.json         TypeScript server application configuration</span><br></pre></td></tr></table></figure><p>首先是<code>main.server.ts</code>文件如下：这个文件主要是服务端渲染的初始化文件，包括设置环境<code>enableProdMode</code>以及<code>export AppServerModule</code>模块在<code>server</code>中<code>bootstrap</code></p>
<ul><li><code>main.server.ts</code></li>
</ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************************************</span></span><br><span class="line"><span class="comment"> * Initialize the server environment - for example, adding DOM built-in types to the global scope.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment"> * This import must come before any imports (direct or transitive) that rely on DOM built-ins being</span></span><br><span class="line"><span class="comment"> * available, such as `<span class="doctag">@angular</span>/elements`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'@angular/platform-server/init'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; enableProdMode &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; environment &#125; <span class="keyword">from</span> <span class="string">'./environments/environment'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (environment.production) &#123;</span><br><span class="line">  enableProdMode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; AppServerModule &#125; <span class="keyword">from</span> <span class="string">'./app/app.server.module'</span></span><br><span class="line"><span class="keyword">export</span> &#123; renderModule, renderModuleFactory &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-server'</span></span><br></pre></td></tr></table></figure><p>其次一个比较重要的文件是<code>server.ts</code>文件：这里是<code>express</code>启动的地方，以及各种服务端的中间处理逻辑都写在这里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'zone.js/dist/zone-node'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ngExpressEngine &#125; <span class="keyword">from</span> <span class="string">'@nguniversal/express-engine'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">'express'</span></span><br><span class="line"><span class="keyword">import</span> &#123; join &#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createProxyMiddleware &#125; <span class="keyword">from</span> <span class="string">'http-proxy-middleware'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppServerModule &#125; <span class="keyword">from</span> <span class="string">'./src/main.server'</span></span><br><span class="line"><span class="keyword">import</span> &#123; APP_BASE_HREF &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span></span><br><span class="line"><span class="keyword">import</span> &#123; existsSync &#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The Express app is exported so that it can be used by serverless Functions.</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">app</span>(<span class="params"></span>): <span class="title">express</span>.<span class="title">Express</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> server = express()</span><br><span class="line">  <span class="keyword">const</span> distFolder = join(process.cwd(), <span class="string">'dist/mean-app/browser'</span>)</span><br><span class="line">  <span class="keyword">const</span> indexHtml = existsSync(join(distFolder, <span class="string">'index.original.html'</span>))</span><br><span class="line">    ? <span class="string">'index.original.html'</span></span><br><span class="line">    : <span class="string">'index'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our Universal express-engine (found @ https://github.com/angular/universal/tree/master/modules/express-engine)</span></span><br><span class="line">  server.engine(</span><br><span class="line">    <span class="string">'html'</span>,</span><br><span class="line">    ngExpressEngine(&#123;</span><br><span class="line">      bootstrap: AppServerModule,</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  server.set(<span class="string">'view engine'</span>, <span class="string">'html'</span>)</span><br><span class="line">  server.set(<span class="string">'views'</span>, distFolder)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Example Express Rest API endpoints</span></span><br><span class="line">  <span class="comment">// server.get('/api/**', (req, res) =&gt; &#123; &#125;);</span></span><br><span class="line">  <span class="comment">// Serve static files from /browser</span></span><br><span class="line">  server.get(</span><br><span class="line">    <span class="string">'*.*'</span>,</span><br><span class="line">    express.static(distFolder, &#123;</span><br><span class="line">      maxAge: <span class="string">'1y'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  server.use(</span><br><span class="line">    <span class="string">'/api'</span>,</span><br><span class="line">    createProxyMiddleware(&#123;</span><br><span class="line">      target: <span class="string">'https://data.mongodb-api.com/...'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/api'</span>: <span class="string">'/'</span>, <span class="comment">// rewrite path</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// All regular routes use the Universal engine</span></span><br><span class="line">  server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.render(indexHtml, &#123;</span><br><span class="line">      req,</span><br><span class="line">      providers: [&#123; <span class="attr">provide</span>: APP_BASE_HREF, <span class="attr">useValue</span>: req.baseUrl &#125;],</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> port = process.env.PORT || <span class="number">4000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start up the Node server</span></span><br><span class="line">  <span class="keyword">const</span> server = app()</span><br><span class="line">  server.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Node Express server listening on http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Webpack will replace 'require' with '__webpack_require__'</span></span><br><span class="line"><span class="comment">// '__non_webpack_require__' is a proxy to Node 'require'</span></span><br><span class="line"><span class="comment">// The below code is to ensure that the server is run only when not requiring the bundle.</span></span><br><span class="line">declare <span class="keyword">const</span> __non_webpack_require__: NodeRequire</span><br><span class="line"><span class="keyword">const</span> mainModule = __non_webpack_require__.main</span><br><span class="line"><span class="keyword">const</span> moduleFilename = (mainModule &amp;&amp; mainModule.filename) || <span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> (moduleFilename === __filename || moduleFilename.includes(<span class="string">'iisnode'</span>)) &#123;</span><br><span class="line">  run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./src/main.server'</span></span><br></pre></td></tr></table></figure><p>这里主要的逻辑有</p>
<ul><li>1.服务端<code>express</code>引擎处理html</li>
<li>2.设置静态文件的加载</li>
<li>3.设置路由</li>
<li>4.对<code>response</code>和<code>request</code>做处理(middleware)</li>
</ul><p>最后是<code>app.server.module.ts</code>是整个angular应用的顶层模块注入管理，在<code>@NgModule</code>中引入了两个新的模块处理服务端渲染的状态管理和模块注入。</p>
<h4 id="坑点1">坑点1<a href="#坑点1" title="坑点1"></a></h4><p>正常来说，通过Angular的<code>ng add @nguniversal/express-engine</code>这行命令就可以自动帮助我们构建服务端渲染程序。但是我遇到一个问题是之前<code>CSR</code>渲染时<code>router</code>定义的方法是通过<code>routerModule</code>定义注入进<code>AppModule</code>的方式：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [...];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes, &#123; relativeLinkResolution: <span class="string">'legacy'</span> &#125;)],</span><br><span class="line">  exports: [RouterModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppRoutingModule &#123;&#125;</span><br></pre></td></tr></table></figure><p>这样的方式在服务端渲染时并未生效，于是查看了一下文档发现最新文档已经不用这样写了，直接定义<code>routes</code>，然后在<code>AppModule</code>中<code>RouterModule.forRoot(routes,...）</code>注入就可以了！</p>
<h4 id="坑点2">坑点2<a href="#坑点2" title="坑点2"></a></h4><p>由于我的个人项目是使用<code>tailwindcss</code>管理样式，这样在服务端渲染时，加载的时间会特别长，看了一下<code>tailwindcss</code>在本地开发是全量打包进<code>style</code>里的，于是每次加载的时候都会加载这个包，这个包体积很大，tailwind官方有<code>shaking</code>的配置，但建议是在生产环境下再进行<code>shaking</code>，原理也就是通过正则对<code>html</code>分析然后剔除不用的类。于是乎被迫在本地开发的情况开启了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    prefix: <span class="string">''</span>,</span><br><span class="line">    purge: &#123;</span><br><span class="line">      enabled:  <span class="literal">true</span>,</span><br><span class="line">      content: [</span><br><span class="line">        <span class="string">'./src/**/*.&#123;html,ts&#125;'</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="坑点3：重复渲染请求">坑点3：重复渲染/请求<a href="#坑点3：重复渲染请求" title="坑点3：重复渲染/请求"></a></h4><p>基于Angular universal的处理会在服务端渲染以及<code>hydrate</code>后在浏览器再执行一遍<code>render</code>，这个目前看起来不是很理解，官方目前也知道这个问题，于是有处理方案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;TransferHttpCacheModule&#125; <span class="keyword">from</span> <span class="string">'@nguniversal/common'</span>;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/angular/universal/blob/master/docs/transfer-http.md" target="_blank">TransferHttpCacheModule</a></p>
<h5 id="一个issue">一个issue<a href="#一个issue" title="一个issue"></a></h5><p><a href="https://github.com/angular/angular/issues/23427" target="_blank">Angular - TransferState - page is loading twice (flickering) issue</a></p>
<p>主要是<code>import</code>进<code>TransferHttpCacheModule</code>注入至全局Module，这样可以缓存内部<code>httpClientModule</code>发起的<code>http</code>请求，防止重复请求闪屏的出现。</p>
<p>暂时就这些问题，先记录一下。</p>
]]></content>
      <tags>
        <tag>angular</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染过程（长期更）</title>
    <url>/2020/04/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%EF%BC%89/</url>
    <content><![CDATA[<p>最近看到很多面试问到了浏览器渲染的原理方面的问题，感觉自己还不熟悉，就来做个总结。<br></p>
<h4>浏览器的进程与线程</h4>
首先是浏览器的进程与线程：浏览器是多进程的，一个主控进程，同时每一个tab页面都会生成新的进程，Chrome以及新版Edge会有插件进程。
<h5>多线程的浏览器内核</h5>
  每个tab页面可以看做是浏览器内核进程，然后这个进程是多线程的：
  <ul>有以下几类子线程
 <li>GUI线程——就是用户界面进程，渲染用户界面，当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行</li>
 <li>js引擎线程——JavaScript引擎是单线程运行的,浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序.</li>
 <li>事件触发线程</li>
 <li>定时器线程</li>
 <li>网络请求线程</li>
  </ul>
 <h5> 首先看看主要的JavaScript引擎</h5>
   <p>1.  如果JS是多线程的方式来操作这些UI , DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS在最初就选择了单线程执行。</p>
   <p>2.  GUI渲染线程与JS引擎线程互斥的，是由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。由于GUI渲染线程与JS执行线程是互斥的关系，当浏览器在执行JS程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
   <p>在JavaScript引擎运行脚本期间,浏览器渲染线程都是处于挂起状态的,</p><h5>定时触发器线程</h5>
<p>浏览器定时计数器并不是由 JS 引擎计数的, 因为 JS 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p><h5>事件触发线程</h5>
  当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。
  <h5>异步http请求线程</h5>
  在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理。
<h4>浏览器的渲染</h4>
用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。
<ul><p>渲染过程主要有4个步骤</p>
<li><p>解析HTML生成DOM树 - 渲染引擎首先解析HTML文档，生成DOM树</p>
<p>DOM树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。DOM树的根节点就是document对象。<p>DOM 树的生成过程中可能会被 CSS 和 JS 的加载执行阻塞，当 HTML 文档解析过程完毕后，浏览器继续进行标记为 deferred 模式的脚本加载，然后就是整个解析过程的实际结束触发 DOMContentLoaded 事件，并在 async 文档文档执行完之后触发 load 事件。</p></p>
</li>
<li><p>构建Render树 - 接下来不管是内联式，外联式还是嵌入式引入的CSS样式会被解析生成CSSOM树，根据DOM树与CSSOM树生成另外一棵用于渲染的树-渲染树(Render tree)</p>
生成 DOM 树的同时会生成样式结构体 CSSOM（CSS Object Model）Tree，再根据 CSSOM 和 DOM 树构造渲染树 Render Tree，渲染树包含带有颜色，尺寸等显示属性的矩形，这些矩形的顺序与显示顺序基本一致。从 MVC 的角度来说，可以将 Render 树看成是 V，DOM 树与 CSSOM 树看成是 M，C 则是具体的调度者，比 HTMLDocumentParser 等。</li>
<li>布局Render树 - 然后对渲染树的每个节点进行布局处理，确定其在屏幕上的显示位置</li>
<li>绘制Render树 - 最后遍历渲染树并用UI后端层将每一个节点绘制出来</li>
</ul>
<P>下面是一个DOM树和Render树的图</P>
<img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XP4dRIhZqqV6B9SNRbyQflzvDFfqbdft6PdWzFWsOk3Tuznqopfj8IyCJrUgAOic7IagvoZyibnA85MzehD9rgjA/640?wx_fmt=png">
<p>以上步骤是一个渐进的过程，为了提高用户体验，它会在从网络层获取文档内容的同时把已经接收到的局部内容先展示出来。</p>
<h5>布局与绘制</h5>
<p>浏览器进行页面布局基本过程是以浏览器可见区域为画布，左上角为 (0,0)基础坐标，从左到右，从上到下从DOM的根节点开始画，首先确定显示元素的大小跟位置，此过程是通过浏览器计算出来的，用户CSS中定义的量未必就是浏览器实际采用的量。如果显示元素有子元素得先去确定子元素的显示信息。<p>布局阶段输出的结果称为 box 盒模型（width,height,margin,padding,border,left,top,…），盒模型精确表示了每一个元素的位置和大小，并且所有相对度量单位此时都转化为了绝对单位。</p>
<p>在绘制(painting)阶段，渲染引擎会遍历 Render 树，并调用 renderer 的 paint() 方法，将 renderer 的内容显示在屏幕上。绘制工作是使用 UI 后端组件完成的。</p></p>
<h5>回流与重绘</h5>
<p>
回流(reflow)：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。reflow 会从 <html>这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。<p>重绘(repaint)：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重绘，但是元素的几何尺寸没有变。</p>
<p>每次 Reflow，Repaint 后浏览器还需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。Reflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。</p>
</p>
<h5>哪些情况会发生回流</h5>
<ul>
<li>页面第一次加载的时候</li>
<li>改变字体，改变元素尺寸（如果只改变字体颜色，元素背景颜色那么只触发重绘）</li>
<li>改变元素里面内容的时候</li>
<li>添加/删除<strong>可见</strong>DOM元素</li>
<li>fiexd定位的元素，在拖动滚动条的时候会一直发生回流</li>
<li>调整窗口大小的时候</li>
<li>计算offertWidth 和 offsetHeight属性的时候</li>
</ul>
<h5>减少回流和重绘</h5>
<ul>
<li>使用tranform代替top</li>
<li>使用visibility 代替 display:none</li>
<li>避免使用table布局</li>
<li>尽可能在dom树末端改变class</li>
<li>避免设置多层内联样式</li>
<li>将动画应用到position属性为absolute或者fixed的元素上</li>
<li>避免使用CSS表达式</li>
<li>避免频繁的操作dom</li></ul>
<span style="float:right">---2020/4/2</span><h5 id="如何加快首屏加载速度">如何加快首屏加载速度<a href="#如何加快首屏加载速度" title="如何加快首屏加载速度"></a></h5><ul><li>优化文件大小：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度</li>
<li>避免资源下载阻塞文档解析：浏览器解析到<code>&lt;script&gt;</code>标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把<code>&lt;script&gt;</code>标签放在底部，或者加上<code>defer、async</code>来进行异步下载</li>
</ul><h5 id="无阻塞脚本（async和defer）">无阻塞脚本（async和defer）<a href="#无阻塞脚本（async和defer）" title="无阻塞脚本（async和defer）"></a></h5><p> <code>defer</code>由HTML4提出，<code>defer</code> 与相比普通 <code>script</code>，有两点区别：</p>
<ul><li>载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后；</li>
<li>在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载<br><code>async</code>由HTML5提出<br>两者都是采用并行下载javaScript文件，不会产生阻塞。<br>不同点在于：<code>async</code> 在加载完成后自动执行  <code>defer</code>需要等待页面加载完成后执行。<br>下面贴张图解释：<br><img src="/images/script.png" class="φcy" alt="script加载"></li>
</ul>]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染</tag>
        <tag>重绘，回流</tag>
      </tags>
  </entry>
  <entry>
    <title>有关Angular新一代编译引擎Ivy的介绍</title>
    <url>/2021/07/23/%E6%9C%89%E5%85%B3Angular%E6%96%B0%E4%B8%80%E4%BB%A3%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8EIvy%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h4 id="angular">Angular<a href="#angular" title="Angular"></a></h4><p>Angular是目前全球最受欢迎的框架之一，但由于在框架中有许多库以及编译知识需要学习，在国内的使用率并不高。同时由于加载时间长，因为Angular生成的项目文件较大也被<code>React</code>以及<code>Vue</code>更优秀的打包体积以及更好的开发体验所打败。但如果掌握了<code>Angular</code>的原理之后，我们也能开发出与React应用性能所差无几的<code>Web App</code>。而由于之前<code>Angular 8.0</code>版本之前使用的是View Engine编译器来对<code>Angular</code>项目文件进行编译，造成了打包体积较大以及不容易追踪bug。于是<code>Angular</code>团队推出了<code>Ivy</code>编译器。</p>
<h4 id="什么是ivy编译">什么是<code>Ivy</code>编译<a href="#什么是ivy编译" title="什么是Ivy编译"></a></h4><p><code>Ivy</code>是下一代模板编译引擎以及渲染的管道工具，他非常先进，并提供了以前没有的高级功能以及更快的编译速度。实际是<code>Ivy</code>是<code>Angular</code>之前渲染引擎的完全重写，具体来说是第四次重写，使用<code>Ivy</code>可以独立得编译组件，同时对于热更新也支持的更好，在重写编译应用程序时会只涉及编译发生更改的组件。</p>
<h5 id="treeshakable">treeshakable<a href="#treeshakable" title="treeshakable"></a></h5><p>同时<code>Ivy</code>另一个重要的点是对于项目文件的<code>treeshaking</code>，意思是在编译打包过程中删除未使用的代码，这也可以通过一些工具如<code>Rollup</code>以及<code>Uglify</code>来完成。在构建的过程中，<code>treeshaking</code>工具使用静态分析消除未使用以及未引用的代码。由于代码的静态分析依赖与引用，当有条件的逻辑判断代码存在的时候，工具不能正确识别，会出现失败的情况。</p>
<h5 id="局限性">局限性<a href="#局限性" title="局限性"></a></h5><p>局限性指的是在使用本地代码独立的编译每个组件的过程，通过对于修改部分的重编译而不是整个项目文件的重新编译来更快地构建，这会显著的提升构建速度。在之前的<code>Angular</code>代码中，每个组件都存在它的父信息，这就导致了编译依赖，从而编译的文件变多。而在<code>Ivy</code>中，每个组件只会生成关于该组件自身的信息，除去了可申明依赖项的名词和包的名称。</p>
<h5 id="ivy编译样例">Ivy编译样例<a href="#ivy编译样例" title="Ivy编译样例"></a></h5><p>在Angular中尝试编写如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ivy works<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">app-child</span>&gt;</span><span class="tag">&lt;/<span class="name">app-child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>app-child</code>代表一个引用的子组件。通过<code>Ivy</code>编译得到的<code>Ivy.component.js</code>如图</p>
<p><img src="/images/Ivy/code_1.png" class="φcy" alt="code_1.png"><br>而我们再通过在未开启<code>Ivy</code>的条件下进行再一次编译，这一次得到如下的目录结构：<br><img src="/images/Ivy/code_2.png" class="φcy" alt="编译目录.png"></p>
<p>这里挑两个主要的文件<code>ivy.component.js</code>和<code>ivy.component.ngfactory.js</code>来展示<code>View Engine</code>编译后的文件：<br><img src="/images/Ivy/code_3.png" class="φcy" alt="viewEngine-IvyComponent.png"><br><img src="/images/Ivy/code_4.png" class="φcy" alt="viewEngine-IvyFactory.png"><br>可以看到，编译后的文件种类以及代码量相较于<code>Ivy</code>编译都变多了不少。</p>
<h4 id="aot编译和jit编译">AOT编译和JIT编译<a href="#aot编译和jit编译" title="AOT编译和JIT编译"></a></h4><p><code>Angular</code> 应用主要由组件及其 <code>HTML</code> 模板组成。组件是由<code>Typescript</code>语言编写以及使用装饰器定义而成，由于浏览器无法直接理解 <code>Angular</code> 所提供的组件和模板，因此 <code>Angular</code> 应用程序需要先进行编译才能在浏览器中运行。在浏览器下载和运行代码之前的编译阶段，Angular 预先（AOT）编译器会先把你的 Angular HTML 和 TypeScript 代码转换成高效的 JavaScript 代码。 在构建期间编译应用可以让浏览器中的渲染更快速。而在官方文档中给出了使用AOT的部分原因：</p>
<ul><li>更快的渲染</li>
<li>更少的异步请求</li>
<li>较小的 <code>Angular</code> 框架下载大小</li>
<li>尽早检测模板错误</li>
<li>更高的安全性( <code>AOT</code> 在将 <code>HTML</code> 模板和组件提供给客户端之前就将其编译为 <code>JavaScript</code> 文件。没有要读取的模板，没有潜藏风险的客户端 HTML 或 <code>JavaScript eval</code>，受到注入攻击的机会就更少了。)</li>
</ul><p>在早期的<code>Angular8</code>版本之前，<code>Angular</code>并没有采用AOT编译的方法，而是采用了JIT(即时编译)编译来生成应用，它会在运行期间在浏览器中编译你的应用。JIT编的一般步骤是、<br>首先将<code>Typescript</code>代码（包括用户编写的代码，以及<code>Angular</code>框架、<code>Angular</code>编译器代码）编译成<code>JavaScript</code>代码。接着将这些代码部署到服务器端然后浏览器发起请求下载代码开始执行，接着Angular启动，Angular调用Angular编译器。对于每个组件类、ngModule、Pipe等都需要编译，之前<code>typescript</code>代码编译为<code>javascript</code>代码所保存的<code>metadata</code>，根据<code>metadata</code>编译出浏览器可以执行的<code>Javascript</code>代码前面图里的<code>NgFactory</code>文件。接着通过<code>NgFactories</code>文件来构建整个应用的具体组件。</p>
<p>这里有对AOT与JIT编译详解的文章：<a href="https://segmentfault.com/a/1190000011562077" target="_blank">Angular编译机制AOT和JIT</a></p>
<h4 id="开启ivy编译">开启Ivy编译<a href="#开启ivy编译" title="开启Ivy编译"></a></h4><p>Ivy编译默认采用的是<code>AOT</code>编译方法，在之前<code>angular</code>主要使用的都是JIT编译，如果需要使用Ivy编译，需要修改<code>tsconfig.app.ts</code>中添加<code>angularCompilerOptions</code>选项以及开启<code>enableIvy</code>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"compilerOptions"</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="string">"angularCompilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"enableIvy"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次要确认的是<code>angular</code>配置文件<code>angular.json</code>中<code>aot</code>设置为<code>true</code>。</p>
<h4 id="ivy运行时">Ivy运行时<a href="#ivy运行时" title="Ivy运行时"></a></h4><p>新的运行时引擎基于<strong><strong>increnmental DOM</strong></strong>的概念。这是一种使用指令表达和应用更新到 DOM 树的方法。DOM 更新是 <code>Angular</code> 中变化检测的主要部分，因此这个概念可以方便地应用到框架中。<a href="https://medium.com/google-developers/introducing-incremental-dom-e98f79ce2c5f" target="_blank">在在这篇文章中</a>可以了解更多关于它<a href="https://medium.com/google-developers/introducing-incremental-dom-e98f79ce2c5f" target="_blank">的内容</a>，它解释了这个概念背后的推理，并将它与React 中的<strong><strong>Virtual DOM</strong></strong>进行了对比。增量 DOM 也恰好是一个<a href="https://github.com/google/incremental-dom" target="_blank">库</a>，但是新的 Ivy 引擎没有使用它，而是实现了自己的增量DOM版本。</p>
<p>在之前<code>Angular</code>的主要实现逻辑是实例化组件、创建DOM节点以及进行更改检测，而这个整体是通过一个很小的原子单元实现的(atomic unit)。编译器只是生成有关的组件以及组件中定义元素的元数据<code>meta data</code>。如下图</p>
<p><img src="/images/Ivy/render_pipeline.png" class="φcy" alt="image.png"></p>
<p>而新的<code>Ivy</code>引擎下的步骤如下：<br><img src="/images/Ivy/Ivy.png" class="φcy" alt="image.png"><br>可与看出模板指令是实例化组件、创建 DOM 节点和运行变更检测的逻辑所在。但是它已经从整体的解释器转移到了单个的指令中。而<code>Ivy</code>带来的另一个优点是对于变更检测(change detection)的调试。新的<code>Ivy</code>编译环境下可以直接在模板函数中放置断点即可调试组件的变更检测。</p>
<p>新的编译器还会将一组独立的<code>Typescript类转换</code>编译为表示<code>Class组件</code>的的AST。这些转换都会被实现为一种<strong>纯函数</strong>，这个函数接受表示装饰器的<code>元数据meta data</code>并将该定义作为静态字段添加到组件类中。</p>
<p>以上便是关于<code>Ivy</code>编译引擎的介绍，而新的<code>Ivy</code>对于原来的变更检测也会带来变化，这个在下次关于变更检测的文章中进行总结。</p>
<p>参考文章：</p>
<ul><li><a href="https://indepth.dev/posts/1062/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection" target="_blank">Angular 中的 Ivy 引擎：首次深入了解编译、运行时和更改检测</a></li>
<li><a href="https://www.angularminds.com/blog/article/what-is-angular-ivy.html" target="_blank">5分钟了解Ivy</a><ul><li><a href="https://blog.lacolaco.net/2021/02/angular-ivy-library-compilation-design-in-depth-en/" target="_blank">Understanding Angular Ivy Library Compilation</a></li>
<li><a href="https://www.youtube.com/watch?v=qWmqiYDrnDc" target="_blank">Renderer and ViewContainerRef over directly manipulating the DOM</a></li>
<li><a href="https://www.youtube.com/watch?v=nbeQdMGtIcU" target="_blank">Eliran Eliassy — Get ready for Ivy — Angular 3rd generation renderer engine</a><br>强烈推荐<strong><em>Eliassy</em></strong>大佬对于<code>Ivy</code>的介绍，以及展示了调试Angular应用的黑科技！</li>
</ul></li>
</ul><iframe width="560" height="315" src="https://www.youtube.com/embed/nbeQdMGtIcU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
  </entry>
  <entry>
    <title>高级排序</title>
    <url>/2020/03/27/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4> 希尔排序 </h4>
<p>希尔排序的工作原理是，通过定义一个间隔序列来表示在排序过程中进行比较的元素之
间有多远的间隔。我们可以动态定义间隔序列，不过对于大部分的实际应用场景，算法
要用到的间隔序列可以提前定义好。有一些公开定义的间隔序列，使用它们会得到不同
的结果。在这里我们用到了 Marcin Ciura 在他 2001 年发表的论文“Best Increments for the
Average Case of Shell Sort”（http:bit.ly/1b04YFv,2001）中定义的间隔序列。这个间隔序列
是：701, 301, 132, 57, 23, 10, 4, 1。</p>
<h5>首先是希尔排序的js写法</h5>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">123</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">66</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">43</span>,<span class="number">52</span>,<span class="number">45</span>,<span class="number">47</span>,<span class="number">48</span>]</span><br><span class="line"><span class="keyword">var</span> gaps=[<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr,gaps</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> g=<span class="number">0</span>;g &lt; gaps.length; ++g)&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; arr.length ; ++i)&#123;</span><br><span class="line">      <span class="keyword">var</span> temp = arr[i]</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j=i; j &gt;= gaps[g] &amp;&amp; arr[j-gaps[g]] &gt; temp ; j-=gaps[g])&#123;</span><br><span class="line">        arr[j]=arr[j-gaps[g]]</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j]=temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>实际就是:</h5>
<p>外循环控制间隔序列的移动。也就是说，算法在第一次处理数据集时，会检查所有间隔为
5 的元素。下一次遍历会检查所有间隔为 3 的元素。最后一次则会对间隔为 1 的元素，也
就是相邻元素执行标准插入排序。在开始做最后一次处理时，大部分元素都将在正确的位
置，算法就不必对很多元素进行交换。这就是希尔排序比插入排序更高效的地方。图 12-3
演示了如何使用间隔序列为 5, 3, 1 的希尔排序算法，对一个包含 10 个随机数字的数据集
合进行排序。
</p>
原理图如下：
<img src="/images/希尔排序原理.png"></img>
<h5>计算动态间隔序列</h5><p>《算法（第 4 版）》（人民邮电出版社）的合著者 Robert Sedgewick 定义了一个 shellsort()
函数，在这个函数中可以通过一个公式来对希尔排序用到的间隔序列进行动态计算。
Sedgewick 的算法是通过下面的代码片段来决定初始间隔值的：
</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> N = <span class="keyword">this</span>.dataStore.length</span><br><span class="line"><span class="keyword">var</span> h = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">  h = <span class="number">3</span> * h + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>间隔值确定好后，这个函数就可以像之前定义的 shellsort() 函数一样运行了，唯一的区
别是，回到外循环之前的最后一条语句会计算一个新的间隔值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">h = <span class="number">3</span> * h + <span class="number">1</span></span><br></pre></td></tr></table></figure><h6>举例如下:</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> N = arr.length;</span><br><span class="line"><span class="keyword">var</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(h&lt;N/<span class="number">3</span>)&#123;</span><br><span class="line">h = h \* <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=h;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j &gt; = h &amp;&amp; arr[j] &lt; arr[j-h];j-=h)&#123;</span><br><span class="line"><span class="keyword">var</span> temp = arr[j-h]</span><br><span class="line">arr[j-h]=arr[j]</span><br><span class="line">arr[j] = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">h=(h<span class="number">-1</span>)/<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运算时间上，前后两个算法相差一个 while()循环来取 gaps[]值，前者设定了[5,3,1],后者通过计算得到 gaps 数组。</p>
<h4>快速排序</h4>
快速排序是处理大数据集最快的排序算法之一，它是一种分而治之的算法，通过递归的方式将数据分解为包含较小元素和较大元素的不同子序列
这个算法首先要在列表中选择一个元素作为基准值（pivot）。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。
如图所示：
<img src="/images/快速排序.jpg"></img><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">var</span> left = []</span><br><span class="line">  <span class="keyword">var</span> right = []</span><br><span class="line">  <span class="keyword">var</span> pivot = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//此处留意i=1</span></span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> QuickSort(left).concat(pivot, QuickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下获取每次循环的输出，解释了快速排序的运行原理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>,<span class="number">3</span>,<span class="number">93</span>,<span class="number">9</span>,<span class="number">65</span>,<span class="number">94</span>,<span class="number">50</span>,<span class="number">90</span>,<span class="number">12</span>,<span class="number">65</span></span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">3</span></span><br><span class="line">移动 <span class="number">3</span> 到左边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">93</span></span><br><span class="line">移动 <span class="number">93</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">9</span></span><br><span class="line">移动 <span class="number">9</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">65</span></span><br><span class="line">移动 <span class="number">65</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">94</span></span><br><span class="line">移动 <span class="number">94</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">50</span></span><br><span class="line">移动 <span class="number">50</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">90</span></span><br><span class="line">移动 <span class="number">90</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">12</span></span><br><span class="line">移动 <span class="number">12</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">65</span></span><br><span class="line">移动 <span class="number">65</span> 到右边</span><br><span class="line">基准值：<span class="number">93</span> 当前元素：<span class="number">9</span></span><br><span class="line">移动 <span class="number">9</span> 到左边</span><br><span class="line">基准值：<span class="number">93</span> 当前元素：<span class="number">65</span></span><br><span class="line">移动 <span class="number">65</span> 到左边</span><br><span class="line">基准值：<span class="number">93</span> 当前元素：<span class="number">94</span></span><br><span class="line">移动 <span class="number">94</span> 到右边</span><br><span class="line">基准值：<span class="number">93</span> 当前元素：<span class="number">50</span></span><br><span class="line">移动 <span class="number">50</span> 到左边</span><br><span class="line">基准值：<span class="number">93</span> 当前元素：<span class="number">90</span></span><br><span class="line">移动 <span class="number">90</span> 到左边</span><br><span class="line">基准值：<span class="number">93</span> 当前元素：<span class="number">12</span></span><br><span class="line">移动 <span class="number">12</span> 到左边</span><br><span class="line">基准值：<span class="number">93</span> 当前元素：<span class="number">65</span></span><br><span class="line">移动 <span class="number">65</span> 到左边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">65</span></span><br><span class="line">移动 <span class="number">65</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">50</span></span><br><span class="line">移动 <span class="number">50</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">90</span></span><br><span class="line">移动 <span class="number">90</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">12</span></span><br><span class="line">移动 <span class="number">12</span> 到右边</span><br><span class="line">基准值：<span class="number">9</span> 当前元素：<span class="number">65</span></span><br><span class="line">移动 <span class="number">65</span> 到右边</span><br><span class="line">基准值：<span class="number">65</span> 当前元素：<span class="number">50</span></span><br><span class="line">移动 <span class="number">50</span> 到左边</span><br><span class="line">基准值：<span class="number">65</span> 当前元素：<span class="number">90</span></span><br><span class="line">移动 <span class="number">90</span> 到右边</span><br><span class="line">排序算法 ｜ <span class="number">167</span></span><br><span class="line">基准值：<span class="number">65</span> 当前元素：<span class="number">12</span></span><br><span class="line">移动 <span class="number">12</span> 到左边</span><br><span class="line">基准值：<span class="number">65</span> 当前元素：<span class="number">65</span></span><br><span class="line">移动 <span class="number">65</span> 到右边</span><br><span class="line">基准值：<span class="number">50</span> 当前元素：<span class="number">12</span></span><br><span class="line">移动 <span class="number">12</span> 到左边</span><br><span class="line">基准值：<span class="number">90</span> 当前元素：<span class="number">65</span></span><br><span class="line">移动 <span class="number">65</span> 到左边</span><br><span class="line"><span class="number">3</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">50</span>,<span class="number">65</span>,<span class="number">65</span>,<span class="number">90</span>,<span class="number">93</span>,<span class="number">94</span></span><br></pre></td></tr></table></figure><p>本次文章到此结束</p>
]]></content>
      <tags>
        <tag>高级排序</tag>
        <tag>希尔排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
</search>
