{"title":"前端项目服务端渲染（SSR）","date":"2021-02-15T22:23:00.000Z","date_formatted":{"ll":"Feb 15, 2021","L":"02/15/2021","MM-DD":"02-15"},"link":"2021/02/15/前端项目服务端渲染（SSR）","tags":["SSR","前端"],"categories":["前端"],"updated":"2022-01-22T09:45:40.643Z","content":"<h3 id=\"名词解释\">名词解释<a title=\"#名词解释\" href=\"#名词解释\"></a></h3>\n<h4 id=\"ssr\">SSR<a title=\"#ssr\" href=\"#ssr\"></a></h4>\n<ul>\n<li>SSR：服务器端渲染-将客户端或通用应用程序渲染到服务器上的HTML。</li>\n</ul>\n<h4 id=\"csr\">CSR<a title=\"#csr\" href=\"#csr\"></a></h4>\n<ul>\n<li>CSR：客户端渲染-通常使用DOM在浏览器中渲染应用程序。</li>\n</ul>\n<h4 id=\"rehydration\">Rehydration<a title=\"#rehydration\" href=\"#rehydration\"></a></h4>\n<ul>\n<li>Rehydration： “启动”客户端上的JavaScript视图，以便它们重用服务器渲染的HTML的DOM树和数据。</li>\n</ul>\n<h4 id=\"prerendering\">Prerendering<a title=\"#prerendering\" href=\"#prerendering\"></a></h4>\n<ul>\n<li>Prerendering：在构建时运行客户端应用程序以将其初始状态捕获为静态HTML。</li>\n</ul>\n<h4 id=\"ttfb\">TTFB<a title=\"#ttfb\" href=\"#ttfb\"></a></h4>\n<ul>\n<li>TTFB： 到第一个字节的时间-视为单击链接到输入内容的第一位之间的时间。</li>\n</ul>\n<h4 id=\"fp\">FP<a title=\"#fp\" href=\"#fp\"></a></h4>\n<ul>\n<li>FP： First Paint-第一次获取任何像素对用户可见。</li>\n</ul>\n<h4 id=\"fcp\">FCP<a title=\"#fcp\" href=\"#fcp\"></a></h4>\n<ul>\n<li>FCP： 第一个内容丰富的油漆-所请求的内容（文章主体等）可见的时间。</li>\n</ul>\n<h4 id=\"tti\">TTI<a title=\"#tti\" href=\"#tti\"></a></h4>\n<ul>\n<li>TTI： 互动时间-页面互动的时间（事件连线等）。</li>\n</ul>\n<h3 id=\"前端渲染介绍\">前端渲染介绍<a title=\"#前端渲染介绍\" href=\"#前端渲染介绍\"></a></h3>\n<h4 id=\"csr客户端渲染\">CSR客户端渲染<a title=\"#csr客户端渲染\" href=\"#csr客户端渲染\"></a></h4>\n<p>今天介绍的是服务端渲染（Server-side Rendering）,简称为SSR。<br>\n首先介绍一下常见的web渲染模式，第一个是目前前后端分离的主要开发模式，也是大多数前端同学的开发方式，就是客户端渲染（Client-side Rendering）。目前的三大框架Angular,React,Vue都是基于CSR开发的框架，我们在开发时只需要和后端同学，提前约定好接口，接着前端页面由我们前端同学开发构建，在需要页面刷新的地方，可以使用Ajax技术进行局部刷新。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">CSR</span> (<span class=\"title class_\">Client</span>-<span class=\"title class_\">Side</span> <span class=\"title class_\">Rendering</span>) – rendering an app <span class=\"keyword\">in</span> a browser, generally using the <span class=\"variable constant_\">DOM</span>.</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/CSR%E6%B8%B2%E6%9F%93.png\" alt=\"CSR渲染\" title=\"CSR渲染图\" loading=\"lazy\"><br>\n上图是Google大会上贴出的介绍CSR的一张原理图，net代表网络请求，请求js文件“bundle.js”,此时是FCP时间点，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FCP：First Contentful Paint - the time when requested content (article body, etc) becomes visible.</span><br></pre></td></tr></table></figure>\n<p>翻译过来就是：第一个内容丰富的渲染-所请求的内容（文章主体等）可见的时间。接下来由我们的js引擎以及浏览器渲染引擎渲染更多的页面内容。渲染完毕后又到了一个时间点：TTI。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTI: Time To Interactive - the time at which a page becomes interactive (events wired up, etc)</span><br></pre></td></tr></table></figure>\n<p>翻译过来就是：“互动时间-页面互动的时间（事件被整理等”,也就是用户第一次可以与页面交互的时间点。而从FCP到TTI需要花费的时间则是由我们前端打包的js文件大小决定。这其中包含了我们的业务代码，同时又有第三方库的部分代码。对于性能较差的机器，也就花费时间更长。在google大会上提到的有利用HTTP/2 Server Push或者<code>&lt;link rel=preload&gt;</code>加载数据，可以提升性能，而在我们前端开发中还可以使用懒加载，webpack的treeshaking等等减少js文件大小来减少渲染时长。同时由于目前的前端框架大多开发的是单页面应用SPA（single page Application）,如果js文件较大，则首屏加载会变慢，影响用户体验。让我换个思路，改变渲染模式，想想会有什么效果。</p>\n<h4 id=\"ssr服务端渲染\">SSR服务端渲染<a title=\"#ssr服务端渲染\" href=\"#ssr服务端渲染\"></a></h4>\n<p>服务器呈现响应于导航生成服务器上页面的完整HTML。这样可以避免客户端进行数据获取和模板化的其他往返过程，因为它是在浏览器获得响应之前进行处理的。服务器渲染通常会产生快速的First Paint  （FP）和First Contentful Paint  （FCP）。在服务器上运行页面逻辑和呈现可以避免向客户端发送大量JavaScript，这有助于实现快速的交互时间 （TTI）。这是有道理的，因为使用服务器渲染，您实际上只是将文本和链接发送到用户的浏览器。这种方法可以在很大范围的设备和网络条件下很好地工作，并且可以带来有趣的浏览器优化，例如流文档解析。SSR渲染过程大致如下图所示：</p>\n<p><img src=\"/images/SSR%E6%B8%B2%E6%9F%93.png\" alt=\"CSR渲染\" title=\"CSR渲染图\" loading=\"lazy\"><br>\n通过服务器渲染，用户不太可能会等待CPU绑定的JavaScript处理才能使用您的网站。即使 无法避免使用第三方JS，使用服务器渲染来减少自己的第一方JS成本也可以为您提供更多的“预算”。但是，此方法有一个主要缺点：在服务器上生成页面会花费时间，这通常会导致首字节时间 （TTFB）变慢。</p>\n<p>服务器渲染的动态特性可能会带来可观的计算开销。许多服务器渲染解决方案不会提早刷新，可能会延迟TTFB或将发送的数据加倍（例如，客户端JS使用的内联状态）。在<code>React</code>中，<code>renderToString()</code>可能很慢，因为它是同步的并且是单线程的。要使服务器呈现“正确”状态，可能涉及寻找或构建组件缓存解决方案，管理内存消耗，应用备忘录技术以及许多其他问题。通常，您要多次处理/重建同一应用程序-一次在客户端，一次在服务器。仅仅因为服务器渲染可以使某些事情更快地出现，并不意味着您要做的工作更少。</p>\n<p>服务器渲染会为每个<code>URL</code>按需生成<code>HTML</code>，但比仅提供静态渲染内容要慢。如果您可以进行其他工作，则服务器渲染+ HTML缓存可以大大减少服务器渲染时间。服务器渲染的优势在于，与静态渲染相比，它能够提取更多的“实时”数据并响应更完整的请求集。需要个性化的页面是请求类型的一个具体示例，无法与静态渲染一起很好地工作。</p>\n<h3 id=\"参考链接\">参考链接<a title=\"#参考链接\" href=\"#参考链接\"></a></h3>\n<p><a href=\"https://developers.google.com/web/updates/2019/02/rendering-on-the-web#server-vs-static\" target=\"_blank\">Google开发者大会对于前端渲染的介绍</a></p>\n","prev":{"title":"Typescript相关","link":"2021/02/21/Typescript相关"},"next":{"title":"Rust学习小记录","link":"2020/10/03/Rust学习小记录"},"plink":"https://edsion11.github.io/2021/02/15/前端项目服务端渲染（SSR）/","toc":[{"id":"名词解释","title":"名词解释","index":"1","children":[{"id":"ssr","title":"SSR","index":"1.1"},{"id":"csr","title":"CSR","index":"1.2"},{"id":"rehydration","title":"Rehydration","index":"1.3"},{"id":"prerendering","title":"Prerendering","index":"1.4"},{"id":"ttfb","title":"TTFB","index":"1.5"},{"id":"fp","title":"FP","index":"1.6"},{"id":"fcp","title":"FCP","index":"1.7"},{"id":"tti","title":"TTI","index":"1.8"}]},{"id":"前端渲染介绍","title":"前端渲染介绍","index":"2","children":[{"id":"csr客户端渲染","title":"CSR客户端渲染","index":"2.1"},{"id":"ssr服务端渲染","title":"SSR服务端渲染","index":"2.2"}]},{"id":"参考链接","title":"参考链接","index":"3"}],"copyright":{"author":"Edsion Gu","link":"<a href=\"https://edsion11.github.io/2021/02/15/前端项目服务端渲染（SSR）/\" title=\"前端项目服务端渲染（SSR）\">https://edsion11.github.io/2021/02/15/前端项目服务端渲染（SSR）/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}