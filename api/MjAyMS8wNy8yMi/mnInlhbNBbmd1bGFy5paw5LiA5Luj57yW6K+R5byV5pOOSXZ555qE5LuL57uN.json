{"title":"有关Angular新一代编译引擎Ivy的介绍","date":"2021-07-22T23:43:37.000Z","date_formatted":{"ll":"Jul 22, 2021","L":"07/22/2021","MM-DD":"07-22"},"link":"2021/07/22/有关Angular新一代编译引擎Ivy的介绍","categories":["前端"],"updated":"2023-10-16T08:07:13.962Z","content":"<h4 id=\"angular\">Angular<a title=\"#angular\" href=\"#angular\"></a></h4>\n<p>Angular是目前全球最受欢迎的框架之一，但由于在框架中有许多库以及编译知识需要学习，在国内的使用率并不高。同时由于加载时间长，因为Angular生成的项目文件较大也被<code>React</code>以及<code>Vue</code>更优秀的打包体积以及更好的开发体验所打败。但如果掌握了<code>Angular</code>的原理之后，我们也能开发出与React应用性能所差无几的<code>Web App</code>。而由于之前<code>Angular 8.0</code>版本之前使用的是View Engine编译器来对<code>Angular</code>项目文件进行编译，造成了打包体积较大以及不容易追踪bug。于是<code>Angular</code>团队推出了<code>Ivy</code>编译器。</p>\n<h4 id=\"什么是ivy编译\">什么是<code>Ivy</code>编译<a title=\"#什么是ivy编译\" href=\"#什么是ivy编译\"></a></h4>\n<p><code>Ivy</code>是下一代模板编译引擎以及渲染的管道工具，他非常先进，并提供了以前没有的高级功能以及更快的编译速度。实际是<code>Ivy</code>是<code>Angular</code>之前渲染引擎的完全重写，具体来说是第四次重写，使用<code>Ivy</code>可以独立得编译组件，同时对于热更新也支持的更好，在重写编译应用程序时会只涉及编译发生更改的组件。</p>\n<h5 id=\"treeshakable\">treeshakable<a title=\"#treeshakable\" href=\"#treeshakable\"></a></h5>\n<p>同时<code>Ivy</code>另一个重要的点是对于项目文件的<code>treeshaking</code>，意思是在编译打包过程中删除未使用的代码，这也可以通过一些工具如<code>Rollup</code>以及<code>Uglify</code>来完成。在构建的过程中，<code>treeshaking</code>工具使用静态分析消除未使用以及未引用的代码。由于代码的静态分析依赖与引用，当有条件的逻辑判断代码存在的时候，工具不能正确识别，会出现失败的情况。</p>\n<h5 id=\"局限性\">局限性<a title=\"#局限性\" href=\"#局限性\"></a></h5>\n<p>局限性指的是在使用本地代码独立的编译每个组件的过程，通过对于修改部分的重编译而不是整个项目文件的重新编译来更快地构建，这会显著的提升构建速度。在之前的<code>Angular</code>代码中，每个组件都存在它的父信息，这就导致了编译依赖，从而编译的文件变多。而在<code>Ivy</code>中，每个组件只会生成关于该组件自身的信息，除去了可申明依赖项的名词和包的名称。</p>\n<h5 id=\"ivy编译样例\">Ivy编译样例<a title=\"#ivy编译样例\" href=\"#ivy编译样例\"></a></h5>\n<p>在Angular中尝试编写如下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>ivy works<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">app-child</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">app-child</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里的<code>app-child</code>代表一个引用的子组件。通过<code>Ivy</code>编译得到的<code>Ivy.component.js</code>如图</p>\n<p><img src=\"/images/Ivy/code_1.png\" alt=\"code_1.png\" loading=\"lazy\"><br>\n而我们再通过在未开启<code>Ivy</code>的条件下进行再一次编译，这一次得到如下的目录结构：<br>\n<img src=\"/images/Ivy/code_2.png\" alt=\"编译目录.png\" loading=\"lazy\"></p>\n<p>这里挑两个主要的文件<code>ivy.component.js</code>和<code>ivy.component.ngfactory.js</code>来展示<code>View Engine</code>编译后的文件：<br>\n<img src=\"/images/Ivy/code_3.png\" alt=\"viewEngine-IvyComponent.png\" loading=\"lazy\"><br>\n<img src=\"/images/Ivy/code_4.png\" alt=\"viewEngine-IvyFactory.png\" loading=\"lazy\"><br>\n可以看到，编译后的文件种类以及代码量相较于<code>Ivy</code>编译都变多了不少。</p>\n<h4 id=\"aot编译和jit编译\">AOT编译和JIT编译<a title=\"#aot编译和jit编译\" href=\"#aot编译和jit编译\"></a></h4>\n<p><code>Angular</code> 应用主要由组件及其 <code>HTML</code> 模板组成。组件是由<code>Typescript</code>语言编写以及使用装饰器定义而成，由于浏览器无法直接理解 <code>Angular</code> 所提供的组件和模板，因此 <code>Angular</code> 应用程序需要先进行编译才能在浏览器中运行。在浏览器下载和运行代码之前的编译阶段，Angular 预先（AOT）编译器会先把你的 Angular HTML 和 TypeScript 代码转换成高效的 JavaScript 代码。 在构建期间编译应用可以让浏览器中的渲染更快速。而在官方文档中给出了使用AOT的部分原因：</p>\n<ul>\n<li>更快的渲染</li>\n<li>更少的异步请求</li>\n<li>较小的 <code>Angular</code> 框架下载大小</li>\n<li>尽早检测模板错误</li>\n<li>更高的安全性( <code>AOT</code> 在将 <code>HTML</code> 模板和组件提供给客户端之前就将其编译为 <code>JavaScript</code> 文件。没有要读取的模板，没有潜藏风险的客户端 HTML 或 <code>JavaScript eval</code>，受到注入攻击的机会就更少了。)</li>\n</ul>\n<p>在早期的<code>Angular8</code>版本之前，<code>Angular</code>并没有采用AOT编译的方法，而是采用了JIT(即时编译)编译来生成应用，它会在运行期间在浏览器中编译你的应用。JIT编的一般步骤是、<br>\n首先将<code>Typescript</code>代码（包括用户编写的代码，以及<code>Angular</code>框架、<code>Angular</code>编译器代码）编译成<code>JavaScript</code>代码。接着将这些代码部署到服务器端然后浏览器发起请求下载代码开始执行，接着Angular启动，Angular调用Angular编译器。对于每个组件类、ngModule、Pipe等都需要编译，之前<code>typescript</code>代码编译为<code>javascript</code>代码所保存的<code>metadata</code>，根据<code>metadata</code>编译出浏览器可以执行的<code>Javascript</code>代码前面图里的<code>NgFactory</code>文件。接着通过<code>NgFactories</code>文件来构建整个应用的具体组件。</p>\n<p>这里有对AOT与JIT编译详解的文章：<a href=\"https://segmentfault.com/a/1190000011562077\" target=\"_blank\">Angular编译机制AOT和JIT</a></p>\n<h4 id=\"开启ivy编译\">开启Ivy编译<a title=\"#开启ivy编译\" href=\"#开启ivy编译\"></a></h4>\n<p>Ivy编译默认采用的是<code>AOT</code>编译方法，在之前<code>angular</code>主要使用的都是JIT编译，如果需要使用Ivy编译，需要修改<code>tsconfig.app.ts</code>中添加<code>angularCompilerOptions</code>选项以及开启<code>enableIvy</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123; ... &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;angularCompilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;enableIvy&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其次要确认的是<code>angular</code>配置文件<code>angular.json</code>中<code>aot</code>设置为<code>true</code>。</p>\n<h4 id=\"ivy运行时\">Ivy运行时<a title=\"#ivy运行时\" href=\"#ivy运行时\"></a></h4>\n<p>新的运行时引擎基于<strong><strong>increnmental DOM</strong></strong>的概念。这是一种使用指令表达和应用更新到 DOM 树的方法。DOM 更新是 <code>Angular</code> 中变化检测的主要部分，因此这个概念可以方便地应用到框架中。<a href=\"https://medium.com/google-developers/introducing-incremental-dom-e98f79ce2c5f\" target=\"_blank\">在在这篇文章中</a>可以了解更多关于它<a href=\"https://medium.com/google-developers/introducing-incremental-dom-e98f79ce2c5f\" target=\"_blank\">的内容</a>，它解释了这个概念背后的推理，并将它与React 中的<strong><strong>Virtual DOM</strong></strong>进行了对比。增量 DOM 也恰好是一个<a href=\"https://github.com/google/incremental-dom\" target=\"_blank\">库</a>，但是新的 Ivy 引擎没有使用它，而是实现了自己的增量DOM版本。</p>\n<p>在之前<code>Angular</code>的主要实现逻辑是实例化组件、创建DOM节点以及进行更改检测，而这个整体是通过一个很小的原子单元实现的(atomic unit)。编译器只是生成有关的组件以及组件中定义元素的元数据<code>meta data</code>。如下图</p>\n<p><img src=\"/images/Ivy/render_pipeline.png\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>而新的<code>Ivy</code>引擎下的步骤如下：<br>\n<img src=\"/images/Ivy/Ivy.png\" alt=\"image.png\" loading=\"lazy\"><br>\n可与看出模板指令是实例化组件、创建 DOM 节点和运行变更检测的逻辑所在。但是它已经从整体的解释器转移到了单个的指令中。而<code>Ivy</code>带来的另一个优点是对于变更检测(change detection)的调试。新的<code>Ivy</code>编译环境下可以直接在模板函数中放置断点即可调试组件的变更检测。</p>\n<p>新的编译器还会将一组独立的<code>Typescript类转换</code>编译为表示<code>Class组件</code>的的AST。这些转换都会被实现为一种<strong>纯函数</strong>，这个函数接受表示装饰器的<code>元数据meta data</code>并将该定义作为静态字段添加到组件类中。</p>\n<p>以上便是关于<code>Ivy</code>编译引擎的介绍，而新的<code>Ivy</code>对于原来的变更检测也会带来变化，这个在下次关于变更检测的文章中进行总结。</p>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://indepth.dev/posts/1062/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection\" target=\"_blank\">Angular 中的 Ivy 引擎：首次深入了解编译、运行时和更改检测</a></li>\n<li><a href=\"https://www.angularminds.com/blog/article/what-is-angular-ivy.html\" target=\"_blank\">5分钟了解Ivy</a></li>\n<li><a href=\"https://blog.lacolaco.net/2021/02/angular-ivy-library-compilation-design-in-depth-en/\" target=\"_blank\">Understanding Angular Ivy Library Compilation</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=qWmqiYDrnDc\" target=\"_blank\">Renderer and ViewContainerRef over directly manipulating the DOM</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=nbeQdMGtIcU\" target=\"_blank\">Eliran Eliassy — Get ready for Ivy — Angular 3rd generation renderer engine</a><br>\n强烈推荐<em><strong>Eliassy</strong></em>大佬对于<code>Ivy</code>的介绍，以及展示了调试Angular应用的黑科技！</li>\n</ul>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nbeQdMGtIcU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","prev":{"title":"使用Angular Universal做ssr渲染","link":"2021/12/12/使用angular-universal做ssr渲染"},"next":{"title":"Typescript相关","link":"2021/02/21/Typescript相关"},"plink":"https://edsion11.github.io/2021/07/22/有关Angular新一代编译引擎Ivy的介绍/","toc":[{"id":"angular","title":"Angular","index":"1"},{"id":"什么是ivy编译","title":"什么是Ivy编译","index":"2"},{"id":"aot编译和jit编译","title":"AOT编译和JIT编译","index":"3"},{"id":"开启ivy编译","title":"开启Ivy编译","index":"4"},{"id":"ivy运行时","title":"Ivy运行时","index":"5"}]}