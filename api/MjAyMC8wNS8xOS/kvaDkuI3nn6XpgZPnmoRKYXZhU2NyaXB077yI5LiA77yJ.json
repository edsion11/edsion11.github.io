{"title":"你不知道的JavaScript（一）","date":"2020-05-19T21:19:59.000Z","date_formatted":{"ll":"May 19, 2020","L":"05/19/2020","MM-DD":"05-19"},"link":"2020/05/19/你不知道的JavaScript（一）","tags":["作用域","闭包"],"updated":"2022-01-22T09:45:40.643Z","content":"<h4 id=\"11-编译原理\">1.1 编译原理<a href=\"#11-编译原理\" title=\"1.1 编译原理\"></a></h4><ul><li><p>分词/词法分析<br>这个过程是将由字符组成的字符串分解成有意义的代码块<br>例如 <code>var x = 2</code>分解为<code>var</code> ,<code>x</code>,<code>=</code> ,<code>2</code>,一个个的字符。<br>分词和词法分析主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。</p>\n</li>\n<li><p>解析/语法分析<br>这个过程主要是将词法单元转换成一个由元素逐级嵌套组成的代表程序语法结构的树<br>这个树叫做抽象语法树（AST）✔</p>\n</li>\n<li><p>代码生成<br>将上面生成的语法树解析为可执行代码的过程称为代码生成<br>而 JavaScript 引擎要比上面复杂，JavaScript 是解释型语言，会存在性能问题，不过 Google 的 V8 引擎已经优化了很多，接近 C++/C 等语言了</p>\n</li>\n</ul><h4 id=\"12-作用域\">1.2 作用域<a href=\"#12-作用域\" title=\"1.2 作用域\"></a></h4><p>简洁的来说就是代码可被访问到的区域</p>\n<p>比如声明<code>var x = 2</code>,用一段代码说明</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//global</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">//指向空对象null，global是顶层作用域</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">//指向global，指向上一层func1定义时所在的作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">123</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">//这里是for循环的作用域</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">//ReferenceError: i is not defined，这里访问不到let定义的块作用域，又称作用域死区</span></span><br><span class=\"line\">  func2()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1()</span><br></pre></td></tr></table></figure><h4 id=\"编译器（关于变量声明）\">编译器（关于变量声明）<a href=\"#编译器（关于变量声明）\" title=\"编译器（关于变量声明）\"></a></h4><p>这里有 LHS 和 RHS 查询，即左值查询与右值查询（右值在 C 语言是一个专业术语）这里不过多解释<br>。这里 LHS 和 RHS 查询分别是对等号左右的值进行查询，例如<code>var x = 2</code>，编译器编译到这里会对 x 进 console.log(b)行 LHS 查询，如果在当前作用域没有查到，就会向上一层作用域继续查询，目的是为 2 找到一个赋值的目标，而<code>console.log(b)</code>则会进行 RHS 查询，目的是对<code>console.log()</code>引用地址的查询，找到 b 是谁，或者说在哪。如果 RHS 在所有的作用域中都没有找到所需要的变量，会抛出异常，是 ReferenceERROR 错误，引用错误。但是 LHS 如果在顶层作用域中也没找到变量时，则会创建一个该变量。（严格模式中会直接和 RHS 一样抛出错误）<br>这里有一个隐式说明要注意：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">foo</span><span class=\"params\">(a)</span></span>&#123;</span><br><span class=\"line\">  console.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure><p><img src=\"/images/LHS和RHS.jpg\" class=\"φcy\" alt=\"这里有个例子\"><br>上面代码片段会有一次 LHS 查询，<code>a=2</code>,这是隐式的，可能会被忽略。</p>\n<h4 id=\"词法作用域\">词法作用域<a href=\"#词法作用域\" title=\"词法作用域\"></a></h4><p>这里有两个关键词：</p>\n<ul><li>词法化</li>\n<li>遮蔽效应<br>词法作用域是由你在写代码时将变量和块作用域写在哪里决定的。<br>遮蔽效应是如果在当前作用域和上一层作用域存在相同名称的变量，如果在当前作用域调用该变量，则当前作用域的变量会遮蔽外层作用域的变量</li>\n</ul><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span> <span class=\"comment\">//这里如果注释掉，下面会输出1</span></span><br><span class=\"line\">  console.log(a) <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1()</span><br></pre></td></tr></table></figure><p>在词法作用域中有两种欺骗词法：<code>eval()</code> 和 <code>with()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str, a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">eval</span>(str) <span class=\"comment\">//eval()将其中的参数会解析为js代码，并运行。</span></span><br><span class=\"line\">  <span class=\"comment\">//严格模式中。eval()运行时有自己的词法作用域，这样其中的参数将不会修改所在的作用域</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">foo(<span class=\"string\">'var b=123'</span>, <span class=\"number\">234</span>) <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure><p>还有 with()</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = &#123;</span><br><span class=\"line\">  b: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(o1)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1.a)</span><br><span class=\"line\">foo(o2)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o2.a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//2,a被泄露到全局作用域里了</span></span><br></pre></td></tr></table></figure><p>with()可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域<br>当我们给 with()传 o1 时，o1 内部有 a 属性，直接赋值，而传 o2 时，内部没有，则进行 LHS 查询到全局作用域赋值<br>，with()实际是给传递给他的变量创造了一个新的词法作用域。</p>\n<h4 id=\"this\">this<a href=\"#this\" title=\"this\"></a></h4><p>常见 this 理解误区</p>\n<ul><li>1.this 指向自身</li>\n<li>2.this 指向它的作用域（这种比较容易混淆，在某些状况是正确的，在其他状况是错误的）</li>\n</ul><h5 id=\"this-绑定规则\">this 绑定规则<a href=\"#this-绑定规则\" title=\"this 绑定规则\"></a></h5><ul><li>默认绑定</li>\n</ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">f1() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure><ul><li>隐式绑定</li>\n</ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  f2: f1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.f2()</span><br></pre></td></tr></table></figure><p>隐式绑定一个常见的问题是隐式绑定的函数会丢失绑定对象<br>，会引用默认绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span>,</span><br><span class=\"line\">  foo: foo,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo</span><br><span class=\"line\">a = <span class=\"string\">'123'</span></span><br><span class=\"line\">bar()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">这里的参数传递其实就是一种隐式赋值。传入函数时也会被隐式赋值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DoFoo</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  f()</span><br><span class=\"line\">  obj.foo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a = <span class=\"string\">'123'</span></span><br><span class=\"line\">obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">223</span>,</span><br><span class=\"line\">  foo: foo,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.foo()</span><br><span class=\"line\">DoFoo(obj.foo)</span><br></pre></td></tr></table></figure><p>还有一个问题是在回调函数中很容易出现 this 丢失的情况，而在一些回调函数中，还会出现修改 this 指向的情况<br>判断 this 的优先级</p>\n<ul><li>函数是否在 new 中调用，(new 绑定)？如果是的话 this 绑定的是新创建的对象</li>\n<li><code>var bar = new foo()</code></li>\n<li>函数是否通过 call()，apply()或者硬绑定调用？如果是的话，this 绑定的是指定的对象</li>\n<li><code>var bar =foo.call(obj)</code></li>\n<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象</li>\n<li><code>var bar = obj1.foo()</code></li>\n<li>如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到 undefined，负责绑定到全局对象。</li>\n<li><code>var bar = foo()</code></li>\n</ul><h4 id=\"被忽略的-this\">被忽略的 this<a href=\"#被忽略的-this\" title=\"被忽略的 this\"></a></h4><p>如果 call(),apply(),bind()，第一个参数传入的是 null 或者 undefined，那么实际绑定为默认绑定，常见的一种做法是用 apply(null,[…])，但是总是使用<code>null</code>有时会产生不必要的效果，比如 this 指向了全局作用域，这样会在不知不觉中修改了全局变量，一种安全的 this 做法是，利用<code>object.create(null)</code>创建一个空对象来作为 this 指向。</p>\n<h4 id=\"间接引用\">间接引用<a href=\"#间接引用\" title=\"间接引用\"></a></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span>,</span><br><span class=\"line\">  foo: foo,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o3 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">o2.foo() <span class=\"comment\">//3</span></span><br><span class=\"line\">;(o3.foo = o2.foo)() <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure><p>赋值表达式 o3.foo=o2.foo 返回值是目标函数的引用，因此调用位置是 foo()而不是 o3.foo(),于是会用默认绑定，绑定到全局作用域，而全局作用域没有定义<code>a</code>，输出 undefined。</p>\n<h4 id=\"this-词法\">this 词法<a href=\"#this-词法\" title=\"this 词法\"></a></h4><p>上面是正常函数定义<code>function(){}</code>，而 ES6 中提出新的定义函数方式：箭头函数，箭头函数 this 指向有外层作用域来决定，来看一段代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">function <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a) =&gt; &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bar = foo.call(obj1)</span><br><span class=\"line\">bar.call(obj2) <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure><p>foo 内部 return 的箭头函数，this 调用时会捕获 foo()的 this，而 foo 的 this 绑定到来 obj1，所以 bar 的 call()无效了。</p>\n","prev":{"title":"javaScript常用字符串以及数组处理函数","link":"2020/05/28/javaScript常用字符串以及数组处理函数"},"next":{"title":"Promise和Observable区别","link":"2020/05/12/Promise和Observable区别"},"plink":"https://edsion11.github.io/2020/05/19/你不知道的JavaScript（一）/","toc":[{"id":"11-编译原理","title":"1.1 编译原理","index":"1"},{"id":"12-作用域","title":"1.2 作用域","index":"2"},{"id":"编译器（关于变量声明）","title":"编译器（关于变量声明）","index":"3"},{"id":"词法作用域","title":"词法作用域","index":"4"},{"id":"this","title":"this","index":"5"},{"id":"被忽略的-this","title":"被忽略的 this","index":"6"},{"id":"间接引用","title":"间接引用","index":"7"},{"id":"this-词法","title":"this 词法","index":"8"}],"copyright":{"author":"Edsion Gu","link":"<a href=\"https://edsion11.github.io/2020/05/19/你不知道的JavaScript（一）/\" title=\"你不知道的JavaScript（一）\">https://edsion11.github.io/2020/05/19/你不知道的JavaScript（一）/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}