[{"title":"Ant Design Select组件弹出选项跟随外部容器scroll问题记录","date":"2023-10-13T15:24:38.000Z","date_formatted":{"ll":"Oct 13, 2023","L":"10/13/2023","MM-DD":"10-13"},"updated":"2023-10-16T09:36:26.280Z","content":"问题阐述\n起因是测试提了 bug 在飞书项目上，截图是说下拉框的内容飘在页面别的地方，当时看到图片的第一反应：是不是浏览器渲染卡了抑或是偶现 bug，反正压根没往代码上面去想，先把优先级降到了 P2，在后来忙完了的时候，再回过头来梳理项目缺陷，看到这个还没 close 掉，于是开始认真看这个 bug。\n\n\n想法\n首先是本地启动项目后，在 Chrome devtool 中查看下拉框的样式可以发现这个弹出的选择框行内样式为绝对定位：\n\n123456789z-index: 1;width: 400px;left: 900px;top: 500px;.ant-select-dropdown &#123;  position: absolute;  // ...&#125;\n在每次点击下拉框展开时，left和top属性都会变化，推测是实时计算得出的值，看到这里反应是Select组件的父元素没设置position: relative，仔细观察发现这个组件弹出框是渲染在最外层DOM结构下，所以排除这个原因。接着看了半天也没看出来原因，于是去 github issues 下面找找，看别人是否也有遇到这个问题，找到一个很类似的问题发现了答案：\nGithub ant-design Popover and Select #3438\n官方文档也有说明整理了一些 Ant Design 社区常见的问题和官方答复\nSelect Dropdown DatePicker TimePicker Popover Popconfir 会跟随滚动条上下移动\n使用 &lt;Select getPopupContainer=&#123;trigger =&gt; trigger.parentElement&#125;&gt;API 文档来将组件渲染到滚动区域内，或者使用其他的 getXxxxContainer 参数。如果需要全局解决这个问题，可以使用 &lt;ConfigProvider getPopupContainer=&#123;trigger =&gt; trigger.parentElement&#125;&gt;API 文档\n并且保证 parentElement 是 position: relative 或 position: absolute。\n解决\n于是在组件props加上 getPopupContainer=&#123;(triggerNode) =&gt; triggerNode.parentNode &#125;，问题得以解决，在点开下拉框后，滚动页面，下拉框的内容不会固定不动了\n源码研究\n再解决完 bug 之后再来看看为什么加上这个属性，就可以正常展示了，首先是加上这个属性之后，原本渲染在最外层 dom 的 Pop 组件渲染在正常文档流中，就是和选择框渲染在同一个 dom 中\n组件结构：\n&lt;Select/&gt; =&gt; &lt;Trigger ... getPopupContainer=&#123;props.getPopupContainer&#125; /&gt;\n&lt;Popup ... target=&#123;targetEle&#125; getPopupContainer=&#123;getPopupContainer&#125;/&gt;\n&lt;Portal ... getContainer=&#123;getPopupContainer &amp;&amp; (() =&gt; getPopupContainer(target))&#125;/&gt;\n看了一下整个组件的层级，首先getPopupContainer函数先传入，getPopupContainer函数的类型定义如下：\n1export declare type RenderDOMFunc = (props: any) =&gt; HTMLElement;\n它的功能是返回一个 dom 元素，HtmlElement的定义是：\n\nThe HTMLElement interface represents any HTML element. Some elements directly implement this interface, while others implement it via an interface that inherits it.\n\n这个函数有个入参是在Popup组件传入的:\n\n&#123;1,2,4-5&#125;123456789101112131415161718192021222324252627// =========================== Target ===========================// Use state to control here since `useRef` update not trigger renderconst [targetEle, setTargetEle] = React.useState&lt;HTMLElement&gt;(null);const setTargetRef = useEvent((node: HTMLElement) =&gt; &#123;  if (isDOM(node) &amp;&amp; targetEle !== node) &#123;    setTargetEle(node);  &#125;&#125;);//... 这里渲染的是下拉框Select的点击交互组件&lt;ResizeObserver  disabled=&#123;!mergedOpen&#125;  ref=&#123;setTargetRef&#125; // 获取Select实际dom元素  onResize=&#123;onTargetResize&#125;&gt;  &lt;TriggerWrapper getTriggerDOMNode=&#123;getTriggerDOMNode&#125;&gt;    &#123;triggerNode&#125;  &lt;/TriggerWrapper&gt;&lt;/ResizeObserver&gt;// 这里渲染的是下拉框的弹出框内容组件 render Popup component=&gt;&lt;Popup    portal=&#123;PortalComponent&#125;    ref=&#123;setPopupRef&#125;    target=&#123;targetEle&#125;    getPopupContainer=&#123;getPopupContainer&#125;    .../&gt;\n上面是rc-trigger组件与getPopupContainer的主要逻辑，即获取到Select组件的实际dom保存下来传递给Popup组件,然后在Popup组件中使用：\n&lt;Portal open=&#123;forceRender || isNodeVisible&#125; getContainer=&#123;getPopupContainer &amp;&amp; (() =&gt; getPopupContainer(target))&#125; autoDestroy&#123;autoDestroy&#125; /&gt;\n接下来是portal组件的实现，比较简单的渲染逻辑，默认渲染在body下，当有getContainer()时，会根据传入的dom渲染\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// Portal componentimport * as React from &#x27;react&#x27;;// ...export interface PortalProps &#123;  /** Customize container element. Default will create a div in document.body when `open` */  getContainer?: GetContainer;  children?: React.ReactNode;  ...&#125;const getPortalContainer = (getContainer: GetContainer) =&gt; &#123;  if (getContainer === false) &#123;    return false;  &#125;  if (!canUseDom() || !getContainer) &#123;    return null;  &#125;  if (typeof getContainer === &#x27;string&#x27;) &#123;    return document.querySelector(getContainer);  &#125;  if (typeof getContainer === &#x27;function&#x27;) &#123;    return getContainer();  &#125;  return getContainer;&#125;;const Portal = React.forwardRef&lt;any, PortalProps&gt;((props, ref) =&gt; &#123;  const &#123;    getContainer,   // ...  &#125; = props;  const [shouldRender, setShouldRender] = React.useState(open);  const mergedRender = shouldRender || open;  // ========================= Warning =========================  if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;    warning(      canUseDom() || !open,      `Portal only work in client side. Please call &#x27;useEffect&#x27; to show Portal instead default render in SSR.`,    );  &#125;  // ====================== Should Render ======================  React.useEffect(() =&gt; &#123;    if (autoDestroy || open) &#123;      setShouldRender(open);    &#125;  &#125;, [open, autoDestroy]);  // ======================== Container ========================  const [innerContainer, setInnerContainer] = React.useState&lt;    ContainerType | false  &gt;(() =&gt; getPortalContainer(getContainer));  React.useEffect(() =&gt; &#123;    const customizeContainer = getPortalContainer(getContainer);    // Tell component that we check this in effect which is safe to be `null`    setInnerContainer(customizeContainer ?? null);  &#125;);  const [defaultContainer, queueCreate] = useDom(    mergedRender &amp;&amp; !innerContainer,    debug,  );  const mergedContainer = innerContainer ?? defaultContainer;  // ========================= Locker ==========================  useScrollLocker(    autoLock &amp;&amp;      open &amp;&amp;      canUseDom() &amp;&amp;      (mergedContainer === defaultContainer ||        mergedContainer === document.body),  );  // =========================== Ref ===========================  let childRef: React.Ref&lt;any&gt; = null;  if (children &amp;&amp; supportRef(children) &amp;&amp; ref) &#123;    (&#123; ref: childRef &#125; = children as any);  &#125;  const mergedRef = useComposeRef(childRef, ref);  // ========================= Render ==========================  // Do not render when nothing need render  // When innerContainer is `undefined`, it may not ready since user use ref in the same render  if (!mergedRender || !canUseDom() || innerContainer === undefined) &#123;    return null;  &#125;  // Render inline  const renderInline = mergedContainer === false || inlineMock();  return (    &lt;OrderContext.Provider value=&#123;queueCreate&#125;&gt;      &#123;renderInline        ? reffedChildren        : createPortal(reffedChildren, mergedContainer)&#125;    &lt;/OrderContext.Provider&gt;  );&#125;);\n所以加入getPopupContainer=&#123;(triggerNode) =&gt; triggerNode.parentNode &#125;这行代码的意义是让Select组件的Popup组件渲染在正常文档流的内部,这样不会和别的区域内容有重叠，以及滑动行为与主操作区域一致。\n\n相关组件\nReact-component Select\nReact-component Trigger\nReact-component Portal\n\n","plink":"https://edsion11.github.io/2023/10/13/Ant-Design-Select组件弹出选项跟随外部容器scroll问题记录/"},{"title":"使用Angular Universal做ssr渲染","date":"2021-12-12T18:34:32.000Z","date_formatted":{"ll":"Dec 12, 2021","L":"12/12/2021","MM-DD":"12-12"},"updated":"2023-10-16T08:07:08.477Z","content":"最近在公司的项目中用到了react做ssr渲染，于是想在angular中也试试，angular在很久之前就出了做ssr渲染的库，名字是@nguniversal/express-engine,使用ng add可以稳定的将自己的项目转化为ssr渲染模式\n如何构建服务端渲染项目\n1ng add @nguniversal/express-engine\n这样我们的项目中会多出几个文件，分别是\n123456src/  main.server.ts             * bootstrapper for server app  app/ ...                   application code    app.server.module.ts     * server-side application moduleserver.ts                    * express web servertsconfig.server.json         TypeScript server application configuration\n首先是main.server.ts文件如下：这个文件主要是服务端渲染的初始化文件，包括设置环境enableProdMode以及export AppServerModule模块在server中bootstrap\n\nmain.server.ts\n\n12345678910111213141516171819/*************************************************************************************************** * Initialize the server environment - for example, adding DOM built-in types to the global scope. * * NOTE: * This import must come before any imports (direct or transitive) that rely on DOM built-ins being * available, such as `@angular/elements`. */import &#x27;@angular/platform-server/init&#x27;import &#123; enableProdMode &#125; from &#x27;@angular/core&#x27;import &#123; environment &#125; from &#x27;./environments/environment&#x27;if (environment.production) &#123;  enableProdMode()&#125;export &#123; AppServerModule &#125; from &#x27;./app/app.server.module&#x27;export &#123; renderModule, renderModuleFactory &#125; from &#x27;@angular/platform-server&#x27;\n其次一个比较重要的文件是server.ts文件：这里是express启动的地方，以及各种服务端的中间处理逻辑都写在这里。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import &#x27;zone.js/dist/zone-node&#x27;import &#123; ngExpressEngine &#125; from &#x27;@nguniversal/express-engine&#x27;import * as express from &#x27;express&#x27;import &#123; join &#125; from &#x27;path&#x27;import &#123; createProxyMiddleware &#125; from &#x27;http-proxy-middleware&#x27;import &#123; AppServerModule &#125; from &#x27;./src/main.server&#x27;import &#123; APP_BASE_HREF &#125; from &#x27;@angular/common&#x27;import &#123; existsSync &#125; from &#x27;fs&#x27;// The Express app is exported so that it can be used by serverless Functions.export function app(): express.Express &#123;  const server = express()  const distFolder = join(process.cwd(), &#x27;dist/mean-app/browser&#x27;)  const indexHtml = existsSync(join(distFolder, &#x27;index.original.html&#x27;))    ? &#x27;index.original.html&#x27;    : &#x27;index&#x27;  // Our Universal express-engine (found @ https://github.com/angular/universal/tree/master/modules/express-engine)  server.engine(    &#x27;html&#x27;,    ngExpressEngine(&#123;      bootstrap: AppServerModule,    &#125;)  )  server.set(&#x27;view engine&#x27;, &#x27;html&#x27;)  server.set(&#x27;views&#x27;, distFolder)  // Example Express Rest API endpoints  // server.get(&#x27;/api/**&#x27;, (req, res) =&gt; &#123; &#125;);  // Serve static files from /browser  server.get(    &#x27;*.*&#x27;,    express.static(distFolder, &#123;      maxAge: &#x27;1y&#x27;,    &#125;)  )  server.use(    &#x27;/api&#x27;,    createProxyMiddleware(&#123;      target: &#x27;https://data.mongodb-api.com/...&#x27;,      changeOrigin: true,      pathRewrite: &#123;        &#x27;^/api&#x27;: &#x27;/&#x27;, // rewrite path      &#125;,    &#125;)  )  // All regular routes use the Universal engine  server.get(&#x27;*&#x27;, (req, res) =&gt; &#123;    res.render(indexHtml, &#123;      req,      providers: [&#123; provide: APP_BASE_HREF, useValue: req.baseUrl &#125;],    &#125;)  &#125;)  return server&#125;function run(): void &#123;  const port = process.env.PORT || 4000  // Start up the Node server  const server = app()  server.listen(port, () =&gt; &#123;    console.log(`Node Express server listening on http://localhost:$&#123;port&#125;`)  &#125;)&#125;// Webpack will replace &#x27;require&#x27; with &#x27;__webpack_require__&#x27;// &#x27;__non_webpack_require__&#x27; is a proxy to Node &#x27;require&#x27;// The below code is to ensure that the server is run only when not requiring the bundle.declare const __non_webpack_require__: NodeRequireconst mainModule = __non_webpack_require__.mainconst moduleFilename = (mainModule &amp;&amp; mainModule.filename) || &#x27;&#x27;if (moduleFilename === __filename || moduleFilename.includes(&#x27;iisnode&#x27;)) &#123;  run()&#125;export * from &#x27;./src/main.server&#x27;\n这里主要的逻辑有\n\n1.服务端express引擎处理html\n2.设置静态文件的加载\n3.设置路由\n4.对response和request做处理(middleware)\n\n最后是app.server.module.ts是整个angular应用的顶层模块注入管理，在@NgModule中引入了两个新的模块处理服务端渲染的状态管理和模块注入。\n坑点1\n正常来说，通过Angular的ng add @nguniversal/express-engine这行命令就可以自动帮助我们构建服务端渲染程序。但是我遇到一个问题是之前CSR渲染时router定义的方法是通过routerModule定义注入进AppModule的方式：\n12345678910import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; Routes, RouterModule &#125; from &#x27;@angular/router&#x27;;const routes: Routes = [...];@NgModule(&#123;  imports: [RouterModule.forRoot(routes, &#123; relativeLinkResolution: &#x27;legacy&#x27; &#125;)],  exports: [RouterModule],&#125;)export class AppRoutingModule &#123;&#125;\n这样的方式在服务端渲染时并未生效，于是查看了一下文档发现最新文档已经不用这样写了，直接定义routes，然后在AppModule中RouterModule.forRoot(routes,...）注入就可以了！\n坑点2\n由于我的个人项目是使用tailwindcss管理样式，这样在服务端渲染时，加载的时间会特别长，看了一下tailwindcss在本地开发是全量打包进style里的，于是每次加载的时候都会加载这个包，这个包体积很大，tailwind官方有shaking的配置，但建议是在生产环境下再进行shaking，原理也就是通过正则对html分析然后剔除不用的类。于是乎被迫在本地开发的情况开启了：\n1234567891011module.exports = &#123;    prefix: &#x27;&#x27;,    purge: &#123;      enabled:  true,      content: [        &#x27;./src/**/*.&#123;html,ts&#125;&#x27;,      ]    &#125;,    ...&#125;;\n坑点3：重复渲染/请求\n基于Angular universal的处理会在服务端渲染以及hydrate后在浏览器再执行一遍render，这个目前看起来不是很理解，官方目前也知道这个问题，于是有处理方案：\n1import &#123;TransferHttpCacheModule&#125; from &#x27;@nguniversal/common&#x27;;\nTransferHttpCacheModule\n一个issue\nAngular - TransferState - page is loading twice (flickering) issue\n主要是import进TransferHttpCacheModule注入至全局Module，这样可以缓存内部httpClientModule发起的http请求，防止重复请求闪屏的出现。\n暂时就这些问题，先记录一下。\n","plink":"https://edsion11.github.io/2021/12/12/使用angular-universal做ssr渲染/"},{"title":"有关Angular新一代编译引擎Ivy的介绍","date":"2021-07-22T23:43:37.000Z","date_formatted":{"ll":"Jul 22, 2021","L":"07/22/2021","MM-DD":"07-22"},"updated":"2023-10-16T08:07:13.962Z","content":"Angular\nAngular是目前全球最受欢迎的框架之一，但由于在框架中有许多库以及编译知识需要学习，在国内的使用率并不高。同时由于加载时间长，因为Angular生成的项目文件较大也被React以及Vue更优秀的打包体积以及更好的开发体验所打败。但如果掌握了Angular的原理之后，我们也能开发出与React应用性能所差无几的Web App。而由于之前Angular 8.0版本之前使用的是View Engine编译器来对Angular项目文件进行编译，造成了打包体积较大以及不容易追踪bug。于是Angular团队推出了Ivy编译器。\n什么是Ivy编译\nIvy是下一代模板编译引擎以及渲染的管道工具，他非常先进，并提供了以前没有的高级功能以及更快的编译速度。实际是Ivy是Angular之前渲染引擎的完全重写，具体来说是第四次重写，使用Ivy可以独立得编译组件，同时对于热更新也支持的更好，在重写编译应用程序时会只涉及编译发生更改的组件。\ntreeshakable\n同时Ivy另一个重要的点是对于项目文件的treeshaking，意思是在编译打包过程中删除未使用的代码，这也可以通过一些工具如Rollup以及Uglify来完成。在构建的过程中，treeshaking工具使用静态分析消除未使用以及未引用的代码。由于代码的静态分析依赖与引用，当有条件的逻辑判断代码存在的时候，工具不能正确识别，会出现失败的情况。\n局限性\n局限性指的是在使用本地代码独立的编译每个组件的过程，通过对于修改部分的重编译而不是整个项目文件的重新编译来更快地构建，这会显著的提升构建速度。在之前的Angular代码中，每个组件都存在它的父信息，这就导致了编译依赖，从而编译的文件变多。而在Ivy中，每个组件只会生成关于该组件自身的信息，除去了可申明依赖项的名词和包的名称。\nIvy编译样例\n在Angular中尝试编写如下代码：\n1234&lt;div&gt;    &lt;p&gt;ivy works&lt;/p&gt;    &lt;app-child&gt;&lt;/app-child&gt;&lt;/div&gt;\n这里的app-child代表一个引用的子组件。通过Ivy编译得到的Ivy.component.js如图\n\n而我们再通过在未开启Ivy的条件下进行再一次编译，这一次得到如下的目录结构：\n\n这里挑两个主要的文件ivy.component.js和ivy.component.ngfactory.js来展示View Engine编译后的文件：\n\n\n可以看到，编译后的文件种类以及代码量相较于Ivy编译都变多了不少。\nAOT编译和JIT编译\nAngular 应用主要由组件及其 HTML 模板组成。组件是由Typescript语言编写以及使用装饰器定义而成，由于浏览器无法直接理解 Angular 所提供的组件和模板，因此 Angular 应用程序需要先进行编译才能在浏览器中运行。在浏览器下载和运行代码之前的编译阶段，Angular 预先（AOT）编译器会先把你的 Angular HTML 和 TypeScript 代码转换成高效的 JavaScript 代码。 在构建期间编译应用可以让浏览器中的渲染更快速。而在官方文档中给出了使用AOT的部分原因：\n\n更快的渲染\n更少的异步请求\n较小的 Angular 框架下载大小\n尽早检测模板错误\n更高的安全性( AOT 在将 HTML 模板和组件提供给客户端之前就将其编译为 JavaScript 文件。没有要读取的模板，没有潜藏风险的客户端 HTML 或 JavaScript eval，受到注入攻击的机会就更少了。)\n\n在早期的Angular8版本之前，Angular并没有采用AOT编译的方法，而是采用了JIT(即时编译)编译来生成应用，它会在运行期间在浏览器中编译你的应用。JIT编的一般步骤是、\n首先将Typescript代码（包括用户编写的代码，以及Angular框架、Angular编译器代码）编译成JavaScript代码。接着将这些代码部署到服务器端然后浏览器发起请求下载代码开始执行，接着Angular启动，Angular调用Angular编译器。对于每个组件类、ngModule、Pipe等都需要编译，之前typescript代码编译为javascript代码所保存的metadata，根据metadata编译出浏览器可以执行的Javascript代码前面图里的NgFactory文件。接着通过NgFactories文件来构建整个应用的具体组件。\n这里有对AOT与JIT编译详解的文章：Angular编译机制AOT和JIT\n开启Ivy编译\nIvy编译默认采用的是AOT编译方法，在之前angular主要使用的都是JIT编译，如果需要使用Ivy编译，需要修改tsconfig.app.ts中添加angularCompilerOptions选项以及开启enableIvy。\n123456&#123;   &quot;compilerOptions&quot;: &#123; ... &#125;,  &quot;angularCompilerOptions&quot;: &#123;    &quot;enableIvy&quot;: true  &#125;&#125;\n其次要确认的是angular配置文件angular.json中aot设置为true。\nIvy运行时\n新的运行时引擎基于increnmental DOM的概念。这是一种使用指令表达和应用更新到 DOM 树的方法。DOM 更新是 Angular 中变化检测的主要部分，因此这个概念可以方便地应用到框架中。在在这篇文章中可以了解更多关于它的内容，它解释了这个概念背后的推理，并将它与React 中的Virtual DOM进行了对比。增量 DOM 也恰好是一个库，但是新的 Ivy 引擎没有使用它，而是实现了自己的增量DOM版本。\n在之前Angular的主要实现逻辑是实例化组件、创建DOM节点以及进行更改检测，而这个整体是通过一个很小的原子单元实现的(atomic unit)。编译器只是生成有关的组件以及组件中定义元素的元数据meta data。如下图\n\n而新的Ivy引擎下的步骤如下：\n\n可与看出模板指令是实例化组件、创建 DOM 节点和运行变更检测的逻辑所在。但是它已经从整体的解释器转移到了单个的指令中。而Ivy带来的另一个优点是对于变更检测(change detection)的调试。新的Ivy编译环境下可以直接在模板函数中放置断点即可调试组件的变更检测。\n新的编译器还会将一组独立的Typescript类转换编译为表示Class组件的的AST。这些转换都会被实现为一种纯函数，这个函数接受表示装饰器的元数据meta data并将该定义作为静态字段添加到组件类中。\n以上便是关于Ivy编译引擎的介绍，而新的Ivy对于原来的变更检测也会带来变化，这个在下次关于变更检测的文章中进行总结。\n参考文章：\n\nAngular 中的 Ivy 引擎：首次深入了解编译、运行时和更改检测\n5分钟了解Ivy\nUnderstanding Angular Ivy Library Compilation\nRenderer and ViewContainerRef over directly manipulating the DOM\nEliran Eliassy — Get ready for Ivy — Angular 3rd generation renderer engine\n强烈推荐Eliassy大佬对于Ivy的介绍，以及展示了调试Angular应用的黑科技！\n\n","plink":"https://edsion11.github.io/2021/07/22/有关Angular新一代编译引擎Ivy的介绍/"},{"title":"Typescript相关","date":"2021-02-21T20:37:20.000Z","date_formatted":{"ll":"Feb 21, 2021","L":"02/21/2021","MM-DD":"02-21"},"updated":"2022-01-22T09:45:40.641Z","content":"最近复习基础看到了Learning Typescript这本书，翻开学习，发现了不少知识，在此记录一下。\n面向对象编程\nSOLID原则\n利用Typescript进行面向对象编程要注意五个点，简称为“SOLID”原则\n\n单一职责原则(SRP): 表明软件组件(函数，类，模块)必须专注于单一的任务(只有单一的职责)\n开/闭原则(OCP): 表明软件设计时必须时刻考虑到(代码)可能的发展(具有扩展性)，但是程序的发展必须最少地修改已有的代码(对已有的修改封闭)\n-里氏替换原则(LSP): 表明只要继承的是同一个接口，程序里任意一个类都可以被其他的类替换。在替换完成后，不需要其他额外的工作程序就能像原来一样运行。\n-接口隔离原则(ISP): 表明我们应该将那些非常大的接口拆分成一些更具体的接口，这样客户端就只需要关心他们需要用到的接口\n-依赖反转原则(DIP): 表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。\n用Typesciript编写一个类如下：\n\n 1234567891011121314class Person&#123;    public name: string;    public surname: string;    public email: string;    constructor(name: string, surname: string, email: string)&#123;        this.email = email;        this.name = name;        this.surname = surname;    &#125;    greet()&#123;        alert(&quot;hello&quot;);    &#125;&#125;var p : Person = new Person(&quot;liming&quot;, &quot;li&quot;, &quot;123@163.com&quot;);\n如果要验证email的格式，在Person上增加代码会使Person类变得非常大，我们可以八email抽象成一个类分离出来，这体现了第一个单一职责原则。\n 123456789101112131415161718192021222324252627class Email&#123;    public email: string;    constructor(email: string)&#123;        if(this.validateEmail(email))&#123;            this.email = email        &#125;else&#123;            throw new Error(&quot;Invalid email!&quot;)        &#125;    &#125;    private validateEmail(email: string)&#123;        var re = &#x27;/\\S+@\\S+\\.\\S+/&#x27;;        return re.test(email)    &#125;&#125;class Person&#123;       public name: string;       public surname: string;       public email: Email;       constructor(name: string, surname: string, email: string)&#123;           this.email = email;           this.name = name;           this.surname = surname;       &#125;       greet()&#123;           alert(&quot;hello&quot;);       &#125;   &#125;\n在面向对象的过程中，类与类有一些关系，比如关联，聚合，组合，继承，混合等，接下来并不介绍他们的概念，而是介绍一下泛型类和泛型约束\n泛型类\n泛型类如同泛型函数，可以介绍很多重复的代码，接下来用代码说明\n首先是一个类\n\n这里包括一个User的类和一个NotGenericUserRepository的类，后面这个类是获取User的列表，并传给JSON文件，当我们想获取一个会议，或者一个歌曲列表时，不同的类形成的这个GenericRepository类也就要重写，这时可以利用泛型类。如下所示：\n\n有时候，我们需要泛型约束，如上述例子，新需求是增加一些变更来验证通过Ajax请求的数据:\n12345678910success: (data)=&gt;&#123;    var list: T[]    var items = &lt;T[]&gt;data.items    for(let i=0;i&lt;items.length;i++)&#123;        if(items[i].isValid())&#123; // 验证            // ...        &#125;    &#125;    resolve(list)&#125;\n那我们可以写一个验证接口，将泛型进行约束：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class User implements ValidatableInterface&#123;    public name: string    public password: string    constructor(name: string, password: string)&#123;        this.name = name        this.password = password    &#125;    public isValid()&#123;        // ...        return true    &#125;&#125;class Talk implements ValidatableInterface&#123;    public name: string    constructor(name: string, password: string)&#123;        this.name = name    &#125;    public isValid()&#123;        // ...        return true    &#125;&#125;class NotGenericUserRepository&lt;T extends ValidatableInterface&gt;&#123;    private _url: string    constructor(url: string)&#123;        this._url = url    &#125;    public getAsync()&#123;        return new Promise((resolve: (users: T[]) =&gt; void. reject) =&gt; &#123;            $.ajax(&#123;                url: this._url,                type: &quot;GET&quot;,                dataType: &quot;JSON&quot;,                success: (data)=&gt;&#123;                    var list: T[]                    var items = &lt;T[]&gt;data.items                    for(let i=0;i&lt;items.length;i++)&#123;                        if(items[i].isValid())&#123;                            list.push(items[i])                        &#125;                    &#125;                    resolve(list)                &#125;,                error: (e)=&gt;&#123;                    reject(e)                &#125;            &#125;)        &#125;)    &#125;&#125;class User implements ValidatableInterface&#123;    public name: string    public password: string    constructor(name: string, password: string)&#123;        this.name = name        this.password = password    &#125;    public isValid()&#123;        // ...        return true    &#125;&#125;class Talk implements ValidatableInterface&#123;    public name: string    constructor(name: string, password: string)&#123;        this.name = name    &#125;    public isValid()&#123;        // ...        return true    &#125;&#125;class NotGenericUserRepository&lt;T extends ValidatableInterface&gt;&#123;    private _url: string    constructor(url: string)&#123;        this._url = url    &#125;    public getAsync()&#123;        return new Promise((resolve: (users: T[]) =&gt; void. reject) =&gt; &#123;            $.ajax(&#123;                url: this._url,                type: &quot;GET&quot;,                dataType: &quot;JSON&quot;,                success: (data)=&gt;&#123;                    var list: T[]                    var items = &lt;T[]&gt;data.items                    for(let i=0;i&lt;items.length;i++)&#123;                        if(items[i].isValid())&#123;                            list.push(items[i])                        &#125;                    &#125;                    resolve(list)                &#125;,                error: (e)=&gt;&#123;                    reject(e)                &#125;            &#125;)        &#125;)    &#125;&#125;\n泛型中的new操作\n要通过代码来创建新的对象，我们需要声明泛型T拥有构造函数，这意味着我们需要像下面一样，用type: &#123;new() :T;&#125;替代type:T\n\n\n","plink":"https://edsion11.github.io/2021/02/21/Typescript相关/"},{"title":"前端项目服务端渲染（SSR）","date":"2021-02-15T22:23:00.000Z","date_formatted":{"ll":"Feb 15, 2021","L":"02/15/2021","MM-DD":"02-15"},"updated":"2022-01-22T09:45:40.643Z","content":"名词解释\nSSR\n\nSSR：服务器端渲染-将客户端或通用应用程序渲染到服务器上的HTML。\n\nCSR\n\nCSR：客户端渲染-通常使用DOM在浏览器中渲染应用程序。\n\nRehydration\n\nRehydration： “启动”客户端上的JavaScript视图，以便它们重用服务器渲染的HTML的DOM树和数据。\n\nPrerendering\n\nPrerendering：在构建时运行客户端应用程序以将其初始状态捕获为静态HTML。\n\nTTFB\n\nTTFB： 到第一个字节的时间-视为单击链接到输入内容的第一位之间的时间。\n\nFP\n\nFP： First Paint-第一次获取任何像素对用户可见。\n\nFCP\n\nFCP： 第一个内容丰富的油漆-所请求的内容（文章主体等）可见的时间。\n\nTTI\n\nTTI： 互动时间-页面互动的时间（事件连线等）。\n\n前端渲染介绍\nCSR客户端渲染\n今天介绍的是服务端渲染（Server-side Rendering）,简称为SSR。\n首先介绍一下常见的web渲染模式，第一个是目前前后端分离的主要开发模式，也是大多数前端同学的开发方式，就是客户端渲染（Client-side Rendering）。目前的三大框架Angular,React,Vue都是基于CSR开发的框架，我们在开发时只需要和后端同学，提前约定好接口，接着前端页面由我们前端同学开发构建，在需要页面刷新的地方，可以使用Ajax技术进行局部刷新。\n1CSR (Client-Side Rendering) – rendering an app in a browser, generally using the DOM.\n\n上图是Google大会上贴出的介绍CSR的一张原理图，net代表网络请求，请求js文件“bundle.js”,此时是FCP时间点，\n1FCP：First Contentful Paint - the time when requested content (article body, etc) becomes visible.\n翻译过来就是：第一个内容丰富的渲染-所请求的内容（文章主体等）可见的时间。接下来由我们的js引擎以及浏览器渲染引擎渲染更多的页面内容。渲染完毕后又到了一个时间点：TTI。\n1TTI: Time To Interactive - the time at which a page becomes interactive (events wired up, etc)\n翻译过来就是：“互动时间-页面互动的时间（事件被整理等”,也就是用户第一次可以与页面交互的时间点。而从FCP到TTI需要花费的时间则是由我们前端打包的js文件大小决定。这其中包含了我们的业务代码，同时又有第三方库的部分代码。对于性能较差的机器，也就花费时间更长。在google大会上提到的有利用HTTP/2 Server Push或者&lt;link rel=preload&gt;加载数据，可以提升性能，而在我们前端开发中还可以使用懒加载，webpack的treeshaking等等减少js文件大小来减少渲染时长。同时由于目前的前端框架大多开发的是单页面应用SPA（single page Application）,如果js文件较大，则首屏加载会变慢，影响用户体验。让我换个思路，改变渲染模式，想想会有什么效果。\nSSR服务端渲染\n服务器呈现响应于导航生成服务器上页面的完整HTML。这样可以避免客户端进行数据获取和模板化的其他往返过程，因为它是在浏览器获得响应之前进行处理的。服务器渲染通常会产生快速的First Paint  （FP）和First Contentful Paint  （FCP）。在服务器上运行页面逻辑和呈现可以避免向客户端发送大量JavaScript，这有助于实现快速的交互时间 （TTI）。这是有道理的，因为使用服务器渲染，您实际上只是将文本和链接发送到用户的浏览器。这种方法可以在很大范围的设备和网络条件下很好地工作，并且可以带来有趣的浏览器优化，例如流文档解析。SSR渲染过程大致如下图所示：\n\n通过服务器渲染，用户不太可能会等待CPU绑定的JavaScript处理才能使用您的网站。即使 无法避免使用第三方JS，使用服务器渲染来减少自己的第一方JS成本也可以为您提供更多的“预算”。但是，此方法有一个主要缺点：在服务器上生成页面会花费时间，这通常会导致首字节时间 （TTFB）变慢。\n服务器渲染的动态特性可能会带来可观的计算开销。许多服务器渲染解决方案不会提早刷新，可能会延迟TTFB或将发送的数据加倍（例如，客户端JS使用的内联状态）。在React中，renderToString()可能很慢，因为它是同步的并且是单线程的。要使服务器呈现“正确”状态，可能涉及寻找或构建组件缓存解决方案，管理内存消耗，应用备忘录技术以及许多其他问题。通常，您要多次处理/重建同一应用程序-一次在客户端，一次在服务器。仅仅因为服务器渲染可以使某些事情更快地出现，并不意味着您要做的工作更少。\n服务器渲染会为每个URL按需生成HTML，但比仅提供静态渲染内容要慢。如果您可以进行其他工作，则服务器渲染+ HTML缓存可以大大减少服务器渲染时间。服务器渲染的优势在于，与静态渲染相比，它能够提取更多的“实时”数据并响应更完整的请求集。需要个性化的页面是请求类型的一个具体示例，无法与静态渲染一起很好地工作。\n参考链接\nGoogle开发者大会对于前端渲染的介绍\n","plink":"https://edsion11.github.io/2021/02/15/前端项目服务端渲染（SSR）/"},{"title":"Rust学习小记录","date":"2020-10-03T15:14:25.000Z","date_formatted":{"ll":"Oct 3, 2020","L":"10/03/2020","MM-DD":"10-03"},"updated":"2022-01-22T09:45:40.641Z","content":"Rust 入坑\n首先介绍一下 Rust:A language for the next 40 years 在油管上某视频被称为下一个 40 年所用的语言。那么 Rust 的特点有哪些呢，官网对其的介绍有三个特点：\n- 高性能\n- 可靠性\n- 生产力\n\nrust 是由 Mozila 公司推出是为构建高性能应用的语言，直接竞争对手有 C，C++语言。Rust 一些比较吸引人的是，具有很高的性能，类似于 npm 的包管理器（前端友好）,稳定的 async await 异步模型，前端的朋友应该很熟悉了。还有诸如泛型，trait，错误处理，生命周期，所有权提供内存安全，以及并发时的数据安全，智能指针+无 GC 更灵活。但 Rust 目前还处于成长状态，有友好的社区支持，但是整体生态不是很完善，可用的包较少，还需要较长时间的实践与发展。\nWebAssembly\nWebAssembly 是由主流浏览器厂商组成的 W3C 社区团体制定的新的规范，作为可用于前端开发的第四种“语言”。WebAssembly 有一套完整的语义，目标是将其他语言编译成wasm 或wat二进制文件，目标是充分发挥硬件能力以达到原生执行效率。\n作为一种编程语言，WebAssembly 由两种表示相同结构的格式组成，尽管使用的方式不同：\n\nwat 文件是 WebAssembly 的一种体现，用的是一种 S-expressions,用的是一种类似于 Clojure 的语言。\n而.wasm 二进制格式是低级别和用于通过 WASM 虚拟机直接消耗。从概念上讲，它类似于 ELF 和 Mach-O。\n\nrust 构建 wasm 之准备\n首先是工具链\n需要 rust 的构建工具 rustup，rustc， cargo.\nrustup是用来安装 rust 的工具，rustc是用来编译rust代码的命令行工具，cargo则是 rust 官方的包管理器。接下来安装wasm-pack，用来构建，测试，发布 rust 生成的 webAssembly。安装地址：wasm-pack。\n1cargo install cargo-generate\ncargo-generate用来启动和运行 rust 项目\n当然将wasm运行在 web 上，还需要npm包管理器\n1npm install npm@latest -g\n正式开始\n首先用刚才安装的cargo-generate克隆远程仓库的项目模板。\n12cargo generate --git https://github.com/rustwasm/wasm-pack-template\n运行之后会提示输入项目名称,比如hello。\n克隆完成后，进入项目\n12cd wasm-game-of-life\n项目结构如下\n123456789hello/├── Cargo.toml├── LICENSE_APACHE├── LICENSE_MIT├── README.md└── src    ├── lib.rs    └── utils.rs\n首先是 cargo.toml 文件，学习过 rust 的都应该了解了这个文件。这个文件类似与 npm 的package.json文件,里面保存了当前的项目的版本以及依赖的包。还有一个比较重要的文件是src下面的lib.rs文件,这个文件类似于一个模块，是我们即将编译为wasm文件的 rust 源文件,它主要用于wasm-bingen和javascript交互\n1234567891011121314151617181920212223#![allow(unused_variables)]fn main() &#123;mod utils;use wasm_bindgen::prelude::*;// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global// allocator.#[cfg(feature = &quot;wee_alloc&quot;)]#[global_allocator]static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;#[wasm_bindgen]extern &#123;    fn alert(s: &amp;str);&#125;#[wasm_bindgen]pub fn greet() &#123;    alert(&quot;Hello, hello!&quot;);&#125;&#125;\n接下来在当前目录下面运行\n1wasm-pack build\n会将我们的 rust 项目打包为 WebAssembly 文件和 js 文件，编译后的文件在pkg文件夹内\n123456pkg/├── package.json├── README.md├── hello_bg.wasm├── hello.d.ts└── hello.js\n同时也生成了 ts 文件，更有助与工程化的构建 web 程序\n接下来在当前目录下克隆一个 wasm 的 web 项目模板,\n12npm init wasm-app www\n可看wasm-app Github 介绍\n接下来修改目录下的文件的部分内容，让他能找到我们的 WebAssembly 文件，并运行在本地环境\n首先是修改www目录下的package.json\n12345678910&#123;  // ...  &quot;dependencies&quot;: &#123;                     // Add this three lines block!    &quot;wasm-game-of-life&quot;: &quot;file:../pkg&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    //...  &#125;&#125;\n接下来修改www/index.js为：\n123import * as wasm from &#x27;wasm-game-of-life&#x27;wasm.greet()\n接下来在该目录下运行\n12npm installnpm run start\n即可在本地环境看到了alert\n这样一个简单的 wasm 项目就运行起来了，接着我们可以在 rust 目录下写 lib.rs 来丰富我们的应用了。\n下一次分享利用 rust 构建一个小型服务器，用来操作 mongoDB 数据库。\n在之后可以尝试将tensorflow上的个别深度学习模型，编译为 wasm 运行在浏览器中，进行尝试。\n","plink":"https://edsion11.github.io/2020/10/03/Rust学习小记录/"},{"title":"JavaScript设计模式之观察者模式","date":"2020-07-25T13:12:22.000Z","date_formatted":{"ll":"Jul 25, 2020","L":"07/25/2020","MM-DD":"07-25"},"updated":"2022-01-22T09:45:40.641Z","content":"发布-订阅模式\n发布订阅模式又称为观察者模式，它定义了对象间的一种一对多的依赖关系，当一个对象发生改变时，所有依赖与它的对象都会得到通知。在前端开发中，DOM事件是一个典型的发布-订阅模型。比如我们监听一个点击事件，设置一个回调函数负责收到通知。\n现在来看看如何来实现一个JavaScript版的发布-订阅模式\n先实现一个发布者工厂：\n1234567891011121314151617181920212223242526272829303132333435var event = &#123;    clientList:[],    subscribe(key,fn) &#123;        if (!this.clientList[key]) &#123;            this.clientList[key] = []        &#125;        this.clientList[key].push(fn)    &#125;,    trigger()&#123;        var key = Array.prototype.shift.call(arguments),        fns = this.clientList[key];        if(!fns||fns.length===0)&#123;            return false        &#125;        for(let i=0,fn;fn = fns[i++];)&#123;            fn.apply(this,arguments);        &#125;    &#125;,    unsubscribe(key,fn) &#123;        var fns = this.clientList[key];        if(!fns)&#123;            return false        &#125;        if(!fn)&#123;            fns&amp;&amp;(fns.length=0)        &#125;else&#123;            for(let l = fns.length-1;l&gt;=0;l--)&#123;                let _fn = fns[l];                if(_fn===fn)&#123;                    fns.splice(l,1)                &#125;            &#125;        &#125;    &#125;&#125;\n在这个发布者工厂里我们先是定义个subscribe函数来对特定的属性进行订阅，并将订阅者存在属性订阅者列表中。接着定义一个trigger用来发布通知给所有的订阅者，接下来是一个unsubscribe来取消订阅，对对应属性的特定订阅者取消该属性的订阅。\n接着写一个给对象布置“发布-订阅”功能的函数\n1234567891011121314151617181920var installEvent = function(obj)&#123;    for(let i in event)&#123;        obj[i] = event[i]    &#125;&#125;//测试let xiaoming = (price)=&gt;&#123;    console.log(&quot;apple-price&quot;,price)&#125;let xiaoHong =(price)=&gt;&#123;    console.log(&quot;banana-price&quot;,price)&#125;sales.subscribe(&quot;apple&quot;,xiaoming)sales.subscribe(&quot;banana&quot;,xiaoHong)sales.trigger(&quot;apple&quot;,500)//apple-price 500sales.trigger(&quot;banana&quot;,600)//banana-price 600sales.trigger(&quot;apple&quot;,1200)//apple-price 1200sales.unsubscribe(&quot;apple&quot;,xiaoming)//取消订阅sales.trigger(&quot;apple&quot;,1)//\n以上就实现了一个简单的发布-订阅模式\nVue中的发布-订阅\n发布-订阅在目前的前端框架有诸多的应用，常见的是Vue2.0的双向绑定就利用了观察者模式\n在Vue2.0中使用Object.defineProperty对数据的属性进行劫持可以收到数据更改的消息，而如何通知视图更新呢，Vue中定义了一个依赖类：dep\n123456789101112131415161718192021222324252627282930313233343536373839// 源码位置：src/core/observer/dep.jsexport default class Dep &#123;  constructor () &#123;    this.subs = []  &#125;  addSub (sub) &#123;    this.subs.push(sub)  &#125;  // 删除一个依赖  removeSub (sub) &#123;    remove(this.subs, sub)  &#125;  // 添加一个依赖  depend () &#123;    if (window.target) &#123;      this.addSub(window.target)    &#125;  &#125;  // 通知所有依赖更新  notify () &#123;    const subs = this.subs.slice()    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;  &#125;&#125;/** * Remove an item from an array */export function remove (arr, item) &#123;  if (arr.length) &#123;    const index = arr.indexOf(item)    if (index &gt; -1) &#123;      return arr.splice(index, 1)    &#125;  &#125;&#125;\n在上面的依赖管理器Dep类中，我们先初始化了一个subs数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。\n有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：\n123456789101112131415161718192021222324function defineReactive (obj,key,val) &#123;  if (arguments.length === 2) &#123;    val = obj[key]  &#125;  if(typeof val === &#x27;object&#x27;)&#123;    new Observer(val)  &#125;  const dep = new Dep()  //实例化一个依赖管理器，生成一个依赖管理数组dep  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get()&#123;      dep.depend()    // 在getter中收集依赖      return val;    &#125;,    set(newVal)&#123;      if(val === newVal)&#123;          return      &#125;      val = newVal;      dep.notify()   // 在setter中通知依赖更新    &#125;  &#125;)&#125;\n其实在Vue中还实现了一个叫做Watcher的类，而Watcher类的实例就是我们上面所说的那个&quot;谁&quot;。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个Watcher实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的Watch实例，由Watcher实例去通知真正的视图。\nWatcher类的具体实现如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142export default class Watcher &#123;  constructor (vm,expOrFn,cb) &#123;    this.vm = vm;    this.cb = cb;    this.getter = parsePath(expOrFn)    this.value = this.get()  &#125;  get () &#123;    window.target = this;    const vm = this.vm    let value = this.getter.call(vm, vm)    window.target = undefined;    return value  &#125;  update () &#123;    const oldValue = this.value    this.value = this.get()    this.cb.call(this.vm, this.value, oldValue)  &#125;&#125;/** * Parse simple path. * 把一个形如&#x27;data.a.b.c&#x27;的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125; * parsePath(&#x27;a.b.c&#x27;)(data)  // 2 */const bailRE = /[^\\w.$]/export function parsePath (path) &#123;  if (bailRE.test(path)) &#123;    return  &#125;  const segments = path.split(&#x27;.&#x27;)  return function (obj) &#123;    for (let i = 0; i &lt; segments.length; i++) &#123;      if (!obj) return      obj = obj[segments[i]]    &#125;    return obj  &#125;&#125;\n此处附上一张Vue双向绑定的图解\n\n","plink":"https://edsion11.github.io/2020/07/25/JavaScript设计模式之观察者模式/"},{"title":"手动实现的call,apply,bind,new","date":"2020-06-27T19:52:13.000Z","date_formatted":{"ll":"Jun 27, 2020","L":"06/27/2020","MM-DD":"06-27"},"updated":"2023-10-16T08:07:11.643Z","content":"call\ncall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数\n语法：function.call(thisArg, arg1, arg2, ...)\n12345678910111213141516171819202122232425Function.prototype.mycall = function (thisArg, ...args) &#123;  //console.log(this)  if (typeof this !== &#x27;function&#x27;) &#123;    throw new TypeError(&#x27;error&#x27;)  &#125;  const fn = Symbol(&#x27;fn&#x27;) // 声明一个独有的Symbol属性, 防止fn覆盖已有属性  thisArg = thisArg || global || window // 若没有传入this, 默认绑定window对象  thisArg[fn] = this // this指向调用call的对象,即我们要改变this指向的函数  const result = thisArg[fn](...args) // 执行当前函数  delete thisArg[fn] // 删除我们声明的fn属性  return result&#125;function greet() &#123;  var reply = [this.animal, &#x27;typically sleep between&#x27;, this.sleepDuration].join(    &#x27; &#x27;  )  console.log(reply)&#125;global.obj = &#123;  animal: &#x27;cats&#x27;,  sleepDuration: &#x27;12 and 16 hours&#x27;,&#125;greet()// typically sleep betweengreet.mycall(obj)//cats typically sleep between 12 and 16 hours\napply\napply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。\n语法：func.apply(thisArg, [argsArray])\n123456789101112Function.prototype.myApply = function (thisArg, args) &#123;  if (typeof this !== &#x27;function&#x27;) &#123;    throw new TypeError(&#x27;error&#x27;)  &#125;  const fn = Symbol(&#x27;fn&#x27;) // 声明一个独有的Symbol属性, 防止fn覆盖已有属性  thisArg = thisArg || window // 若没有传入this, 默认绑定window对象  thisArg[fn] = this // this指向调用call的对象,即我们要改变this指向的函数  const result = thisArg[fn](...args) // 执行当前函数  delete thisArg[fn] // 删除我们声明的fn属性  return result // 返回函数执行结果&#125;greet.myApply(obj, [])//cats typically sleep between 12 and 16 hours\nBind\nbind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n语法: function.bind(thisArg, arg1, arg2, ...)\n注意三点:\n\nbind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数\nnew会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例\n没有保留原函数在原型链上的属性和方法\n\n12345678910111213141516171819Function.prototype.myBind = function (thisArg, ...args) &#123;  if (typeof this !== &#x27;function&#x27;) &#123;    throw TypeError(&#x27;Bind must be called on a function&#x27;)  &#125;  var self = this  // new优先级  var fbound = function () &#123;    self.apply(      this instanceof self ? this : thisArg,      args.concat(Array.prototype.slice.call(arguments))    )  &#125;  // 继承原型上的属性和方法  fbound.prototype = Object.create(self.prototype)  return fbound&#125;let result = greet.bind(obj)result()//cats typically sleep between 12 and 16 hours\nnew\n首先我们要知道new做了什么\n\n创建一个新对象，并继承其构造函数的prototype，这一步是为了继承构造函数原型上的属性和方法\n执行构造函数，方法内的this被指定为该新实例，这一步是为了执行构造函数内的赋值操作\n返回新实例（规范规定，如果构造方法返回了一个对象，那么返回该对象，否则返回第一步创建的新对象）\n\n 12345678910111213141516171819202122232425262728 function myNew(item,...args) &#123;    let obj = Object.create(item.prototype)    //这里要注意是否对象会有返回值    let result = item.apply(obj,args)    return typeof item()===undefined?obj:result&#125;function Book(name)&#123;    this.name = name    return &#123;        name:name    &#125;&#125;let b1 = myNew(Book,&quot;javaScript&quot;)let b2 = new Book(&quot;javaScript&quot;)let obj1 = new Object()Book.apply(obj1,[&quot;123&quot;])console.log(obj1)//&#123; name: &#x27;123&#x27; &#125;console.log(b1)//&#123; name: &#x27;javaScript&#x27; &#125;console.log(b2)//&#123; name: &#x27;javaScript&#x27; &#125;//function objectFactory() &#123;    var obj = new Object(),    Constructor = [].shift.call(arguments);    obj.__proto__ = Constructor.prototype;    var ret = Constructor.apply(obj, arguments);    return typeof ret === &#x27;object&#x27; ? ret : obj;&#125;;\n","plink":"https://edsion11.github.io/2020/06/27/手动实现的call-apply-bind-new/"},{"title":"leeocde-148-链表排序","date":"2020-06-09T19:44:10.000Z","date_formatted":{"ll":"Jun 9, 2020","L":"06/09/2020","MM-DD":"06-09"},"updated":"2022-01-22T09:45:40.642Z","content":"leetcode-148-链表排序\n题目描述：\n在 O(nlog n) 时间复杂度和常数级空间复杂度下，对链表进行排序。\n分析：看到O(nlog n)的时间复杂度以及O(1)的空间复杂度。确定使用归并排序作为主要程序结构。\n在归并排序中，体现了分而治之的思想：利用递归算法将链表分解一个个递归基：单节点。分解利用二分的思想，逐渐分解。但链表结构不同于向量结构，向量是循秩访问，可以求出中间元素的秩。链表则是通过节点间联系访问。这里是难点之一，解决方法是利用双指针法：设置快慢两个指针，快的走两步，慢的走一步，而且快指针定义在慢指针初始位置的下一位。这样当快指针为null时，慢指针刚好到中间。\n123456let mid = nodelet fast = node.nextwhile (fast &amp;&amp; fast.next) &#123;  mid = mid.next  fast = fast.next.next&#125;  \n链表多种操作会用到双指针的方法，这里while语句利用短路表达式&amp;&amp;，使代码可读性高，易于理解。\n有了这关键的一步，就可以递归了。\n1234567891011121314function mergeSort(node)&#123;    if (!node || !node.next) return node    let mid = node    let fast = node.next    while (fast &amp;&amp; fast.next) &#123;      mid = mid.next      fast = fast.next.next    &#125;    let rightList = mid.next    mid.next = null    let left = node    let right = rightList    return mergeList(mergeSort(left), mergeSort(right))//这里的mergeSort是合并算法  &#125;\n递归完成后就要合并了，合并和正常归并排序一致，将左链表与右链表逐一比较，较小者连接到头节点，即可。\n附上完整代码实现\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//**在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; *//** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */function ListNode(val) &#123;  this.val = val  this.next = null&#125;var sortList = function (head) &#123;  /**   *  合并每个递归基   * @param &#123;*&#125; left   * @param &#123;*&#125; right   */  //  function mergeList(left, right)&#123;    let res = new ListNode(0)    let pre = res    while (left &amp;&amp; right) &#123;      if (left.val &lt;= right.val) &#123;        pre.next = left        left = left.next      &#125; else &#123;        pre.next = right        right = right.next      &#125;      pre = pre.next    &#125;    pre.next = left ? left : right    return res.next  &#125;  /**   * 递归至每个递归基   * @param &#123;*&#125; node   */  function mergeSort(node)&#123;    if (!node || !node.next) return node    let mid = node    let fast = node.next    while (fast &amp;&amp; fast.next) &#123;      mid = mid.next      fast = fast.next.next    &#125;    let rightList = mid.next    mid.next = null    let left = node    let right = rightList    return mergeList(mergeSort(left), mergeSort(right))  &#125;  return mergeSort(head)&#125;\n当然归并排序比较复杂，链表排序方法中，容易理解以及使用的还有插入排序，这在leetocde-147.\n在数组中插入元素比较麻烦，但可以转化为元素互换，而在链表中插入是个比较容易的操作。所以插入排序很适用。这里直接贴题解代码：\n12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var insertionSortList = function(head) &#123;    // 边界条件    // 哨兵节点    let preHead = new ListNode(0);    // 将要移动重新插入链表中的元素    let curr = head;    // 插入链表中的前驱位置 插入pre和pre.next之间    let pre = preHead;    // 下一个将要移动插入的元素    let next = null;    // 遍历    while(curr)&#123;        // 保存下一个将要插入的元素        next = curr.next;        // 寻找插入的前驱位置        while(pre.next &amp;&amp; pre.next.val &lt; curr.val)&#123;            pre = pre.next;        &#125;        // 插入        curr.next = pre.next;        pre.next = curr;        // 从头或者从左到右开始遍历        pre = preHead;        // 下一个        curr = next;    &#125;    return preHead.next;&#125;;\n代码中有详细注释，就不用解释了。整体代码简洁，容易理解，可以更好的理解插入排序。\n","plink":"https://edsion11.github.io/2020/06/09/leeocde-链表排序/"},{"title":"JavaScript常用字符串以及数组处理函数2","date":"2020-06-05T10:24:49.000Z","date_formatted":{"ll":"Jun 5, 2020","L":"06/05/2020","MM-DD":"06-05"},"updated":"2022-01-22T09:45:40.641Z","content":"includes()\n判断数组是否包含一个值，返回true 或者 false\nindexOf()和lastIndexOf()\n返回给定元素的第一个索引和最后一个索引\npop()和push()\npop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。\npush() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。\npop(),push()具有通用性，可用call()或apply()用在类数组对象上(arguments)\nshift()和unshift()\nshift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。\nunshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。\nreduce()\nreduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\nreduce()的callback接受五个参数（前两个为必选，后三个可选参数）：\n\naccumulator累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue。\ncurrentValue数组中正在处理的元素。\nindex 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。\narray 调用reduce()的数组\ninitialValue 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。\n回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。\n\n 12345678910111213141516171819202122232425 var names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Tiff&#x27;, &#x27;Bruce&#x27;, &#x27;Alice&#x27;]; var countedNames = names.reduce(function (allNames, name) &#123;     if (name in allNames) &#123;         allNames[name]++;     &#125;     else &#123;         allNames[name] = 1;     &#125;     return allNames; &#125;, &#123;&#125;); console.log(names) console.log(countedNames) //数组去重 let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];let result = arr.sort().reduce((init, current) =&gt; &#123;    if(init.length === 0 || init[init.length-1] !== current) &#123;        init.push(current);    &#125;    return init;&#125;, []);console.log(result); //[1,2,3,4,5  //--还有按顺序运行Promise\nslice()\nslice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\nslice可以一般化用在类数组对象昂，即Array.prototype.slice.call(arguments)\nsplice()\nsplice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。\n1234567891011const months = [&#x27;Jan&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;June&#x27;];months.splice(1, 0, &#x27;Feb&#x27;);// inserts at index 1console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]months.splice(4, 1, &#x27;May&#x27;);// replaces 1 element at index 4console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;]\nsort()\n对数组进行排序\n默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var items = [    &#123; name: &#x27;Edward&#x27;, value: 21 &#125;,    &#123; name: &#x27;Sharpe&#x27;, value: 37 &#125;,    &#123; name: &#x27;And&#x27;, value: 45 &#125;,    &#123; name: &#x27;The&#x27;, value: -12 &#125;,    &#123; name: &#x27;Magnetic&#x27; &#125;,    &#123; name: &#x27;Zeros&#x27;, value: 37 &#125;];// sort by valueitems.sort(function (a, b) &#123;    return (a.value - b.value)&#125;);console.log(items)/** [  &#123; name: &#x27;The&#x27;, value: -12 &#125;,  &#123; name: &#x27;Edward&#x27;, value: 21 &#125;,  &#123; name: &#x27;Sharpe&#x27;, value: 37 &#125;,  &#123; name: &#x27;And&#x27;, value: 45 &#125;,  &#123; name: &#x27;Magnetic&#x27; &#125;,  &#123; name: &#x27;Zeros&#x27;, value: 37 &#125;]* */// sort by nameitems.sort(function(a, b) &#123;    var nameA = a.name.toUpperCase(); // ignore upper and lowercase    var nameB = b.name.toUpperCase(); // ignore upper and lowercase    if (nameA &lt; nameB) &#123;        return -1;    &#125;    if (nameA &gt; nameB) &#123;        return 1;    &#125;// names must be equal    return 0;&#125;);console.log(items)/*[  &#123; name: &#x27;And&#x27;, value: 45 &#125;,  &#123; name: &#x27;Edward&#x27;, value: 21 &#125;,  &#123; name: &#x27;Magnetic&#x27; &#125;,  &#123; name: &#x27;Sharpe&#x27;, value: 37 &#125;,  &#123; name: &#x27;The&#x27;, value: -12 &#125;,  &#123; name: &#x27;Zeros&#x27;, value: 37 &#125;]*/\ntoString()和join()\njoin() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。\ntoString() 返回一个字符串，表示指定的数组及其元素。\n两者区别不大，只是join()可以接受一个作为分隔符。\nString.prototype方法\nfromCharCode()\n静态 String.fromCharCode() 方法返回由指定的UTF-16代码单元序列创建的字符串。\ncharAt()\ncharAt() 方法从一个字符串中返回指定的字符。参数为下标\ncharCodeAt()\n返回指定下标出对应字符的UTF-16的编码值\nconcat()\nconcat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。\nmatch()\nmatch() 方法检索返回一个字符串匹配正则表达式的的结果。\n123456var str = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27;;var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]\nsubstring()\nsubstring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。\nreplace()\nreplace() 方法返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。\n原字符串不会改变。\n语法：str.replace(regexp|substr, newSubStr|function)\n\nregexp (pattern)一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。\nsubstr (pattern)一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。\nnewSubStr (replacement)用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。\nfunction (replacement)一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。\n\n1234567891011var str = &#x27;Twas the night before Xmas...&#x27;;var newstr = str.replace(/xmas/i, &#x27;Christmas&#x27;);console.log(newstr);  // Twas the night before Christmas...var re = /apples/gi;var str = &quot;Apples are round, and apples are juicy.&quot;;var newstr = str.replace(re, &quot;oranges&quot;);// oranges are round, and oranges are juicy.console.log(newstr);\nsearch()\nsearch() 方法执行正则表达式和 String 对象之间的一个搜索匹配。\n12345var str = &quot;hey JudE&quot;;var re = /[A-Z]/g;var re2 = /[.]/g;console.log(str.search(re)); // returns 4, which is the index of the first capital letter &quot;J&quot;console.log(str.search(re2)); // returns -1 cannot find &#x27;.&#x27; dot punctuation\ntrim()\ntrim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。\n1234567var orig = &#x27;   foo  &#x27;;console.log(orig.trim()); // &#x27;foo&#x27;// 另一个 .trim() 例子，只从一边删除var orig = &#x27;foo    &#x27;;console.log(orig.trim()); // &#x27;foo&#x27;\n","plink":"https://edsion11.github.io/2020/06/05/JavaScript常用字符串以及数组处理函数2/"},{"title":"javaScript常用字符串以及数组处理函数","date":"2020-05-28T21:37:39.000Z","date_formatted":{"ll":"May 28, 2020","L":"05/28/2020","MM-DD":"05-28"},"updated":"2022-01-22T09:45:40.642Z","content":"今天对javaScript常用的数组以及字符串函数做个总结\n数组函数\nArray.prototype.concat()(连接)\nconcat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n官网介绍的语法：var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])\n说明：concat方法创建一个新的数组，返回的是当前数组的一个浅拷贝，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。\n12345示例：let arr1 = [1,2,3]let arr2 = [2,3,4,[2,[3,4]]]let resultArr1 = arr1.concat(arr2)console.log(resultArr1)//[ 1, 2, 3, 2, 3, 4, [ 2, [ 3, 4 ] ] ]\nArray.prototype.every()和Array.prototype.some()\nevery() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。而some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。\n12345678910111213const array = [1, 2, 3, 4, 5];const even = (element) =&gt; element % 2 === 0;console.log(array.some(even));console.log(array.every(even))//true//falseconst arr = []console.log(arr.some(even));console.log(arr.every(even))//false//true注意：如果用一个空数组进行测试，some在任何情况下它返回的都是false。 every在任何情况下都返回true\nArray.prototype.fill()\nfill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。参数：value,start,end.\n12345678910111213let arr=[1,2,3,4]let obj=&#123;    a:1,    b:2&#125;let arr1 = arr.fill(obj,2,3)console.log(arr1)//当一个对象传给value时，填充数组的是这个对象的引用。obj.a=3console.log(arr1)//[ 1, 2, &#123; a: 1, b: 2 &#125;, 4 ]//[ 1, 2, &#123; a: 3, b: 2 &#125;, 4 ]\nArray.prototype.filter()\nfilter()字面意思就是过滤器，返回过滤后的数组元素，刚方法创建一个新数组，对原数组不做修改。接收参数和concat()相同，value:当前处理的元素，index,当前处理元素的index,array,调用filter()的函数本身。\n12345let arr=[1,2,3,4]let arr1 = arr.filter((value)=&gt;&#123;    return value&gt;=3&#125;)console.log(arr1)//[3,4]\nArray.prototype.find()和Array.prototype.findIndex()\nfind() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。\n1234567let arr=[1,2,3,4]console.log(arr.find(value=&gt;&#123;    return value&gt;=3&#125;))console.log(arr.findIndex(value=&gt;value&gt;=3))//3//2\nArray.prototype.flat()\nflat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。主要用处为数组扁平化，以及去除数组空值。该函数带有一个可选参数deep,默认为1.指定深度遍历的结构深度\n123456789101112const array=[1,2,[3,4,[5,[6,[[[[123,[2],[]]]]] ]]],3,4,5,6, , ,3]let array1 = array.flat(456)console.log(array1)//[1, 2, 3, 4, 5, 6,123, 2, 3, 4, 5, 6,3]MDN官网列出了几种替代方法，这里列出其中一个。有机会再总结数组扁平化的方法，以及手写个flatfunction flatDeep(arr, d = 1) &#123;    return d &gt; 0 ? arr.reduce((acc, val) =&gt; acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [])        : arr.slice();&#125;;let result = flatDeep(array, Infinity);console.log(result)\nArray.prototype.flatmap()和Array.prototype.map()\nflatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。它返回一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。\n12345let arr=[1,2,3,4]console.log(arr.map(x=&gt;[x*2]).flat())console.log(arr.map(x =&gt; [x * 2]));console.log(arr.flatMap(x =&gt; [x * 2]));console.log(arr.flatMap(x =&gt; [[x * 2]]));\n此外flatMap 能用于在map期间增删项目（也就是修改items的数量）。换句话说，它允许你遍历很多项使之成为另一些项（靠分别把它们放进去来处理），而不是总是一对一。 从这个意义上讲，它的作用类似于 filter的对立面。只需返回一个1项元素数组以保留该项，返回一个多元素数组以添加项，或返回一个0项元素数组以删除该项。\n12345678910// Let&#x27;s say we want to remove all the negative numbers and split the odd numbers into an even number and a 1let a = [5, 4, -3, 20, 17, -33, -4, 18]//       |\\  \\  x   |  | \\   x   x   |//      [4,1, 4,   20, 16, 1,       18]a.flatMap( (n) =&gt;  (n &lt; 0) ?      [] :  (n % 2 == 0) ? [n] :                 [n-1, 1])// expected output: [4, 1, 4, 20, 16, 1, 18]\n对于map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。\n以下列出map的常见用法\n12345678910111213首先是字符串引用let  a = Array.prototype.map.call(&quot;Hello World&quot;, function(x) &#123;    return x.charCodeAt(0);&#125;)console.log(a)//querySelector应用var elems = document.querySelectorAll(&#x27;select option:checked&#x27;);var values = Array.prototype.map.call(elems, function(obj) &#123;  return obj.value;&#125;);\nmap()中的坑点：\n123456789101112131415161718192021console.log([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt));//[1,NaN,NaN]//parseInt一般第一个参数是字符串，第二个参数是进制转换值//原因是parseInt 经常被带着一个参数使用, 但是这里接受两个。第一个参数是一个表达式而第二个是callback function的基,Array.prototype.map 传递3个参数，第三个参数被parseInt忽视了console.log([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;].map( str =&gt; parseInt(str) ));//[1,2,3]function returnInt(element) &#123;  return parseInt(element, 10);&#125;console.log([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;].map(returnInt));//[1,2,3]//当返回undefined 或没有返回任何内容时:var numbers = [1, 2, 3, 4];var filteredNumbers = numbers.map(function(num, index) &#123;  if(index &lt; 3) &#123;     return num;  &#125;&#125;);// filteredNumbers is [1, 2, 3, undefined]// numbers is still [1, 2, 3, 4]\nArray.prototype.forEach()\nforEach() 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162这里是一个使用thisArg的例子thisArg 参数（this）传给了 forEach()，每次调用时，它都被传给 callback 函数，作为它的 this 值。function Counter() &#123;  this.sum = 0;  this.count = 0;&#125;Counter.prototype.add = function(array) &#123;  array.forEach(function(entry) &#123;    this.sum += entry;    ++this.count;  &#125;, this);  // ^---- Note&#125;;const obj = new Counter();obj.add([2, 5, 9]);obj.count;// 3 === (1 + 1 + 1)obj.sum;// 16 === (2 + 5 + 9)复制对象function copy(obj) &#123;  const copy = Object.create(Object.getPrototypeOf(obj));  const propNames = Object.getOwnPropertyNames(obj);  propNames.forEach(function(name) &#123;    const desc = Object.getOwnPropertyDescriptor(obj, name);    Object.defineProperty(copy, name, desc);  &#125;);  return copy;&#125;const obj1 = &#123; a: 1, b: 2 &#125;;//如果数组在迭代时被修改了，则其他元素会被跳过。const obj2 = copy(obj1);var words = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;];words.forEach(function(word) &#123;  console.log(word);  if (word === &#x27;two&#x27;) &#123;    words.shift();  &#125;&#125;);// one// two// four还可以用作扁平化数组function flatten(arr) &#123;  const result = [];  arr.forEach((i) =&gt; &#123;    if (Array.isArray(i))      result.push(...flatten(i));    else      result.push(i);  &#125;)  return result;&#125;\n","plink":"https://edsion11.github.io/2020/05/28/javaScript常用字符串以及数组处理函数/"},{"title":"你不知道的JavaScript（一）","date":"2020-05-19T21:19:59.000Z","date_formatted":{"ll":"May 19, 2020","L":"05/19/2020","MM-DD":"05-19"},"updated":"2023-10-16T08:07:04.075Z","content":"1.1 编译原理\n\n\n分词/词法分析\n这个过程是将由字符组成的字符串分解成有意义的代码块\n例如 var x = 2分解为var ,x,= ,2,一个个的字符。\n分词和词法分析主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。\n\n\n解析/语法分析\n这个过程主要是将词法单元转换成一个由元素逐级嵌套组成的代表程序语法结构的树\n这个树叫做抽象语法树（AST）✔\n\n\n代码生成\n将上面生成的语法树解析为可执行代码的过程称为代码生成\n而 JavaScript 引擎要比上面复杂，JavaScript 是解释型语言，会存在性能问题，不过 Google 的 V8 引擎已经优化了很多，接近 C++/C 等语言了\n\n\n1.2 作用域\n简洁的来说就是代码可被访问到的区域\n比如声明var x = 2,用一段代码说明\n123456789101112//globalconsole.log(this) //指向空对象null，global是顶层作用域var x = 2function func1() &#123;  console.log(this) //指向global，指向上一层func1定义时所在的作用域  for (let i = 0; i &lt; 123; i++) &#123;    console.log(i) //这里是for循环的作用域  &#125;  console.log(i) //ReferenceError: i is not defined，这里访问不到let定义的块作用域，又称作用域死区  func2()&#125;func1()\n编译器（关于变量声明）\n这里有 LHS 和 RHS 查询，即左值查询与右值查询（右值在 C 语言是一个专业术语）这里不过多解释\n。这里 LHS 和 RHS 查询分别是对等号左右的值进行查询，例如var x = 2，编译器编译到这里会对 x 进 console.log(b)行 LHS 查询，如果在当前作用域没有查到，就会向上一层作用域继续查询，目的是为 2 找到一个赋值的目标，而console.log(b)则会进行 RHS 查询，目的是对console.log()引用地址的查询，找到 b 是谁，或者说在哪。如果 RHS 在所有的作用域中都没有找到所需要的变量，会抛出异常，是 ReferenceERROR 错误，引用错误。但是 LHS 如果在顶层作用域中也没找到变量时，则会创建一个该变量。（严格模式中会直接和 RHS 一样抛出错误）\n这里有一个隐式说明要注意：\n1234function foo(a)&#123;  console.log(a)&#125;foo(2)\n\n上面代码片段会有一次 LHS 查询，a=2,这是隐式的，可能会被忽略。\n词法作用域\n这里有两个关键词：\n\n词法化\n遮蔽效应\n词法作用域是由你在写代码时将变量和块作用域写在哪里决定的。\n遮蔽效应是如果在当前作用域和上一层作用域存在相同名称的变量，如果在当前作用域调用该变量，则当前作用域的变量会遮蔽外层作用域的变量\n\n1234567var a = 1function f1() &#123;  var a = 2 //这里如果注释掉，下面会输出1  console.log(a) // 2&#125;f1()\n在词法作用域中有两种欺骗词法：eval() 和 with()\n1234567function foo(str, a) &#123;  eval(str) //eval()将其中的参数会解析为js代码，并运行。  //严格模式中。eval()运行时有自己的词法作用域，这样其中的参数将不会修改所在的作用域  console.log(a, b)&#125;var b = 2foo(&#x27;var b=123&#x27;, 234) //\n还有 with()\n12345678910111213141516function foo(obj) &#123;  with (obj) &#123;    a = 2  &#125;&#125;var o1 = &#123;  a: 3,&#125;var o2 = &#123;  b: 3,&#125;foo(o1)console.log(o1.a)foo(o2)console.log(o2.a) //undefinedconsole.log(a) //2,a被泄露到全局作用域里了\nwith()可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域\n当我们给 with()传 o1 时，o1 内部有 a 属性，直接赋值，而传 o2 时，内部没有，则进行 LHS 查询到全局作用域赋值\n，with()实际是给传递给他的变量创造了一个新的词法作用域。\nthis\n常见 this 理解误区\n\n1.this 指向自身\n2.this 指向它的作用域（这种比较容易混淆，在某些状况是正确的，在其他状况是错误的）\n\nthis 绑定规则\n\n默认绑定\n\n12345function f1() &#123;  console.log(this.a)&#125;var a = 2f1() // 2\n\n隐式绑定\n\n12345678function f1() &#123;  console.log(this.a)&#125;var obj = &#123;  a: 2,  f2: f1,&#125;obj.f2()\n隐式绑定一个常见的问题是隐式绑定的函数会丢失绑定对象\n，会引用默认绑定\n1234567891011121314151617181920212223242526272829function foo() &#123;  console.log(this.a)&#125;var obj = &#123;  a: 3,  foo: foo,&#125;var bar = obj.fooa = &#x27;123&#x27;bar()//这里的参数传递其实就是一种隐式赋值。传入函数时也会被隐式赋值function foo() &#123;  console.log(this.a)&#125;function DoFoo(f) &#123;  f()  obj.foo()&#125;a = &#x27;123&#x27;obj = &#123;  a: 223,  foo: foo,&#125;obj.foo()DoFoo(obj.foo)\n还有一个问题是在回调函数中很容易出现 this 丢失的情况，而在一些回调函数中，还会出现修改 this 指向的情况\n判断 this 的优先级\n\n函数是否在 new 中调用，(new 绑定)？如果是的话 this 绑定的是新创建的对象\nvar bar = new foo()\n函数是否通过 call()，apply()或者硬绑定调用？如果是的话，this 绑定的是指定的对象\nvar bar =foo.call(obj)\n函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象\nvar bar = obj1.foo()\n如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到 undefined，负责绑定到全局对象。\nvar bar = foo()\n\n被忽略的 this\n如果 call(),apply(),bind()，第一个参数传入的是 null 或者 undefined，那么实际绑定为默认绑定，常见的一种做法是用 apply(null,[…])，但是总是使用null有时会产生不必要的效果，比如 this 指向了全局作用域，这样会在不知不觉中修改了全局变量，一种安全的 this 做法是，利用object.create(null)创建一个空对象来作为 this 指向。\n间接引用\n123456789101112131415function foo() &#123;  console.log(this.a)&#125;var o1 = &#123;  a: 1,&#125;var o2 = &#123;  a: 3,  foo: foo,&#125;var o3 = &#123;  a: 4,&#125;o2.foo() //3;(o3.foo = o2.foo)() //undefined\n赋值表达式 o3.foo=o2.foo 返回值是目标函数的引用，因此调用位置是 foo()而不是 o3.foo(),于是会用默认绑定，绑定到全局作用域，而全局作用域没有定义a，输出 undefined。\nthis 词法\n上面是正常函数定义function()&#123;&#125;，而 ES6 中提出新的定义函数方式：箭头函数，箭头函数 this 指向有外层作用域来决定，来看一段代码。\n12345678910111213function foo() &#123;  return (a) =&gt; &#123;    console.log(this.a)  &#125;&#125;var obj1 = &#123;  a: 2,&#125;var obj2 = &#123;  a: 3,&#125;var bar = foo.call(obj1)bar.call(obj2) //2\nfoo 内部 return 的箭头函数，this 调用时会捕获 foo()的 this，而 foo 的 this 绑定到来 obj1，所以 bar 的 call()无效了。\n","plink":"https://edsion11.github.io/2020/05/19/你不知道的JavaScript（一）/"},{"title":"Promise和Observable区别","date":"2020-05-12T11:32:27.000Z","date_formatted":{"ll":"May 12, 2020","L":"05/12/2020","MM-DD":"05-12"},"updated":"2022-01-22T09:45:40.641Z","content":"最近学 Angular 看大漠老师的视频看到了 Observable 这块，Observable 是 Rxjs 库里异步编程核心的一部分，相比于 Rxjs 又有那些区别呢\nObservable 介绍\nRxJS 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 Observable，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。 ————引用 Rxjs 中文网站的介绍 ——Rxjs 官网\nObservable（可观察对象）\n这里具体原理可参照 JavaScript 设计模式–观察，订阅模式\n\n在 RxJS 中用来解决异步事件管理的的基本概念是：\n-Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。\nObserver (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。\nSubscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。\nOperators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。\nSubject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。\nSchedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其\n\n使用 Observable\n123456789//Observable写法import &#123; Observable &#125; from &#x27;rxjs&#x27;//创建一个Observable对象let Ob1 = new Observable((observer) =&gt; &#123;  observer.next(&#x27;observable&#x27;)&#125;)Ob1.subscribe((value) =&gt; &#123;  console.log(value)&#125;)\n使用 Promise\n1234567let Pro1 = new Promise((resolve,reject)=&gt;&#123;  resolve(1)  //reject(2)&#125;Pro1.then(value=&gt;&#123;  console.log(value)&#125;)\nObservable 与函数\n12345678910111213141516171819202122232425262728293031function foo() &#123;  console.log(&#x27;Hello&#x27;);  return 42;&#125;var x = foo.call(); // 等同于 foo()console.log(x);var y = foo.call(); // 等同于 foo()console.log(y);//&quot;Hello&quot;//42//&quot;Hello&quot;//42//用 Observables 重写上面的代码：var foo = Rx.Observable.create(function (observer) &#123;  console.log(&#x27;Hello&#x27;);  observer.next(42);&#125;);foo.subscribe(function (x) &#123;  console.log(x);&#125;);foo.subscribe(function (y) &#123;  console.log(y);&#125;);//&quot;Hello&quot;//42//&quot;Hello&quot;//42//\n因为函数和 Observables 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observables 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observables 与之相反，不会共享副作用并且是延迟执行。\n区别\n为什么用 Rxjs\npromise 相较于 Rxjs 而言功能更单一 promise 只能将一个数据的状态由 pending 转换成 resoloved 或者 rejected.而 Rxjs 可以处理多个数据对应 complete 和 error 状态但是 Rxjs 同时又拥有 next 方法。Observable 是惰性的，需要 subscribe 的时候才输出值。promise 内部状态是不可控制的，执行了就无法终止。而 Observable 可以定义如何取消异步方法。\n比如如下的场景：\n输入框中输入字符，按回车发送一个请求，并将返回的结果变成一个 Todo item。如果在请求返回结果前又一次按下回车或 add 按钮，如果相同则不进行任何操作，如果不同则取消掉上次的请求并发送新的请求。（实际的场景往往是发送个 http 请求该请求会返回的很慢，业务上加上心跳检查（发送方按照一定规则（周期性发送、空闲发送等等）向接收方发送固定格式的消息，接受方收到消息后回复一个固定格式的消息，如果长时间没有收到，比如心跳周期的 3 倍，则认为当前连接失效，将其断开。），如果前一次在心跳间隔内无返回则再次调用请求，同时需要抛弃前一次请求的返回，并且此时有可能调用参数不一样的该接口从而造成数据不一致的问题）对于 Promise 实现我们不只要维护一个定时器 timer 同时还要维护一个全局变量。\n再比如我们需要监听页面滚动的事件，作出一些逻辑操作，这是就会产生事件过于频繁的调用，造成页面卡顿的现象。用原生 js 实现的时候，需要实现个节流或者防抖函数，通过实现个闭包函数，在内部维护个定时器。而在 Rxjs 中通过操作符 debounce 就可以方便的解决\n同步与异步\n首先第一个区别是：Promise 是解决异步编程的方法，而 Observable 可以同步也可以异步\n12345678910111213141516171819202122232425262728293031323334353637//Observable同步执行var foo = Rx.Observable.create(function (observer) &#123;  console.log(&#x27;Hello&#x27;)  observer.next(42)  observer.next(100) // “返回”另外一个值  observer.next(200) // 还可以再“返回”值&#125;)console.log(&#x27;before&#x27;)foo.subscribe(function (x) &#123;  console.log(x)&#125;)/*&quot;before&quot;&quot;Hello&quot;42100200&quot;after&quot;*/console.log(&#x27;after&#x27;)const Observable = require(&#x27;rxjs/Observable&#x27;).Observable;const observable = new Observable((observer) =&gt; &#123;    // observer.next(5);    setTimeout(() =&gt; &#123;        observer.next(5);    &#125;)&#125;);observable.subscribe(value =&gt; console.log(value + &#x27;!&#x27;));console.log(&#x27;And now we are here.&#x27;);//这个如果是直接next 5,则输出是  5！ -&gt; And now we are here.采用setTimeout next 5， 则相反  And now we are here.-&gt; 5\n单个值和多个值\nObservable 里面的 next()方法类似与 Promise.resolve(),但是 Promise()内部的 resolve()方法成功后，后面的不会执行，就是说 Observable 可以持续发射很多值，而 Promise 只能发射一个值就结束了\n123456const promise1 = new Promise((resolve) =&gt; &#123;  console.log(&#x27; I am promise &#x27;)&#125;)const observable1 = new Observable(() =&gt; &#123;  console.log(&#x27;I am Observable!&#x27;)&#125;)\nPromise 里的 console.log 会执行，而 Observable 里的代码不会输出，只有订阅（subscribe）之后才会输出\n异步执行任务的取消\nPromise 的执行默认是不可取消的，而 Observable 是可以通过 subscribe 的 unsubscribe()方法来取消\n因为在 Promise 中.then()返回的是一个新的 Promise 对象，而 Observable+subscribe 返回的是 subscription 对象\n12345678910111213141516171819202122232425const Observable = require(&#x27;rxjs/Observable&#x27;).Observable;const observable = new Observable((observer) =&gt; &#123;    let i = 0;    const token = setInterval(() =&gt; &#123;        observer.next(i++);    &#125;, 1000);    return () =&gt; clearInterval(token);&#125;);const subscription = observable.subscribe(value =&gt; console.log(value + &#x27;!&#x27;));setTimeout(() =&gt; &#123;    subscription.unsubscribe();&#125;, 5000)// 结果0!1!2!3!//Observable\n一次和多次执行\nPromise 只会执行一次 resolve(),而 Observable 每次订阅都会执行一次观察对象中的代码\n1234567891011121314151617181920212223242526272829303132333435363738394041//Promiselet time;const waitOneSecondPromise = new Promise((resolve) =&gt; &#123;    console.log(&#x27;promise call&#x27;)    time = new Date().getTime();    setTimeout(() =&gt; resolve(&#x27;hello world&#x27;), 1000);&#125;);waitOneSecondPromise.then((value) =&gt; &#123;console.log( &#x27;第一次&#x27;, value, new Date().getTime() - time)&#125;);setTimeout(() =&gt; &#123;    waitOneSecondPromise.then((value) =&gt; &#123;console.log(&#x27;第二次&#x27;, value, new Date().getTime() - time)&#125;);&#125;, 5000)// 输出结果是 promise call第一次 hello world 1007第二次 hello world 5006//Observableconst Observable = require(&#x27;rxjs/Observable&#x27;).Observable;let time;const waitOneSecondObservable = new Observable((observer) =&gt; &#123;    console.log(&#x27;I was called&#x27;);    time = new Date().getTime();    setTimeout(() =&gt; observer.next(&#x27;hey girl&#x27;), 1000);&#125;);waitOneSecondObservable.subscribe((value) =&gt; &#123;console.log( &#x27;第一次&#x27;, value, new Date().getTime() - time)&#125;);setTimeout(() =&gt; &#123;    waitOneSecondObservable.subscribe((value) =&gt; &#123;console.log( &#x27;第二次&#x27;, value, new Date().getTime() - time)&#125;);&#125;, 5000)// 输出I was called第一次 hey girl 1003I was called第二次 hey girl 1003\n工具\nObservable 提供了很多的工具函数，常用的 filter 和 map 演示如下\n12345678910111213141516171819let stream2$ =  new Observable() &lt;  number &gt;  ((observer) =&gt; &#123;    let count = 0    let interval = setInterval(() =&gt; &#123;      observer.next(count++)    &#125;, 1000)    return () =&gt; &#123;      clearInterval(interval)    &#125;  &#125;)stream2$.subscribe((value) =&gt; console.log(&#x27;Observable&gt;&#x27; + value))stream2$  .pipe(filter((val) =&gt; val % 2 == 0))  .subscribe((value) =&gt; console.log(&#x27;filter&gt;&#x27; + value))stream2$  .pipe(map((value) =&gt; value * value))  .subscribe((value) =&gt; console.log(&#x27;map&gt;&#x27; + value))\n总结\n\nObservable 是 lazy 的，只有订阅才输出，同时 Observable 可以接受多个值。Promise 只能 resolve 一次。\nPromise 内部 resolve 一定是异步的，而 Observable 则可以自由发挥\nPromise 只会执行一次，创建之后就会执行，不能重复执行，而 Observable 每订阅一次会执行一次，而如果想只执行一次，可以利用 share。\nPromise 不可以取消，而 Observable 可以取消\n\n","plink":"https://edsion11.github.io/2020/05/12/Promise和Observable区别/"},{"title":"Promise从入门到放弃","date":"2020-04-28T23:34:41.000Z","date_formatted":{"ll":"Apr 28, 2020","L":"04/28/2020","MM-DD":"04-28"},"updated":"2022-01-22T09:45:40.641Z","content":"Promise 从入门到放弃\njavascript 异步操作执行历史\nJavaScript 语言的执行环境是“单线程”， 所谓单线程，就是一次只能完成一件任务， 如果有多个任务就需要排队，一个完成了，继续下一个，这种方式在实现来说是非常简单的，但是如果一个任务耗时很长，那么后面的任务就需要排队等着，会拖延整个程序的执行。 常见的浏览器无响应（假死）就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡死，其他任务无法执行。\njavascript 异步操作的类型\n\n回调函数\n事件监听\n发布/订阅\npromise\ngenerator（ES6）\nasync/await （ES7）\n\n回调函数\n\n同步回调\n立即执行，完全执行完之后才结束，不会放入回调队列\nexample : Promise(()=&gt;{}) 数组的 forEach()\n异步回调\nsetTimeout((()=&gt;{}))\n\n12345var arr = [1, 1, 1]arr.forEach((value) =&gt; &#123;  console.log(value)&#125;)console.log(&#x27;over&#x27;)\n\n\n异步回调\n进入回调队列，等待执行\n\n\n回调函数\n\n\n123456789101112131415161718function f1(func) &#123;  setTimeout(() =&gt; &#123;    console.log(&#x27;我是f1&#x27;)    for (let i = 1; i &lt; 50000; i++) &#123;      console.log(&#x27;我是f1的&#x27; + i)    &#125;    func(Zz)  &#125;, 500)&#125;function f2() &#123;  alert(&#x27;我是f2&#x27;)&#125;function f3() &#123;  alert(&#x27;我是f3&#x27;)&#125;f1(f2) //这里f1(),f2()不会阻塞f3()的运行f3()\n这里主要利用setTimeout()函数来进行异步操作，f3()的执行不会受到f1()影响。主要是因为setTimeout()是异步函数。\n\n为什么要用 Promise\n\n1.指定回调函数的而方式更加灵活\n2.支持链式调用，可解决回调地狱问题\n回调地狱就是传统的回调函数嵌套所产生的问题，不利于阅读，不利于异常处理，解决方案有 Promise 链式调用以及最新的 async 和 await\n\n\n\nPromise\n\nPromise 是 ES6 中提出的新的异步编程解决方案\n语法上来看：Promise 是一个构造函数\n功能上来看；Promise 对象用来封装了一个异步操作并可以获取其结果\nPromise 状态\npending 状态–&gt;初始状态\nfullFilled 状态–&gt;对应 Promise 内函数执行成功–&gt;对应 resolve(params)\nrejected 状态–&gt;对应 Promise 内函数执行失败或抛出异常–&gt;对应 reject(params)\nPromise 执行流程\n\n\n如何改变 promise 的状态\n123resolve(value)//---pedding-&gt;fullfilledreject(reason)//---pedding-&gt;rejectedthrow //抛出异常，rejected，reason为throw的值\n定义两个 then()，都会输出\npromise 状态的改变和 then 回调函数的执行\n123456789101112131415161718192021222324252627282930313233343536373839//先指定回调函数，在改变状态new Promise((resolve, reject) =&gt; &#123;  //这里是同步执行  console.log`先指定回调函数，在改变状态`  setTimeout(() =&gt; &#123;    resolve(1) //再改变pedding状态，同时改变数据  &#125;, 1000)&#125;).then((value) =&gt; &#123;  //先指定回调函数  console.log(&#x27;value1----&gt;&#x27; + value)&#125;)//先改变状态，再指定函数//第一种，去掉异步的定时器new Promise((resolve, reject) =&gt; &#123;  console.log`//先改变状态，再指定函数`  resolve(2)&#125;).then((value) =&gt; &#123;  console.log(&#x27;value2---&gt;&#x27; + value)&#125;)//第二种都设置定时器const p3 = new Promise((resolve, reject) =&gt; &#123;  console.log`//先改变状态，再指定函数`  setTimeout(() =&gt; &#123;    resolve(3)  &#125;, 1000)&#125;)setTimeout(() =&gt; &#123;  p3.then((value) =&gt; &#123;    console.log(&#x27;value3---&gt;&#x27; + value)  &#125;)&#125;, 1200)/*输出：[ &#x27;先指定回调函数，在改变状态&#x27; ][ &#x27;//先改变状态，再指定函数&#x27; ][ &#x27;//先改变状态，再指定函数&#x27; ]value2---&gt;2value1----&gt;1value3---&gt;3*/\nPromise.all() 和 Promise.race()\n\nPromise.all()\nPromise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。\nPromise.race()\nPromise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。\n\nPromise 值穿透问题\n\n.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。\n\n123456789101112Promise.resolve(&#x27;foo&#x27;)  .then(Promise.resolve(&#x27;bar&#x27;))  .then(function (result) &#123;    console.log(result) //foo  &#125;)//-----------------------------Promise.resolve(1)  .then(function () &#123;    return 2  &#125;)  .then(Promise.resolve(3))  .then(console.log) //2\n\n异常穿透\n(1)当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,\n(2)前面任何操作出了异常, 都会传到最后失败的回调中处理\n\n中断 promise 链\n(1)当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数\n(2)办法: 在回调函数中返回一个 pendding 状态的 promise 对象\n手写 Promise 对象\n已上传到 GIthub 手写 Promise(ES5).\nasync 和 await\n\nasync 函数\n函数的返回值为 Promise 对象\nPromise 对象的结果由 async 函数执行的返回值决定\nawait 函数\nawait 右侧的表达式一般为 Promise 对象，但也可以是其他值\n如果表达式是 Promise 对象，await 返回 Promise 成功的值\n如果为其他值，则直接作为 await 的返回值\n注意\nawait 必须写在 async 函数中，但 async 函数中可以没有 await\nawait 的 Promise 对象失败，会抛出异常，用 try…catch 捕获异常 🍎\n\n宏队列 和 微队列\n\n宏队列\nDOM 事件回调 Ajax 回调 定时器回调\n微队列\nMutation() Promise()1234567891011121314151617181920212223242526&lt;script&gt;  //微队列优先级高  setTimeout(() =&gt; &#123;    //立即进入宏队列    console.log(&#x27;timeout1&#x27;)    Promise.resolve(2).then((value) =&gt; &#123;      console.log(&#x27;setTimeout的Promise1&#x27; + value)    &#125;)  &#125;, 0)  setTimeout(() =&gt; &#123;    //立即进入宏队列    console.log(&#x27;timeout2&#x27;)    /*      每次准备取出一个宏队列的任务时，都会先执行所有的微任务      */    Promise.resolve(2).then((value) =&gt; &#123;      console.log(&#x27;setTimeout的Promise2&#x27; + value)    &#125;)  &#125;, 0)  Promise.resolve(1).then((value) =&gt; &#123;    //立即进入微队列    console.log(&#x27;Promise onResolved&#x27; + value)  &#125;)  //Promise onResolved 1.  //timeout&lt;/script&gt;\n\n\n","plink":"https://edsion11.github.io/2020/04/28/Promise从入门到放弃/"},{"title":"动态规划","date":"2020-04-24T14:12:11.000Z","date_formatted":{"ll":"Apr 24, 2020","L":"04/24/2020","MM-DD":"04-24"},"updated":"2022-01-22T09:45:40.643Z","content":"动态规划的问题总结如下：\n1.斐波那契数列引入动态规划问题\n\n使用动态规划思想解决问题的起点是，通过分解目标问题，得到要解决目标问题的子问题。通过对子问题的求解，继而求解其他更加复杂的子问题(包括“最终问题”)。类似递归的逆过程，“递归”是自顶向下的循环求解思想，而“动态规划”是自下而上的求解思想，从子问题向上求解。\n下面三个例子都是动态规划的经典问题：\n1.求解最长公共子串\n题目：给定两个字符串  text1 和  text2，返回这两个字符串的最长公共子序列的长度。\n一个字符串的   子序列   是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。\n若这两个字符串没有公共子序列，则返回 0。\n示例 1\n123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;输出：3解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。\n思路为动态规划，使用一个二维数组存储两个字符串相同\n位置的字符比较结果。初始化时，该数组的每一个元素被设置为 0。每次在这两个数组的\n相同位置发现了匹配，就将数组对应行和列的元素加 1，否则保持为 0。\n按照这种方式，一个变量会持续记录下找到了多少个匹配项。当算法执行完毕时，这个变\n量会结合一个索引变量来获得最长公共子串。\n代码如下：\n123456789101112131415161718192021/** * @param &#123;string&#125; text1 * @param &#123;string&#125; text2 * @return &#123;number&#125; */var longestCommonSubsequence = function (text1, text2) &#123;  let n = text1.length  let m = text2.length  let dp = Array.from(new Array(n + 1), () =&gt; new Array(m + 1).fill(0))  //这里用到了ES6的新Array方法from,实现一个浅拷贝，向数组赋值0，  for (let i = 1; i &lt;= n; i++) &#123;    for (let j = 1; j &lt;= m; j++) &#123;      if (text1[i - 1] == text2[j - 1]) &#123;        dp[i][j] = dp[i - 1][j - 1] + 1      &#125; else &#123;        dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j])      &#125;    &#125;  &#125;  return dp[n][m]&#125;\n下面有两道题用到了动态规划，当然也有别的方法，此处只是对动态规划进行应用与演示.\n2.leetcode-62-不同路径 I\n1234输入: m = 3, n = 2输出: 3解释: 从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下 2. 向右 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向右\n123456789101112131415161718192021/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var uniquePaths = function (m, n) &#123;  var dp = new Array(m)  for (let i = 0; i &lt; m; i++) &#123;    dp[i] = new Array(n)  &#125;  for (let i = 0; i &lt; m; i++) &#123;    for (let j = 0; j &lt; n; j++) &#123;      if (i == 0 || j == 0) &#123;        dp[i][j] = 1      &#125; else &#123;        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]      &#125;    &#125;  &#125;  return dp[m - 1][n - 1]&#125;\n3.leetcode-63-不同路径 II(障碍物)\n12345输入: [   [0,0,0],   [0,1,0],   [0,0,0] ]输出: 2解释: 3x3网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -&gt;向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右\n12345678910111213141516171819202122232425262728293031323334/** * @param &#123;number[][]&#125; obstacleGrid * @return &#123;number&#125; */var uniquePathsWithObstacles = function (obstacleGrid) &#123;  var n = obstacleGrid.length  var m = obstacleGrid[0].length  var dp = new Array(n)  for (var i = 0; i &lt; n; i++) &#123;    dp[i] = new Array(m).fill(0)  &#125;  dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0  if (dp[0][0] == 0) &#123;    return 0  &#125;  for (var j = 1; j &lt; m; j++) &#123;    if (obstacleGrid[0][j] != 1) &#123;      dp[0][j] = dp[0][j - 1]    &#125;  &#125;  for (var r = 1; r &lt; n; r++) &#123;    if (obstacleGrid[r][0] != 1) &#123;      dp[r][0] = dp[r - 1][0]    &#125;  &#125;  for (var i = 1; i &lt; n; i++) &#123;    for (var r = 1; r &lt; m; r++) &#123;      if (obstacleGrid[i][r] != 1) &#123;        dp[i][r] = dp[i - 1][r] + dp[i][r - 1]      &#125;    &#125;  &#125;  return dp[n - 1][m - 1]&#125;\n","plink":"https://edsion11.github.io/2020/04/24/动态规划/"},{"title":"箭头函数","date":"2020-04-21T11:55:51.000Z","date_formatted":{"ll":"Apr 21, 2020","L":"04/21/2020","MM-DD":"04-21"},"updated":"2022-01-22T09:45:40.644Z","content":"箭头函数\n箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n例\n123const materials = [&#x27;Hydrogen&#x27;, &#x27;Helium&#x27;, &#x27;Lithium&#x27;, &#x27;Beryllium&#x27;]console.log(materials.map((material) =&gt; material.length))// expected output: Array [8, 6, 7, 9]\n基础语法\n12345678910(param1, param2, …, paramN) =&gt; &#123; statements &#125;(param1, param2, …, paramN) =&gt; expression//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;// 当只有一个参数时，圆括号是可选的：(singleParam) =&gt; &#123; statements &#125;singleParam =&gt; &#123; statements &#125;// 没有参数的函数应该写成一对圆括号。() =&gt; &#123; statements &#125;\n高级语法\n1234567891011//加括号的函数体返回对象字面量表达式：params =&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(param1, param2, ...rest) =&gt; &#123; statements &#125;(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123;statements &#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f();  // 6\n引入箭头函数主要有两个方面的作用:更简短的函数而且不绑定 this\n箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的 this 与封闭函数中的this值相同：\n12345678function Person() &#123;  this.age = 0  setInterval(() =&gt; &#123;    this.age++ // |this| 正确地指向 p 实例  &#125;, 1000)&#125;var p = new Person()\n通过call和apply调用\n由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定 this），他们的第一个参数会被忽略。\n1234567891011121314151617181920var adder = &#123;  base : 1,  add : function(a) &#123;    var f = v =&gt; v + this.base;    return f(a);  &#125;,  addThruCall: function(a) &#123;    var f = v =&gt; v + this.base;    var b = &#123;      base : 2    &#125;;    return f.call(b, a);  &#125;&#125;;console.log(adder.add(1));         // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2\n使用箭头函数作为方法\n箭头函数作为方法时，由于没有定义this绑定，方法里指向里上一个作用链的作用域。下面是例子中指向的是全局作用域。\n12345678910111213141516171819202122232425//使用箭头函数作为方法var obj = &#123;  a: 1,  b: () =&gt; &#123;    console.log(this.a, this)  &#125;,  c: function () &#123;    console.log(this.a, this)  &#125;,&#125;//obj.b() //undefined &#123;&#125;//上面是在node环境下运行的，在浏览器环境下运行会输出：undefined,window//obj.c() //1 &#123;a:1.b:[Function:b],c:[Function:c]&#125;Object.defineProperty(obj, &#x27;b&#x27;, &#123;  get: () =&gt; &#123;    console.log(this.a, typeof this.a, this)    return this.a++  &#125;,&#125;)//obj.b //undefined &#x27;undefined&#x27; &#123;&#125;//箭头函数不能用作构造器，和new一起用会报错/*(var Foo = () =&gt; &#123;&#125;var f = new Foo()*///箭头函数也没有prototype属性，同样报错//箭头函数不能用作函数生成器。\n还有几点注意：\n\n箭头函数返回子面量对象时要加括号（这是因为花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。）\n箭头函数的作用域注意，是局部作用域\n\n1234567891011121314151617181920212223242526272829// 常规写法var greeting = () =&gt; &#123;  let now = new Date()  return &#x27;Good&#x27; + (now.getHours() &gt; 17 ? &#x27; evening.&#x27; : &#x27; day.&#x27;)&#125;greeting() //&quot;Good day.&quot;console.log(now) // ReferenceError: now is not defined 标准的let作用域// 参数括号内定义的变量是局部变量（默认参数）var greeting = (now = new Date()) =&gt;  &#x27;Good&#x27; + (now.getHours() &gt; 17 ? &#x27; evening.&#x27; : &#x27; day.&#x27;)greeting() //&quot;Good day.&quot;console.log(now) // ReferenceError: now is not defined// 对比：函数体内&#123;&#125;不使用var定义的变量是全局变量var greeting = () =&gt; &#123;  now = new Date()  return &#x27;Good&#x27; + (now.getHours() &gt; 17 ? &#x27; evening.&#x27; : &#x27; day.&#x27;)&#125;greeting() //&quot;Good day.&quot;console.log(now) // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)// 对比：函数体内&#123;&#125; 用var定义的变量是局部变量var greeting = () =&gt; &#123;  var now = new Date()  return &#x27;Good&#x27; + (now.getHours() &gt; 17 ? &#x27; evening.&#x27; : &#x27; day.&#x27;)&#125;greeting() //&quot;Good day.&quot;console.log(now) // ReferenceError: now is not defined\n上面是 MDN 的例子。\n\n同样的箭头函数还可以使用闭包和递归\n\n2020/4/25 补充\n箭头函数与匿名函数的区别\n\n\nthis 指向区别\n\n箭头函数根据所在的环境（我在哪个环境中，this 就指向谁），Arrow functions bind the parent context。按照词法作用域绑定 this\n匿名函数中 this 指向 window\n\n\n\n使用箭头函数注意几点\n\n\n1、函数体内的 this 对象就是定义时所在的对象，而不是使用时所在对象；\n\n\n2、不可以当作构造函数使用，也就是不能用 new 命令实例化一个对象，否则会抛出一个错误；\n\n\n3、不可以使用 arguments 对象，该对象在函数体内不存在，如果要用的话，可以用 rest 参数代替；\n\n\n4、不可以使用 yield 命令，箭头函数不能用作 Generator 函数；\n\n\n","plink":"https://edsion11.github.io/2020/04/21/箭头函数/"},{"title":"leetcode-21-合并两个有序链表","date":"2020-04-20T15:27:03.000Z","date_formatted":{"ll":"Apr 20, 2020","L":"04/20/2020","MM-DD":"04-20"},"updated":"2022-01-22T09:45:40.642Z","content":"题目\n将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例\n12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n看到这道题第一个思路就是遍历其中一个链表，依次插入另一个链表。这个方法在官方解释为“迭代法”。\n即我们假设l1元素严格比l2元素少，我们可以将l2中的元素逐一插入l1中正确的位置。\n算法思路\n首先建立一个新链表，指向空，接着建立一个“哨兵节点”prevNode用于不断next下一个添加新元素。重复遍历判断l1和l2的值，两者较小值插入，然后prevNode.next。一直到最后其中一个链表到达尾部指向 null,此时另一个链表剩余值一定比目前这个值大，所以直接连接在prevNode后面即可。具体实现如下：\n12345678910111213141516var mergeTwoLists = function (l1, l2) &#123;  var prevHead = new ListNode(-1)  var prevNode = prevHead  while (l1 != null &amp;&amp; l2 != null) &#123;    if (l1.val &lt;= l2.val) &#123;      prevNode.next = l1      l1 = l1.next    &#125; else &#123;      prevNode.next = l2      l2 = l2.next    &#125;    prevNode = prevNode.next  &#125;  prevNode.next = l1 ? l1 : l2  return prevHead.next&#125;\n另一种方法是用递归方法，递归思想：递归的定义操作merge,比较两个链表头部较小的一个与剩下元素的merge操作结果合并。\n递归算法思路\n先判断递归终值，即判断l1 ,l2为null的时候，return的值。递归内容：如果l1的val值更小，则将l1.next与排序好的链表头相接，l2同理。\n具体实现如下\n123456789101112131415var mergeLists = function (l1, l2) &#123;  if (l1 === null) &#123;    return l2  &#125;  if (l2 === null) &#123;    return l1  &#125;  if (l1.val &lt; l2.val) &#123;    l1.next = mergeLists(l1.next, l2)    return l1  &#125; else &#123;    l2.next = mergeLists(l1, l2.next)    return l2  &#125;&#125;\n","plink":"https://edsion11.github.io/2020/04/20/leetcode-21-合并两个有序链表/"},{"title":"webpack打包","date":"2020-04-19T12:21:16.000Z","date_formatted":{"ll":"Apr 19, 2020","L":"04/19/2020","MM-DD":"04-19"},"updated":"2022-01-22T09:45:40.643Z","content":"webpack\nwebpack 是一个打包工具，可以通过 npm 下载安装：npm install -g webpack来安装。\n原因\n我们在构建网站时，在 &lt;script&gt; 或者&lt;link&gt;标签中会引入静态资源文件。\n常见的静态资源\n\n.js .jsx .coffee .ts(typescript)\ncss\nimages\n字体文件\n模板文件\n\n这些静态文件是我们经常需要引用的，但是浏览器解析渲染时，如果静态资源太多，会加载变慢。还有许多依赖关系也会影响。\n解决问题就是：\n\n合并，压缩\n图片的 base64 编码\n使用 requireJS,也可用 webpack 解决依赖关系\nGulp 是基于 task 的解决方案\nwebpack 是基于项目的解决方案\n\n初次使用 webpack\nhtml 的隔行变色\n首先是构建一个项目目录：\n\ndist （webpack 打包后的文件目录）\nsrc （html,css,js 文件）\nnode_modules（npm 引入的库文件）\npackage.json （npm init）\n\n先建立 index.html\n123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=/, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;!--下面的script标签是在webpack打包之后引入的文件--&gt;    &lt;script src=&quot;../dist/main.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;ul&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;      &lt;li&gt;我是一个标签&lt;/li&gt;    &lt;/ul&gt;  &lt;/body&gt;&lt;/html&gt;\nsrc&gt;main.js\n12345import $ from &#x27;jquery&#x27;$(function () &#123;  $(&#x27;li:odd&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;lightblue&#x27;)  $(&#x27;li:even&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;lightyellow&#x27;)&#125;)\n先在 dist 目录下创建 main.js 文件\n接着在项目目录下面执行webpack ./src/main.js ./dist/main.js 就会生成 main.js 文件，运行～，成功！\n具体可见webpack 官网\n后续再补充！\n","plink":"https://edsion11.github.io/2020/04/19/webpack打包/"},{"title":"Vue双向绑定","date":"2020-04-08T14:27:04.000Z","date_formatted":{"ll":"Apr 8, 2020","L":"04/08/2020","MM-DD":"04-08"},"updated":"2022-01-22T09:45:40.642Z","content":"Vue的双向绑定是v-model指令\n具体的实现原理是用了js中的Object.defineProperty方法来修改目标对象的属性\n\n先看看Vue中源码中的解释:\n源码地址\n1.使Object数据变得可侦测 \n数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。\n要将数据变的‘可观测’，我们就要借助前言中提到的Object.defineProperty方法了，在本文中，我们就使用这个方法使数据变得“可观测”。\n12345678910111213var Obj = &#123;  val: &#x27;hello&#x27;,&#125;Object.defineProperty(Obj, &#x27;val&#x27;, &#123;  get: function () &#123;    console.log(&#x27;数据已读取&#x27;)  &#125;,  set: function () &#123;    console.log(&#x27;数据已修改&#x27;)  &#125;,&#125;)Obj.valObj.val = &#x27;123&#x27;\n上面是创建一个对象Obj，然后读取和赋值，下面是输出结果\n123数据已读取数据已修改[Done] exited with code=0 in 0.118 seconds\n上面是Object.defineProperty方法对数据进行观测拦截，每当该属性进行读或写操作的时候就会触发get()和set(),这样的方法在原来html页面进行简单的双向绑定，大型项目会很复杂，Vue框架的双向绑定引入观测模式，封装在index.js中，就是Vue的双向绑定。\n```javascript\nObserver类会通过递归的方式把一个对象的所有属性都转化成可观测对象\nexport class Observer {\n  constructor (value) {\n    this.value = value\n    // 给value新增一个__ob__属性，值为该value的Observer实例\n    // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作\n    def(value,'__ob__',this)\n    if (Array.isArray(value)) {\n      // 当value为数组时的逻辑\n      // ...\n    } else {\n      this.walk(value)\n    }\n  }\n   walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n}\n* 使一个对象转化成可观测对象\n * @param { Object } obj 对象\n * @param { String } key 对象的key\n * @param { Any } val 对象的某个key的值\nfunction defineReactive (obj,key,val) {\n  // 如果只传了obj和key，那么val = obj[key]\n  if (arguments.length === 2) {\n    val = obj[key]\n  }\n  if(typeof val === 'object'){\n      new Observer(val)\n  }\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get(){\n      console.log(`${key}属性被读取了`);\n      return val;\n    },\n    set(newVal){\n      if(val === newVal){\n          return\n      }\n      console.log(`${key}属性被修改了`);\n      val = newVal;\n    }\n  })\n}\n````\n上面是数据可观测的过程，上面的代码中我们定义了observer类，它用来将一个正常的object转换成可观测的object。\n并且给value新增一个__ob__属性，值为该value的Observer实例。这个操作相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作\n\n\n然后判断数据的类型，只有object类型的数据才会调用walk将每一个属性转换成getter/setter的形式来侦测变化。 最后，在defineReactive中当传入的属性值还是一个object时使用new observer（val）来递归子属性，这样我们就可以把obj中的所有属性（包括子属性）都转换成getter/seter的形式来侦测变化。 也就是说，只要我们将一个object传到observer中，那么这个object就会变成可观测的、响应式的object。\n\n2.依赖收集\n之后还有依赖收集，我们在上面是实现了数据的可观测性，数据变换之后，还得通知对应的视图层变换，在整个视图层之中知道需要通知的部分，就是“依赖收集”。如果数据变了，就把数据的依赖数组通知变换。\n总结一句话就是:getter()收集依赖 , setter()通知依赖更新\n","plink":"https://edsion11.github.io/2020/04/08/Vue双向绑定/"},{"title":"leetcode每日一题(旋转矩阵)","date":"2020-04-07T15:30:44.000Z","date_formatted":{"ll":"Apr 7, 2020","L":"04/07/2020","MM-DD":"04-07"},"updated":"2022-01-22T09:45:40.643Z","content":"题目描述\n给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。\n不占用额外内存空间能否做到？\n\n第一种算法，引入辅助数组，再复制\n1234567891011121314151617181920212223/** * @param &#123;number[][]&#125; matrix * @return &#123;void&#125; Do not return anything, modify matrix in-place instead. */ var rotate = function (matrix) &#123;  const l = matrix[0].length  const h = matrix.length  var arr = new Array(l)  for (let i = 0; i &lt; l; i++) &#123;    arr[i] = []  &#125;  for (let i = 0; i &lt; matrix[0].length; i++) &#123;    for (let j = 0; j &lt; matrix.length; j++) &#123;      arr[i][j] = matrix[matrix.length - 1 - j][i]    &#125;  &#125;  for (let i = 0; i &lt; h; i++) &#123;    for (let j = 0; j &lt; l; j++) &#123;      matrix[i][j] = arr[i][j]    &#125;  &#125;&#125;\n第二种解法，直接对原数组操作，需要观察规律\n12345678910111213var rotate = function (matrix) &#123;  const length = matrix.length  for (let i = length - 1; i &gt;= 0; i--) &#123;    for (let j = 0; j &lt; length; j++) &#123;      matrix[j].push(matrix[i][j])    &#125;  &#125;  for (let i = 0; i &lt; length; i++) &#123;    matrix[i].splice(0, length)  &#125;&#125;\n","plink":"https://edsion11.github.io/2020/04/07/leetcode每日一题-旋转矩阵/"},{"title":"leetcode-5-最长回文字符串的解法","date":"2020-04-05T11:36:18.000Z","date_formatted":{"ll":"Apr 5, 2020","L":"04/05/2020","MM-DD":"04-05"},"updated":"2022-01-22T09:45:40.642Z","content":"题目：\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设  s 的最大长度为 1000。\n示例一\n123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案\n一.暴力法\n首先就是双重循环，一一遍历的暴力法，直接了当。废话不说，直接上代码。\n12345678910111213141516171819202122var huiwen = function (s)&#123;    if(s.split(&#x27;&#x27;).join()==s.split(&#x27;&#x27;).reverse().join()) return true    return false&#125;var longestPalindrome = function(s) &#123;  if(!s || s.length &lt; 2) return s;    var ans=&#x27;&#x27;;    var max=0;    for(let i =0;i&lt;s.length;i++)&#123;        var str=&#x27;&#x27;        for(let j=i ; j&lt;s.length;j++)&#123;            str+=s[j]            //console.log(str)            if(huiwen(str)&amp;&amp;str.length&gt;=max)&#123;                max=str.length                ans = str                //console.log(ans)            &#125;        &#125;    &#125;    return ans&#125;;\n这是本人自己想的代码，只过了41用例，就超时了，看了看别人的暴力法通过了91用例，道理都差不多，具体应该是str的问题吧。直接到下一种方法动态规划\n二.动态规划\n\n由于还不会在博客写公式，先贴一张leetcode的官方题解思路-动态规划\n\n\n代码如下：\n作者：Alexer-660\n链接：点此直通\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123;    if(!s || s.length &lt; 2)&#123;        return s;    &#125;    var s_f = s.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);    var resultStr = s[0];//放结果    var maxLen = 1;    var tmpLen = 1;    var maxStrIndex = 0;//最大下标    var len = s.length;    //判断字符串是否回文    function isPalinerome(i,r)&#123;        if(len - i - 1 == r -tmpLen + 1)&#123;            return true        &#125;        return false;    &#125;    //初始化二维数组    var len = s.length;    var arr = new Array(len);    for(var i = 0;i&lt;len;i++)&#123;        arr[i] = [];        for(var r = 0;r&lt;len;r++)&#123;            arr[i][r] = 0        &#125;    &#125;    for(var i = 0;i&lt;len;i++)&#123;        for(var r=0;r&lt;len;r++)&#123;            if(s[i] == s_f[r])&#123;                if(i==0 || r==0)&#123;                    arr[i][r] = 1                &#125;else&#123;                    arr[i][r] = arr[i-1][r-1] + 1                    tmpLen = arr[i][r]                &#125;                if(tmpLen &gt; maxLen &amp;&amp; isPalinerome(i,r))&#123;                    maxStrIndex = r;                    maxLen = tmpLen;                    resultStr =  s.substring(i-tmpLen+1,i+1);                &#125;            &#125;        &#125;    &#125;    return resultStr;&#125;;\n运行下来耗时700ms多，占用内存是140MB左右\n思路已经明白，就是根据子串的回文性质，转换为求最长子串问题\n，这又映射到类似的leetcode-3无重复字符的最长子串问题\n题目如下：\n给定一个字符串，请你找出其中不含有重复字符的 最长子串S的长度。\n示例\n123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n在后面博客有讲解：直通\n本次文章到此完毕，谢谢！2020/4/4---研究一下动态规划再补充","plink":"https://edsion11.github.io/2020/04/05/leetcode-5-最长回文字符串的解法/"},{"title":"leetcode-6-Z字形变换","date":"2020-04-04T14:20:29.000Z","date_formatted":{"ll":"Apr 4, 2020","L":"04/04/2020","MM-DD":"04-04"},"updated":"2022-01-22T09:45:40.643Z","content":"题目描述\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：\n123L   C   I   RE T O E S I I GE   D   H   N\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例1：\n12345678输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L     D     RE   O E   I IE C   I H   NT     S     G\n上面是题目的基本介绍，拿到这道题我的思路首先是遍历字符串，但是字符串排列规律一时间不好确定，\n于是通过画图来看，本来思路是创建一个二维数组往进去填字符串，然后最后按行拼接，去除空的就像，然鹅并没有写出填的方法。于是乎打开了leetcode的题解，膜拜了一下大神的写法。先上代码：\n对于大神的代码每行注释以下方便理解\n1234567891011121314151617181920212223242526var convert = function(s, numRows) &#123;    if(numRows == 1)        return s;//向来函数第一先边界判断！！！    const len = Math.min(s.length, numRows);//取字符串长度和Z高的较小值    //console.log(&quot;len=&quot; +len)//输出一下(此行我加的--忽略)    const rows = [];    for(let i = 0; i&lt; len; i++) rows[i] = &quot;&quot;;    //console.log(rows)    let loc = 0;    let down = false;    for(const c of s) &#123;        rows[loc] += c;        if(loc == 0 || loc == numRows - 1)            down = !down;        loc += down ? 1 : -1;    &#125;    let ans = &quot;&quot;;    for(const row of rows) &#123;        ans += row;    &#125;    return ans;&#125;;console.log(convert(&quot;LEETCODEISHIRING&quot;,3))\n图解如下：转自leetcode\n\n这样的解法就是把直接按行输出字符串，无中间空余，作者设了一个down参量来判断是否是“Z”的竖列，每次给rows[0]rows[1]rows[2]......rows[n]字符串值拼接即可得到答案，感觉很巧妙，关键在与rows的设置和down的运用。其他算法相比这个较复杂，这个好理解，等我发现更好的，或者通法再来补充。\n感谢这位leetcode名为灵魂画手作者的奉献\n","plink":"https://edsion11.github.io/2020/04/04/leetcode-6-Z字形变换/"},{"title":"ES6语法总结（一）","date":"2020-04-02T23:18:14.000Z","date_formatted":{"ll":"Apr 2, 2020","L":"04/02/2020","MM-DD":"04-02"},"updated":"2022-01-22T09:45:40.640Z","content":"let 和 const\n在原来的ES5时，定义变量，函数用的var会造成变量提升，于是ES6新增了let和const语法。接下来用代码说明\n1234567891011121314151617var a=[]for (var i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[6]()var b = [];for (let j = 0; j &lt; 10 ;j++)&#123;  b[j] = function () &#123;    console.log(j)  &#125;&#125;b[6]()//输出：106\n上下仅有的不同是for循环里面的 i ， j 定义方式不同，上面定义的 i 为全局变量，for循环结束， i 为10。而下面定义的 j 为局部变量，只在for（）｛｝的作用域内有效，于是形成了上面的结果。\n另外for循环的的设置循环变量括号内部是父作用域，而循环体则是子作用域。---来自阮一峰老师的博客介绍\nvar的变量存在变量提升，什么意思呢，就是var定义的变量，在js运行时，会在运行开始的时候执行一条语句 var a 此时a为undefined，如果在定义a变量之前调用a变量,会显示undefined。而现在ES6为了减少这种情况，同时规范代码，新提出了let指令，let定义的变量，只有在let的块作用域内有效，出了作用域调用就会报错// 报错ReferenceError\n暂时性死区\nES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。即在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。有了这个，typeof就会更加安全，如果let定义之前typeof，会报错，而如果没有定义，则会输出undefined。\n还有一点： let 不允许重复定义，不能同时定义相同的变量两次。\n块作用域\n在ES5中只有全局作用域和局部作用域，带来了很多不合理的场景，所以如今ES6提出了块作用域，强调规范\n第一种场景，内层变量可能会覆盖外层变量。\n第二种场景，用来计数的循环变量泄露为全局变量。(上面开头例子)\n详见阮一峰老师的博客阮一峰-let和const\n关于函数声明\nES5中规定：函数只能在顶层作用域或者函数作用域中声明，不能在块级作用域申明。但是浏览器中还是支持在块级作用域中申明函数，不会报错。\n而ES6引入了块级作用域，规定块级作用域外不可引用作用域内的函数\n12345678910function fnc() &#123;    console.log(&#x27;I am outside!&#x27;);   &#125;(function () &#123;  if (0) &#123;    function f() &#123; console.log(&#x27;I am inside!&#x27;); &#125;  &#125;  f();&#125;());\n上面的代码在ES5中会输出I am inside!，因为类似于var变量，函数会var声明提前，将if作用域内的function会提前至if之前，即 var f = undefined于是在ES6中回报错。\n1234  test.js:10  f();  ^TypeError: f is not a function\n原因是ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。\n\n允许在块级作用域内声明函数。\n函数声明类似于var，即会提升到全局作用域或函数作用域的头部。\n同时，函数声明还会提升到所在的块级作用域的头部。\n\nconst命令\nconst会声明一个只读的变量，不能更改，也不能再定义并且定义的同时要立即赋值。同时const也是存在暂时性死区和块级作用域。与之前let类似\nconst只是定义数据所在的内存地址不能变动，而不是数据不能改动，即如果const定义一个数组或者对象，数组的push()，push()方法依然有效，对象设置属性也正常，但是对const定义的数组或者对象等再次赋值，负责会报错。如果永久冻结，不能变动，有一个冻结方法是Object.freeze\n如果有如下的定义：\n12const foo = Object.freeze(&#123;&#125;);foo.prop = 123;\n正常模式会无效，而严格模式会报错（具体没有尝试，还没有具体碰到两种模式，只是了解）\nES6申明变量6种方法\n\n  var\n  function\n  let\n  const\n  import具体介绍\n  class具体介绍\n\nglobalThis对象\nES6还引入了globalThis对象，用来表示顶层对象，比如浏览器的顶层对象是window，WebWorker的顶层对象是self，Node里面是global\n本次博客主要参考自阮一峰的ECMAScript6入门(一)\n","plink":"https://edsion11.github.io/2020/04/02/ES6语法总结（一）/"},{"title":"浏览器渲染过程（长期更）","date":"2020-04-02T14:03:40.000Z","date_formatted":{"ll":"Apr 2, 2020","L":"04/02/2020","MM-DD":"04-02"},"updated":"2023-10-16T08:07:01.195Z","content":"最近看到很多面试问到了浏览器渲染的原理方面的问题，感觉自己还不熟悉，就来做个总结。\n浏览器的进程与线程\n首先是浏览器的进程与线程：浏览器是多进程的，一个主控进程，同时每一个tab页面都会生成新的进程，Chrome以及新版Edge会有插件进程。\n多线程的浏览器内核\n  每个tab页面可以看做是浏览器内核进程，然后这个进程是多线程的：\n  有以下几类子线程\n GUI线程——就是用户界面进程，渲染用户界面，当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行\n js引擎线程——JavaScript引擎是单线程运行的,浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序.\n 事件触发线程\n 定时器线程\n 网络请求线程\n  \n  首先看看主要的JavaScript引擎\n   1.  如果JS是多线程的方式来操作这些UI , DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS在最初就选择了单线程执行。\n   2.  GUI渲染线程与JS引擎线程互斥的，是由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。由于GUI渲染线程与JS执行线程是互斥的关系，当浏览器在执行JS程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n   在JavaScript引擎运行脚本期间,浏览器渲染线程都是处于挂起状态的,\n  定时触发器线程\n浏览器定时计数器并不是由 JS 引擎计数的, 因为 JS 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。\n   事件触发线程\n  当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。\n  异步http请求线程\n  在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理。\n浏览器的渲染\n用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。\n渲染过程主要有4个步骤\n解析HTML生成DOM树 - 渲染引擎首先解析HTML文档，生成DOM树\nDOM树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。DOM树的根节点就是document对象。\nDOM 树的生成过程中可能会被 CSS 和 JS 的加载执行阻塞，当 HTML 文档解析过程完毕后，浏览器继续进行标记为 deferred 模式的脚本加载，然后就是整个解析过程的实际结束触发 DOMContentLoaded 事件，并在 async 文档文档执行完之后触发 load 事件。\n\n构建Render树 - 接下来不管是内联式，外联式还是嵌入式引入的CSS样式会被解析生成CSSOM树，根据DOM树与CSSOM树生成另外一棵用于渲染的树-渲染树(Render tree)\n生成 DOM 树的同时会生成样式结构体 CSSOM（CSS Object Model）Tree，再根据 CSSOM 和 DOM 树构造渲染树 Render Tree，渲染树包含带有颜色，尺寸等显示属性的矩形，这些矩形的顺序与显示顺序基本一致。从 MVC 的角度来说，可以将 Render 树看成是 V，DOM 树与 CSSOM 树看成是 M，C 则是具体的调度者，比 HTMLDocumentParser 等。\n\n布局Render树 - 然后对渲染树的每个节点进行布局处理，确定其在屏幕上的显示位置\n绘制Render树 - 最后遍历渲染树并用UI后端层将每一个节点绘制出来\n\n下面是一个DOM树和Render树的图\n\n以上步骤是一个渐进的过程，为了提高用户体验，它会在从网络层获取文档内容的同时把已经接收到的局部内容先展示出来。\n布局与绘制\n浏览器进行页面布局基本过程是以浏览器可见区域为画布，左上角为 (0,0)基础坐标，从左到右，从上到下从DOM的根节点开始画，首先确定显示元素的大小跟位置，此过程是通过浏览器计算出来的，用户CSS中定义的量未必就是浏览器实际采用的量。如果显示元素有子元素得先去确定子元素的显示信息。\n布局阶段输出的结果称为 box 盒模型（width,height,margin,padding,border,left,top,…），盒模型精确表示了每一个元素的位置和大小，并且所有相对度量单位此时都转化为了绝对单位。\n在绘制(painting)阶段，渲染引擎会遍历 Render 树，并调用 renderer 的 paint() 方法，将 renderer 的内容显示在屏幕上。绘制工作是使用 UI 后端组件完成的。\n回流与重绘\n\n回流(reflow)：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。reflow 会从 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。\n重绘(repaint)：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重绘，但是元素的几何尺寸没有变。\n每次 Reflow，Repaint 后浏览器还需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。Reflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。\n\n哪些情况会发生回流\n\n页面第一次加载的时候\n改变字体，改变元素尺寸（如果只改变字体颜色，元素背景颜色那么只触发重绘）\n改变元素里面内容的时候\n添加/删除可见DOM元素\nfiexd定位的元素，在拖动滚动条的时候会一直发生回流\n调整窗口大小的时候\n计算offertWidth 和 offsetHeight属性的时候\n\n减少回流和重绘\n\n使用tranform代替top\n使用visibility 代替 display:none\n避免使用table布局\n尽可能在dom树末端改变class\n避免设置多层内联样式\n将动画应用到position属性为absolute或者fixed的元素上\n避免使用CSS表达式\n避免频繁的操作dom\n---2020/4/2\n如何加快首屏加载速度\n\n优化文件大小：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度\n避免资源下载阻塞文档解析：浏览器解析到&lt;script&gt;标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把&lt;script&gt;标签放在底部，或者加上defer、async来进行异步下载\n\n无阻塞脚本（async和defer）\ndefer由HTML4提出，defer 与相比普通 script，有两点区别：\n\n载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后；\n在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载\nasync由HTML5提出\n两者都是采用并行下载javaScript文件，不会产生阻塞。\n不同点在于：async 在加载完成后自动执行  defer需要等待页面加载完成后执行。\n下面贴张图解释：\n\n\n","plink":"https://edsion11.github.io/2020/04/02/浏览器渲染过程（长期更）/"},{"title":"MVC,MVP,MVVM了解","date":"2020-03-31T12:44:52.000Z","date_formatted":{"ll":"Mar 31, 2020","L":"03/31/2020","MM-DD":"03-31"},"updated":"2022-01-22T09:45:40.641Z","content":"MVC\nMVC的概念\nM是指业务模型，V是指业务界面，C是控制器\n\nM即model模型，数据层，负责数据的的处理和获取的数据接口\nV即view视图层，是用户看到并且交互的界面\nC即control控制层，是model和view进行数据交互的桥梁\n\n它们之间的通信用一个图表示：\n\nModel主要负责数据层的接口，View是展示层(GUI)，对于web前端来说所有以html开头的文件都属于这一层，Controller控制层，理论上所有的通信都是单向的。类似于 一个三角形通信结构。所以MVC更适合后端开发，相关发展比较成熟。\n好处：    1.耦合性低。    2.重用性高    3.拓展新好    4.可维护性高\nMVC不适合前端开发：\n\n1.前端的View已经具备了独立处理用户事件的能力，如果每个事件都流经Controller层，这层会变得十分臃肿\n2.MVC中的View和Controller一般都是一一对应的，捆绑起来表示一个组件，视图层和控制层的紧密连接让Controller和View无法复用\n\n\nMVP模式\nMVP(Model-View-Presenter)是MVC的改良版，由IBM的子公司提出\n在MVC中View可以直接操控Model，而在MVP模式中，View只能通过presenter来操控Model，而presenter和View和Model都是双向通信\n与MVC相比，MVP通过解耦View和Model，完全分离视图和模型，使职责划分更清晰\nView不依赖Model，可以将View分离出来做组件，组件化生产，只需要一系列接口提供给上层操作\n\n上图就是MVP模式图\nMVP也存在问题\n\nPresenter作为View和Model的桥梁，除了基本业务逻辑外，还有大量代码需要对View到Model和从Model到View进行“手动同步”，这样显得presenter很重，维护麻烦\n同时由于没有数据绑定，如果Presenter对视图渲染的需求增多，一旦试图需求发生改变，Presenter也需要改动\n\nMVVM的出现\nMVVM提出了ViewModel模型(最早由微软提出)\n关键点在于ViewModel和Model层实现了数据的双向绑定\n\nMVVM首先是将View和Model的同步逻辑自动化了，对应于MVP模式的“手动同步”\n之前presenter负责的View和Model同步不用再手动同步了，而是交给框架提供的数据绑定负责，只需要告诉View显示的数据对应于Model的哪个部分即可。在这之中通过ViewModel进行数据绑定，Model发生变化，ViewModel自动刷新，同时如果ViewModel改变，Model也自动刷新\n总结：\n\n\n整体上看，MVVM比MVC和MVP精简了很多，不仅优化了业务和界面的依赖，还解决了数据频繁更新的问题。\nMVVM中，View不知道Model的存在，ViewModel和Model也察觉不到View，这种低耦合模式，让开发更容易\nMVVM更适合试图更多的前端项目进行工程化开发\n\n\n","plink":"https://edsion11.github.io/2020/03/31/MVC-MVP-MVVM了解/"},{"title":"Ajax交互总结","date":"2020-03-30T14:43:18.000Z","date_formatted":{"ll":"Mar 30, 2020","L":"03/30/2020","MM-DD":"03-30"},"updated":"2022-01-22T09:45:40.640Z","content":"什么是Ajax和JSON，它们的优缺点\n\nAjax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新\n优点：可以实现异步通信效果，页面局部刷新，带来更好的用户体验\nJSON是一种轻量级的数据交换格式，看着像对象，本质是字符串\n优点：轻量级、易于人的阅读和编写，便于js解析，支持复合数据类型\n\nAjax的交互流程有哪几步？\n\n创建ajax对象\nxhr = new XMLHttpRequest\n规定请求地址\nxhr.open(method,url,async)\n等待服务器相应\nxhr.onload\n向服务器发送请求\nxhr.send()\n\n下面是一个验证用户名的ajax例子\n12345678910111213141516171819202122232425262728username.onblur = function()&#123;var usernameValue = username.value;//将usernameValue提交给服务器，有服务器进行唯一性的校验//1、创建对象 兼容处理var xhr = null;if(window.XMLHttpRequest) &#123;\txhr = new XMLHttpRequest();&#125; else &#123;\txhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\t&#125;\t//2、准备发送\txhr.open(&quot;get&quot;,&quot;./server/checkUsername.php?uname=&quot; + usernameValue,true);\t//3、执行发送\txhr.send(null);\t//制定回调函数\txhr.onreadystatechange = function()&#123;\tif(xhr.readyState == 4) &#123;\tif(xhr.status == 200) &#123;\t\tvar result = xhr.responseText;\tvar username_result = document.querySelector(&quot;#username_result&quot;);\tif(result == &quot;ok&quot;) &#123;\tusername_result.innerText = &quot;用户名可以使用&quot;;&#125; else &#123;\t\tusername_result.innerText = &quot;用户名已经被注册&quot;;\t\t &#125;\t  &#125;     &#125;&#125;;\nXMLHttpRequest对象在IE和Firefox中创建方式有没有不同？\n\nIE中通过new ActiveXObject()得到，Firefox中通过newXMLHttpRequest()得到.\n使用jquery封装好的ajax，会避免这些问题\n\n简述ajax的优缺点\n\n优点：\n　　无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）\n　　异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）\n　　前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）\n　　界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）\n　　缺点：\n　　ajax不支持浏览器back按钮\n　　安全问题 Aajax暴露了与服务器交互的细节\n　　对搜索引擎的支持比较弱\n　　破坏了Back与History后退按钮的正常行为等浏览器机制\n\nget与post的区别，什么时候使用post？\nget和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些\n\nget相对post安全性低\nget有缓存，post没有\nget体积小，post可以无限大\nget的url参数可见，post不可见\nget只接受ASCII字符的参数数据类型，post没有限制\nget请求参数会保留历史记录，post中参数不会保留\nget会被浏览器主动catch，post不会，需要手动设置\nget在浏览器回退时无害，post会再次提交请求\n\npost一般用于修改服务器上的资源，对所发送的信息没有限制。比如\n无法使用缓存文件（更新服务器上的文件或数据库）\n向服务器发送大量数据（POST 没有数据量限制）\n发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n\nXMLHttpRequest常用方法和属性\nopen(get/post,url,是否异步)创建http请求\nsend()发送请求给服务器\nsetRequestHeader()设置头信息（使用post才会用到，get并不需要调用该方法）\n常用的属性：\nonreadystatechange 用于监听ajax的工作状态（readyState变化时会调用此方法）\nreadyState 用来存放XMLHttpRequest的状态\nstatus 服务器返回的状态码\nresponseText 服务器返回的文本内容\nreadyState的几个状态\n0：请求未初始化（此时还没有调用open）\n1：服务器连接已建立，已经发送请求开始监听\n2：请求已接收，已经收到服务器返回的内容\n3：请求处理中，解析服务器响应内容\n4：请求已完成，且响应就绪\njquery ajax的实现\n12345678910$.ajax(&#123;     url:发送请求的地址,     data:数据的拼接,//发送到服务器的数据     type:&#x27;get&#x27;,//请求方式，默认get请求     dataType:&#x27;json&#x27;,//服务器返回的数据类型     async:true,//是否异步，默认true     cache:false,//设置为 false 将不会从浏览器缓存中加载请求信息     success:function()&#123;&#125;,//请求成功后的回调函数     error: function()&#123;&#125;//请求失败时调用此函数&#125;)\n不足之处：\n（1）针对MVC的编程,不符合现在前端MVVM的浪潮\n（2）基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案\n同步和异步\n同步：程序运行从上而下，浏览器必须把这个任务执行完毕，才能继续执行下一个任务\n异步：程序运行从上而下，浏览器任务没有执行完，但是可以继续执行下一行代码\n跨域\n跨域的概念：协议、域名、端口都相同才同域，否则都是跨域\n解决跨域问题：\n1.使用JSONP（json+padding）把数据内填充起来\n2.CORS方式（跨域资源共享），在后端上配置可跨域\n3.服务器代理，通过服务器的文件能访问第三方资源\nJSONP原理\najax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。\nAjax和JSONP\najax: { }\njsonp:fn( { } )\najax的数据jsonp不能用，jsonp的数据ajax是可以用的\njsonp本质是通过URL的方式进行请求的，所以它是get方式请求，没有post\n","plink":"https://edsion11.github.io/2020/03/30/Ajax交互总结/"},{"title":"javaScript(一)","date":"2020-03-29T16:56:58.000Z","date_formatted":{"ll":"Mar 29, 2020","L":"03/29/2020","MM-DD":"03-29"},"updated":"2022-01-22T09:45:40.642Z","content":"把多个JavaScript函数绑定到onload时间处理函数上\n假设我有两个函数：firstFunction()和secondFunction()。如果我想让他们俩都在页面加载时得到执行，我该怎么办？如果把他们逐一绑定到onload事件上，他们当中将只有最后那个被执行：\n\nwindow.onload = firstFunction;\nwindow.onload = scondFunction;\n\nsecondFunction将取代firstFunction。所以得出结论：每个事件处理函数只能绑定一条指令\n1234567891011function addLoadEvent(func)&#123;  var oldload = window.onload;  if(typeof window.onload != &#x27;function&#x27;)&#123;    window.onload = fnc;  &#125;else&#123;    window.onload = function()&#123;      oldonload();      func();    &#125;  &#125;&#125;&lt;/span&gt;\n这相当于把那些将在页面加载完毕时执行的函数创建为一个队列。如果想把刚才那两个函数添加到这个队列里去，只需要写如下代码：\n12addLoadEvent(firstFunction)addLoadEvent(secondFunction)\n---未完待续\n","plink":"https://edsion11.github.io/2020/03/29/javaScript-一/"},{"title":"http状态码","date":"2020-03-29T14:40:03.000Z","date_formatted":{"ll":"Mar 29, 2020","L":"03/29/2020","MM-DD":"03-29"},"updated":"2022-01-22T09:45:40.642Z","content":"\n一些常见的状态码有\n1234200       //服务器请求成功403       //服务器理解请求客户端的请求，但是拒绝执行此请求404       //服务器请求的网页不存在503       //服务器不可用\n所有状态解释：\n1XX(临时响应)\n表示临时响应需要请求者继续执行操作的状态码\n\n 100       //服务器收到请求的一部分，正在等待剩余部分\n 101   //请求切换协议，服务器确认并切换\n\n2XX(成功)\n表示响应成功--status\n1234567200       //OK    请求成功。一般用于GET与POST请求201       //Created    已创建。成功请求并创建了新的资源202       //Accepted    已接受。已经接受请求，但未处理完成203       //Non-Authoritative Information    非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204       //无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205       //重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206       //部分内容。服务器成功处理了部分GET请求\n3XX(重定向)\n表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向\n12345678300       //多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301       //永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302       //临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303       // 查看其它地址。与301类似。使用GET和POST请求查看304       // 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305       // 使用代理。所请求的资源必须通过代理访问306       //已经被废弃的HTTP状态码307       //临时重定向。与302类似。使用GET请求重定向\n4XX(请求错误)\n这些状态码表示请求可能出错，妨碍了服务器的处理。\n12345678910111213400       //客户端请求的语法错误，服务器无法理解401       //请求要求用户的身份认证402       //保留，将来使用403       //服务器理解请求客户端的请求，但是拒绝执行此请求404       //服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面405       //客户端请求中的方法被禁止406       //服务器无法根据客户端请求的内容特性完成请求407       //请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权408       //服务器等待客户端发送的请求时间过长，超时409       //服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突410       //客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置411       //服务器无法处理客户端发送的不带Content-Length的请求信息.....\n5XX(服务器错误)\n这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\n123456100       // 服务器内部错误，无法完成请求101       //服务器不支持请求的功能，无法完成请求102       //作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应103       //由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中104       //充当网关或代理的服务器，未及时从远端服务器获取请求105       //服务器不支持请求的HTTP协议的版本，无法完成处理\n强，协商缓存\n顺便记录一下强缓存和协商缓存\n缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。\n\n\n    \n获取资源形式\n状态码\n是否发送请求到服务器\n\n\n强缓存\n从缓存取\n200\n否，直接从缓存取\n\n\n协商缓存\n从缓存取\n状304\n\t\n是，通过服务器来告知缓存是否可用\n\n\n本文链接(https://591616.coding-pages.com/2020/03/29/http状态码/)\n","plink":"https://edsion11.github.io/2020/03/29/http状态码/"},{"title":"高级排序","date":"2020-03-27T15:57:33.000Z","date_formatted":{"ll":"Mar 27, 2020","L":"03/27/2020","MM-DD":"03-27"},"updated":"2022-01-22T09:45:40.644Z","content":" 希尔排序 \n希尔排序的工作原理是，通过定义一个间隔序列来表示在排序过程中进行比较的元素之\n间有多远的间隔。我们可以动态定义间隔序列，不过对于大部分的实际应用场景，算法\n要用到的间隔序列可以提前定义好。有一些公开定义的间隔序列，使用它们会得到不同\n的结果。在这里我们用到了 Marcin Ciura 在他 2001 年发表的论文“Best Increments for the\nAverage Case of Shell Sort”（http:bit.ly/1b04YFv,2001）中定义的间隔序列。这个间隔序列\n是：701, 301, 132, 57, 23, 10, 4, 1。\n首先是希尔排序的js写法\n12345678910111213var arr=[2,3,5,6,2,1,5,123,34,5,66,3,4,2,43,52,45,47,48]var gaps=[5,3,1]function shellSort(arr,gaps)&#123;  for(let g=0;g &lt; gaps.length; ++g)&#123;    for( let i = 0 ; i &lt; arr.length ; ++i)&#123;      var temp = arr[i]      for(var j=i; j &gt;= gaps[g] &amp;&amp; arr[j-gaps[g]] &gt; temp ; j-=gaps[g])&#123;        arr[j]=arr[j-gaps[g]]      &#125;      arr[j]=temp    &#125;  &#125;&#125;\n实际就是:\n外循环控制间隔序列的移动。也就是说，算法在第一次处理数据集时，会检查所有间隔为\n5 的元素。下一次遍历会检查所有间隔为 3 的元素。最后一次则会对间隔为 1 的元素，也\n就是相邻元素执行标准插入排序。在开始做最后一次处理时，大部分元素都将在正确的位\n置，算法就不必对很多元素进行交换。这就是希尔排序比插入排序更高效的地方。图 12-3\n演示了如何使用间隔序列为 5, 3, 1 的希尔排序算法，对一个包含 10 个随机数字的数据集\n合进行排序。\n\n原理图如下：\n\n计算动态间隔序列\n《算法（第 4 版）》（人民邮电出版社）的合著者 Robert Sedgewick 定义了一个 shellsort()\n函数，在这个函数中可以通过一个公式来对希尔排序用到的间隔序列进行动态计算。\nSedgewick 的算法是通过下面的代码片段来决定初始间隔值的：\n\n12345var N = this.dataStore.lengthvar h = 1while (h &lt; N / 3) &#123;  h = 3 * h + 1&#125;\n间隔值确定好后，这个函数就可以像之前定义的 shellsort() 函数一样运行了，唯一的区\n别是，回到外循环之前的最后一条语句会计算一个新的间隔值：\n1h = 3 * h + 1\n举例如下:\n1234567891011121314151617function shellSort (arr)&#123;var N = arr.length;var h = 1;while(h&lt;N/3)&#123;h = h \\* 3 + 1;&#125;while(h&gt;=1)&#123;for(var i=h;i&lt;N;i++)&#123;for(j=i;j &gt; = h &amp;&amp; arr[j] &lt; arr[j-h];j-=h)&#123;var temp = arr[j-h]arr[j-h]=arr[j]arr[j] = temp&#125;&#125;h=(h-1)/3&#125;&#125;\n在运算时间上，前后两个算法相差一个 while()循环来取 gaps[]值，前者设定了[5,3,1],后者通过计算得到 gaps 数组。\n快速排序\n快速排序是处理大数据集最快的排序算法之一，它是一种分而治之的算法，通过递归的方式将数据分解为包含较小元素和较大元素的不同子序列\n这个算法首先要在列表中选择一个元素作为基准值（pivot）。数据排序围绕基准值进行，将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。\n如图所示：\n\n123456789101112131415function QuickSort(arr) &#123;  if (arr.length == 0) return []  var left = []  var right = []  var pivot = arr[0]  for (let i = 1; i &lt; arr.length; i++) &#123;    //此处留意i=1    if (arr[i] &lt; pivot) &#123;      left.push(arr[i])    &#125; else &#123;      right.push(arr[i])    &#125;  &#125;  return QuickSort(left).concat(pivot, QuickSort(right))&#125;\n以下获取每次循环的输出，解释了快速排序的运行原理。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556579,3,93,9,65,94,50,90,12,65基准值：9 当前元素：3移动 3 到左边基准值：9 当前元素：93移动 93 到右边基准值：9 当前元素：9移动 9 到右边基准值：9 当前元素：65移动 65 到右边基准值：9 当前元素：94移动 94 到右边基准值：9 当前元素：50移动 50 到右边基准值：9 当前元素：90移动 90 到右边基准值：9 当前元素：12移动 12 到右边基准值：9 当前元素：65移动 65 到右边基准值：93 当前元素：9移动 9 到左边基准值：93 当前元素：65移动 65 到左边基准值：93 当前元素：94移动 94 到右边基准值：93 当前元素：50移动 50 到左边基准值：93 当前元素：90移动 90 到左边基准值：93 当前元素：12移动 12 到左边基准值：93 当前元素：65移动 65 到左边基准值：9 当前元素：65移动 65 到右边基准值：9 当前元素：50移动 50 到右边基准值：9 当前元素：90移动 90 到右边基准值：9 当前元素：12移动 12 到右边基准值：9 当前元素：65移动 65 到右边基准值：65 当前元素：50移动 50 到左边基准值：65 当前元素：90移动 90 到右边排序算法 ｜ 167基准值：65 当前元素：12移动 12 到左边基准值：65 当前元素：65移动 65 到右边基准值：50 当前元素：12移动 12 到左边基准值：90 当前元素：65移动 65 到左边3,9,9,12,50,65,65,90,93,94\n本次文章到此结束\n","plink":"https://edsion11.github.io/2020/03/27/高级排序/"},{"title":"GET和POST的区别","date":"2020-03-26T18:39:45.000Z","date_formatted":{"ll":"Mar 26, 2020","L":"03/26/2020","MM-DD":"03-26"},"updated":"2022-01-22T09:45:40.640Z","content":"-GET 和 POST 有什么区别？\n-1.首先最直观的是语义上的区别。\n-2.从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。\n-3.从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。\n-4.从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。\n-5.从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同)\n-6.从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 -body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)\n","plink":"https://edsion11.github.io/2020/03/26/GET和POST的区别/"},{"title":"about","date":"2021-02-16T12:42:31.000Z","date_formatted":{"ll":"Feb 16, 2021","L":"02/16/2021","MM-DD":"02-16"},"updated":"2023-10-11T08:56:16.914Z","content":"edsionGu\n喜欢研究学习Angular，React，Rxjs    等前端相关技术知识。\n目前正在开发的个人项目有：\nng-wind：\n\n\n一个使用Angular做SSR渲染的博客静态托管网站，主要使用 tailwindcss作为全局css样式基础,使用markdown-wasm以及highlighjs渲染markdown文件内容。\n\n\n关于markdown渲染有markedjs，这里使用markdown-wasm只是webAssembly在前端项目的尝试.\n\n\n目前的TodoList：\n\nnode中引入wasm进行预渲染(也可以是用其他语言编写的高性能markdown库)\nserverless化接口，目前接口是取mongodb的实验性api，访问速度很慢\n\n使用vercel部署的地址为https://ng-ewind.vercel.app\nrust_algorithm  地址\n在闲暇时间用rust做做算法题，保持rust的手感。\n接下来长期的主要关注点在于前端工程化的混合渲染，即在不同的场景使用不同的渲染逻辑如CSR，SSR以及SSG(prerender),同时保持对跨端方向的关注如tauri以及flutter，skia。\n工作经历\n\n小鹏汽车-广州\n\n教育经历\n\n南京邮电大学 2017～2021\n\n掘金\nhttps://juejin.cn/user/2084329779628551\n","plink":"https://edsion11.github.io/about/"}]